"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble";
exports.ids = ["vendor-chunks/@noble"];
exports.modules = {

/***/ "(ssr)/./node_modules/@noble/hashes/_assert.js":
/*!***********************************************!*\
  !*** ./node_modules/@noble/hashes/_assert.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.anumber = anumber;\nexports.number = anumber;\nexports.abytes = abytes;\nexports.bytes = abytes;\nexports.ahash = ahash;\nexports.aexists = aexists;\nexports.aoutput = aoutput;\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(\"positive integer expected, got \" + n);\n}\n// copied from utils\nfunction isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b)) throw new Error(\"Uint8Array expected\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(\"Uint8Array expected of length \" + lengths + \", got length=\" + b.length);\n}\nfunction ahash(h) {\n    if (typeof h !== \"function\" || typeof h.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(\"digestInto() expects output buffer of length at least \" + min);\n    }\n}\nconst assert = {\n    number: anumber,\n    bytes: abytes,\n    hash: ahash,\n    exists: aexists,\n    output: aoutput\n};\nexports[\"default\"] = assert; //# sourceMappingURL=_assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxlQUFlLEdBQUdFO0FBQ2xCRixjQUFjLEdBQUdFO0FBQ2pCRixjQUFjLEdBQUdJO0FBQ2pCSixhQUFhLEdBQUdJO0FBQ2hCSixhQUFhLEdBQUdNO0FBQ2hCTixlQUFlLEdBQUdPO0FBQ2xCUCxlQUFlLEdBQUdRO0FBQ2xCLFNBQVNOLFFBQVFPLENBQUM7SUFDZCxJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0YsTUFBTUEsSUFBSSxHQUNoQyxNQUFNLElBQUlHLE1BQU0sb0NBQW9DSDtBQUM1RDtBQUNBLG9CQUFvQjtBQUNwQixTQUFTSSxRQUFRQyxDQUFDO0lBQ2QsT0FBT0EsYUFBYUMsY0FBZUMsWUFBWUMsTUFBTSxDQUFDSCxNQUFNQSxFQUFFSSxXQUFXLENBQUNDLElBQUksS0FBSztBQUN2RjtBQUNBLFNBQVNmLE9BQU9nQixDQUFDLEVBQUUsR0FBR0MsT0FBTztJQUN6QixJQUFJLENBQUNSLFFBQVFPLElBQ1QsTUFBTSxJQUFJUixNQUFNO0lBQ3BCLElBQUlTLFFBQVFDLE1BQU0sR0FBRyxLQUFLLENBQUNELFFBQVFFLFFBQVEsQ0FBQ0gsRUFBRUUsTUFBTSxHQUNoRCxNQUFNLElBQUlWLE1BQU0sbUNBQW1DUyxVQUFVLGtCQUFrQkQsRUFBRUUsTUFBTTtBQUMvRjtBQUNBLFNBQVNoQixNQUFNa0IsQ0FBQztJQUNaLElBQUksT0FBT0EsTUFBTSxjQUFjLE9BQU9BLEVBQUVDLE1BQU0sS0FBSyxZQUMvQyxNQUFNLElBQUliLE1BQU07SUFDcEJWLFFBQVFzQixFQUFFRSxTQUFTO0lBQ25CeEIsUUFBUXNCLEVBQUVHLFFBQVE7QUFDdEI7QUFDQSxTQUFTcEIsUUFBUXFCLFFBQVEsRUFBRUMsZ0JBQWdCLElBQUk7SUFDM0MsSUFBSUQsU0FBU0UsU0FBUyxFQUNsQixNQUFNLElBQUlsQixNQUFNO0lBQ3BCLElBQUlpQixpQkFBaUJELFNBQVNHLFFBQVEsRUFDbEMsTUFBTSxJQUFJbkIsTUFBTTtBQUN4QjtBQUNBLFNBQVNKLFFBQVF3QixHQUFHLEVBQUVKLFFBQVE7SUFDMUJ4QixPQUFPNEI7SUFDUCxNQUFNQyxNQUFNTCxTQUFTRixTQUFTO0lBQzlCLElBQUlNLElBQUlWLE1BQU0sR0FBR1csS0FBSztRQUNsQixNQUFNLElBQUlyQixNQUFNLDJEQUEyRHFCO0lBQy9FO0FBQ0o7QUFDQSxNQUFNQyxTQUFTO0lBQ1gvQixRQUFRRDtJQUNSRyxPQUFPRDtJQUNQK0IsTUFBTTdCO0lBQ044QixRQUFRN0I7SUFDUjhCLFFBQVE3QjtBQUNaO0FBQ0FSLGtCQUFlLEdBQUdrQyxRQUNsQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tdWx0aXZlcnN4LWRhcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fYXNzZXJ0LmpzPzU4ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFudW1iZXIgPSBhbnVtYmVyO1xuZXhwb3J0cy5udW1iZXIgPSBhbnVtYmVyO1xuZXhwb3J0cy5hYnl0ZXMgPSBhYnl0ZXM7XG5leHBvcnRzLmJ5dGVzID0gYWJ5dGVzO1xuZXhwb3J0cy5haGFzaCA9IGFoYXNoO1xuZXhwb3J0cy5hZXhpc3RzID0gYWV4aXN0cztcbmV4cG9ydHMuYW91dHB1dCA9IGFvdXRwdXQ7XG5mdW5jdGlvbiBhbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIGdvdCAnICsgbik7XG59XG4vLyBjb3BpZWQgZnJvbSB1dGlsc1xuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuZnVuY3Rpb24gYWJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICcgKyBsZW5ndGhzICsgJywgZ290IGxlbmd0aD0nICsgYi5sZW5ndGgpO1xufVxuZnVuY3Rpb24gYWhhc2goaCkge1xuICAgIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBhbnVtYmVyKGgub3V0cHV0TGVuKTtcbiAgICBhbnVtYmVyKGguYmxvY2tMZW4pO1xufVxuZnVuY3Rpb24gYWV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gYW91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYWJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJyArIG1pbik7XG4gICAgfVxufVxuY29uc3QgYXNzZXJ0ID0ge1xuICAgIG51bWJlcjogYW51bWJlcixcbiAgICBieXRlczogYWJ5dGVzLFxuICAgIGhhc2g6IGFoYXNoLFxuICAgIGV4aXN0czogYWV4aXN0cyxcbiAgICBvdXRwdXQ6IGFvdXRwdXQsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhbnVtYmVyIiwibnVtYmVyIiwiYWJ5dGVzIiwiYnl0ZXMiLCJhaGFzaCIsImFleGlzdHMiLCJhb3V0cHV0IiwibiIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsImlzQnl0ZXMiLCJhIiwiVWludDhBcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiYiIsImxlbmd0aHMiLCJsZW5ndGgiLCJpbmNsdWRlcyIsImgiLCJjcmVhdGUiLCJvdXRwdXRMZW4iLCJibG9ja0xlbiIsImluc3RhbmNlIiwiY2hlY2tGaW5pc2hlZCIsImRlc3Ryb3llZCIsImZpbmlzaGVkIiwib3V0IiwibWluIiwiYXNzZXJ0IiwiaGFzaCIsImV4aXN0cyIsIm91dHB1dCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/_md.js":
/*!*******************************************!*\
  !*** ./node_modules/@noble/hashes/_md.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.HashMD = exports.Maj = exports.Chi = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\n/**\n * Polyfill for Safari 14\n */ function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/**\n * Choice: a ? b : c\n */ const Chi = (a, b, c)=>a & b ^ ~a & c;\nexports.Chi = Chi;\n/**\n * Majority function, true if any two inputs is true\n */ const Maj = (a, b, c)=>a & b ^ a & c ^ b & c;\nexports.Maj = Maj;\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */ class HashMD extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, _assert_js_1.aexists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.aexists)(this);\n        (0, _assert_js_1.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.HashMD = HashMD; //# sourceMappingURL=_md.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fbWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBR0EsV0FBVyxHQUFHQSxXQUFXLEdBQUcsS0FBSztBQUNsRCxNQUFNSyxlQUFlQyxtQkFBT0EsQ0FBQyxtRUFBYztBQUMzQyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQywrREFBWTtBQUN2Qzs7Q0FFQyxHQUNELFNBQVNFLGFBQWFDLElBQUksRUFBRUMsVUFBVSxFQUFFVCxLQUFLLEVBQUVVLElBQUk7SUFDL0MsSUFBSSxPQUFPRixLQUFLRCxZQUFZLEtBQUssWUFDN0IsT0FBT0MsS0FBS0QsWUFBWSxDQUFDRSxZQUFZVCxPQUFPVTtJQUNoRCxNQUFNQyxPQUFPQyxPQUFPO0lBQ3BCLE1BQU1DLFdBQVdELE9BQU87SUFDeEIsTUFBTUUsS0FBS0MsT0FBTyxTQUFVSixPQUFRRTtJQUNwQyxNQUFNRyxLQUFLRCxPQUFPZixRQUFRYTtJQUMxQixNQUFNSSxJQUFJUCxPQUFPLElBQUk7SUFDckIsTUFBTVEsSUFBSVIsT0FBTyxJQUFJO0lBQ3JCRixLQUFLVyxTQUFTLENBQUNWLGFBQWFRLEdBQUdILElBQUlKO0lBQ25DRixLQUFLVyxTQUFTLENBQUNWLGFBQWFTLEdBQUdGLElBQUlOO0FBQ3ZDO0FBQ0E7O0NBRUMsR0FDRCxNQUFNUCxNQUFNLENBQUNpQixHQUFHQyxHQUFHQyxJQUFNLElBQUtELElBQU0sQ0FBQ0QsSUFBSUU7QUFDekN2QixXQUFXLEdBQUdJO0FBQ2Q7O0NBRUMsR0FDRCxNQUFNRCxNQUFNLENBQUNrQixHQUFHQyxHQUFHQyxJQUFNLElBQUtELElBQU1ELElBQUlFLElBQU1ELElBQUlDO0FBQ2xEdkIsV0FBVyxHQUFHRztBQUNkOzs7Q0FHQyxHQUNELE1BQU1ELGVBQWVLLFdBQVdpQixJQUFJO0lBQ2hDQyxZQUFZQyxRQUFRLEVBQUVDLFNBQVMsRUFB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SUYsU0FBU0osVUFDVHNDLEdBQUcvQixNQUFNLENBQUNhLEdBQUcsQ0FBQ2I7UUFDbEIsT0FBTytCO0lBQ1g7QUFDSjtBQUNBaEUsY0FBYyxHQUFHRSxRQUNqQiwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tdWx0aXZlcnN4LWRhcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fbWQuanM/NzAxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGFzaE1EID0gZXhwb3J0cy5NYWogPSBleHBvcnRzLkNoaSA9IHZvaWQgMDtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vKipcbiAqIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbiAqL1xuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8qKlxuICogQ2hvaWNlOiBhID8gYiA6IGNcbiAqL1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbmV4cG9ydHMuQ2hpID0gQ2hpO1xuLyoqXG4gKiBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHV0cyBpcyB0cnVlXG4gKi9cbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG5leHBvcnRzLk1haiA9IE1hajtcbi8qKlxuICogTWVya2xlLURhbWdhcmQgaGFzaCBjb25zdHJ1Y3Rpb24gYmFzZSBjbGFzcy5cbiAqIENvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIE1ENSwgUklQRU1ELCBTSEExLCBTSEEyLlxuICovXG5jbGFzcyBIYXNoTUQgZXh0ZW5kcyB1dGlsc19qc18xLkhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmFleGlzdHMpKHRoaXMpO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmFvdXRwdXQpKG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluXG4gICAgICAgIC8vIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFzaE1EID0gSGFzaE1EO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X21kLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkhhc2hNRCIsIk1haiIsIkNoaSIsIl9hc3NlcnRfanNfMSIsInJlcXVpcmUiLCJ1dGlsc19qc18xIiwic2V0QmlnVWludDY0IiwidmlldyIsImJ5dGVPZmZzZXQiLCJpc0xFIiwiXzMybiIsIkJpZ0ludCIsIl91MzJfbWF4Iiwid2giLCJOdW1iZXIiLCJ3bCIsImgiLCJsIiwic2V0VWludDMyIiwiYSIsImIiLCJjIiwiSGFzaCIsImNvbnN0cnVjdG9yIiwiYmxvY2tMZW4iLCJvdXRwdXRMZW4iLCJwYWRPZmZzZXQiLCJmaW5pc2hlZCIsImxlbmd0aCIsInBvcyIsImRlc3Ryb3llZCIsImJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJjcmVhdGVWaWV3IiwidXBkYXRlIiwiZGF0YSIsImFleGlzdHMiLCJ0b0J5dGVzIiwibGVuIiwidGFrZSIsIk1hdGgiLCJtaW4iLCJkYXRhVmlldyIsInByb2Nlc3MiLCJzZXQiLCJzdWJhcnJheSIsInJvdW5kQ2xlYW4iLCJkaWdlc3RJbnRvIiwib3V0IiwiYW91dHB1dCIsImZpbGwiLCJpIiwib3ZpZXciLCJFcnJvciIsIm91dExlbiIsInN0YXRlIiwiZ2V0IiwiZGlnZXN0IiwicmVzIiwic2xpY2UiLCJkZXN0cm95IiwiX2Nsb25lSW50byIsInRvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/_md.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/_u64.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/_u64.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = void 0;\nexports.fromBig = fromBig;\nexports.split = split;\nexports.add = add;\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// BigUint64Array is too slow as per 2024, so we implement it using Uint32Array.\n// TODO: re-check https://issues.chromium.org/issues/42212588\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for(let i = 0; i < lst.length; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s)=>h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l)=>l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, _l)=>h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\nexports.add5H = add5H;\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\nexports[\"default\"] = u64; //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fdTY0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLGVBQWUsR0FBR0EsZUFBZSxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxhQUFhLEdBQUcsS0FBSztBQUNqVUEsZUFBZSxHQUFHcUI7QUFDbEJyQixhQUFhLEdBQUdzQjtBQUNoQnRCLFdBQVcsR0FBR3VCO0FBQ2QsTUFBTUMsYUFBYSxhQUFhLEdBQUdDLE9BQU8sS0FBSyxLQUFLO0FBQ3BELE1BQU1DLE9BQU8sYUFBYSxHQUFHRCxPQUFPO0FBQ3BDLGdGQUFnRjtBQUNoRiw2REFBNkQ7QUFDN0QsU0FBU0osUUFBUU0sQ0FBQyxFQUFFQyxLQUFLLEtBQUs7SUFDMUIsSUFBSUEsSUFDQSxPQUFPO1FBQUVDLEdBQUdDLE9BQU9ILElBQUlIO1FBQWFPLEdBQUdELE9BQU8sS0FBTUosT0FBUUY7SUFBWTtJQUM1RSxPQUFPO1FBQUVLLEdBQUdDLE9BQU8sS0FBTUosT0FBUUYsY0FBYztRQUFHTyxHQUFHRCxPQUFPSCxJQUFJSCxjQUFjO0lBQUU7QUFDcEY7QUFDQSxTQUFTRixNQUFNVSxHQUFHLEVBQUVKLEtBQUssS0FBSztJQUMxQixJQUFJSyxLQUFLLElBQUlDLFlBQVlGLElBQUlHLE1BQU07SUFDbkMsSUFBSUMsS0FBSyxJQUFJRixZQUFZRixJQUFJRyxNQUFNO0lBQ25DLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJTCxJQUFJRyxNQUFNLEVBQUVFLElBQUs7UUFDakMsTUFBTSxFQUFFUixDQUFD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RyxDQUFBQSxPQUFPO0FBQ2pGOUMsYUFBYSxHQUFHSztBQUNoQixNQUFNRCxRQUFRLENBQUN3QyxLQUFLWCxJQUFJUSxJQUFJSSxJQUFJRSxLQUFPLEtBQU1OLEtBQUtJLEtBQUtFLEtBQU0sT0FBTyxLQUFLLEtBQU0sS0FBTTtBQUNyRi9DLGFBQWEsR0FBR0k7QUFDaEIsTUFBTUYsUUFBUSxDQUFDa0MsSUFBSU0sSUFBSUMsSUFBSUcsSUFBSUUsS0FBTyxDQUFDWixPQUFPLEtBQU1NLENBQUFBLE9BQU8sS0FBTUMsQ0FBQUEsT0FBTyxLQUFNRyxDQUFBQSxPQUFPLEtBQU1FLENBQUFBLE9BQU87QUFDbEdoRCxhQUFhLEdBQUdFO0FBQ2hCLE1BQU1DLFFBQVEsQ0FBQ3lDLEtBQUtYLElBQUlRLElBQUlJLElBQUlFLElBQUlFLEtBQU8sS0FBTVIsS0FBS0ksS0FBS0UsS0FBS0UsS0FBTSxPQUFPLEtBQUssS0FBTSxLQUFNO0FBQzlGakQsYUFBYSxHQUFHRztBQUNoQixrQkFBa0I7QUFDbEIsTUFBTStDLE1BQU07SUFDUjdCO0lBQVNDO0lBQU9GO0lBQ2hCRDtJQUFPRDtJQUNQRDtJQUFRRDtJQUFRRDtJQUFRRDtJQUN4QkQ7SUFBU0Q7SUFDVEQ7SUFBUUQ7SUFBUUQ7SUFBUUQ7SUFDeEJlO0lBQUtoQjtJQUFPRDtJQUFPRDtJQUFPRDtJQUFPRDtJQUFPRDtBQUM1QztBQUNBRixrQkFBZSxHQUFHa0QsS0FDbEIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXVsdGl2ZXJzeC1kYXBwLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3U2NC5qcz9kMjcyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGQ1TCA9IGV4cG9ydHMuYWRkNUggPSBleHBvcnRzLmFkZDRIID0gZXhwb3J0cy5hZGQ0TCA9IGV4cG9ydHMuYWRkM0ggPSBleHBvcnRzLmFkZDNMID0gZXhwb3J0cy5yb3RsQkwgPSBleHBvcnRzLnJvdGxCSCA9IGV4cG9ydHMucm90bFNMID0gZXhwb3J0cy5yb3RsU0ggPSBleHBvcnRzLnJvdHIzMkwgPSBleHBvcnRzLnJvdHIzMkggPSBleHBvcnRzLnJvdHJCTCA9IGV4cG9ydHMucm90ckJIID0gZXhwb3J0cy5yb3RyU0wgPSBleHBvcnRzLnJvdHJTSCA9IGV4cG9ydHMuc2hyU0wgPSBleHBvcnRzLnNoclNIID0gZXhwb3J0cy50b0JpZyA9IHZvaWQgMDtcbmV4cG9ydHMuZnJvbUJpZyA9IGZyb21CaWc7XG5leHBvcnRzLnNwbGl0ID0gc3BsaXQ7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbi8vIEJpZ1VpbnQ2NEFycmF5IGlzIHRvbyBzbG93IGFzIHBlciAyMDI0LCBzbyB3ZSBpbXBsZW1lbnQgaXQgdXNpbmcgVWludDMyQXJyYXkuXG4vLyBUT0RPOiByZS1jaGVjayBodHRwczovL2lzc3Vlcy5jaHJvbWl1bS5vcmcvaXNzdWVzLzQyMjEyNTg4XG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuZXhwb3J0cy50b0JpZyA9IHRvQmlnO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuZXhwb3J0cy5zaHJTSCA9IHNoclNIO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuZXhwb3J0cy5zaHJTTCA9IHNoclNMO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuZXhwb3J0cy5yb3RyU0ggPSByb3RyU0g7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuZXhwb3J0cy5yb3RyU0wgPSByb3RyU0w7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmV4cG9ydHMucm90ckJIID0gcm90ckJIO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdHJCTCA9IHJvdHJCTDtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKF9oLCBsKSA9PiBsO1xuZXhwb3J0cy5yb3RyMzJIID0gcm90cjMySDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG5leHBvcnRzLnJvdHIzMkwgPSByb3RyMzJMO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdGxTSCA9IHJvdGxTSDtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdGxTTCA9IHJvdGxTTDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdGxCSCA9IHJvdGxCSDtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuZXhwb3J0cy5yb3RsQkwgPSByb3RsQkw7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5leHBvcnRzLmFkZDNMID0gYWRkM0w7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmV4cG9ydHMuYWRkM0ggPSBhZGQzSDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuZXhwb3J0cy5hZGQ0TCA9IGFkZDRMO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5leHBvcnRzLmFkZDRIID0gYWRkNEg7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuZXhwb3J0cy5hZGQ1TCA9IGFkZDVMO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5leHBvcnRzLmFkZDVIID0gYWRkNUg7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gdTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3U2NC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhZGQ1TCIsImFkZDVIIiwiYWRkNEgiLCJhZGQ0TCIsImFkZDNIIiwiYWRkM0wiLCJyb3RsQkwiLCJyb3RsQkgiLCJyb3RsU0wiLCJyb3RsU0giLCJyb3RyMzJMIiwicm90cjMySCIsInJvdHJCTCIsInJvdHJCSCIsInJvdHJTTCIsInJvdHJTSCIsInNoclNMIiwic2hyU0giLCJ0b0JpZyIsImZyb21CaWciLCJzcGxpdCIsImFkZCIsIlUzMl9NQVNLNjQiLCJCaWdJbnQiLCJfMzJuIiwibiIsImxlIiwiaCIsIk51bWJlciIsImwiLCJsc3QiLCJBaCIsIlVpbnQzMkFycmF5IiwibGVuZ3RoIiwiQWwiLCJpIiwiX2wiLCJzIiwiX2giLCJCaCIsIkJsIiwiQ2wiLCJsb3ciLCJDaCIsIkRsIiwiRGgiLCJFbCIsIkVoIiwidTY0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/cryptoNode.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/cryptoNode.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.crypto = void 0;\n// We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.\n// Falls back to Node.js built-in crypto for Node.js <=v14\n// See utils.ts for details.\n// @ts-ignore\nconst nc = __webpack_require__(/*! node:crypto */ \"node:crypto\");\nexports.crypto = nc && typeof nc === \"object\" && \"webcrypto\" in nc ? nc.webcrypto : nc && typeof nc === \"object\" && \"randomBytes\" in nc ? nc : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG9Ob2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QiwwRUFBMEU7QUFDMUUsMERBQTBEO0FBQzFELDRCQUE0QjtBQUM1QixhQUFhO0FBQ2IsTUFBTUcsS0FBS0MsbUJBQU9BLENBQUMsZ0NBQWE7QUFDaENKLGNBQWMsR0FBR0csTUFBTSxPQUFPQSxPQUFPLFlBQVksZUFBZUEsS0FDMURBLEdBQUdFLFNBQVMsR0FDWkYsTUFBTSxPQUFPQSxPQUFPLFlBQVksaUJBQWlCQSxLQUM3Q0EsS0FDQUcsV0FDVixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tdWx0aXZlcnN4LWRhcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG9Ob2RlLmpzP2RlMDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IHZvaWQgMDtcbi8vIFdlIHByZWZlciBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gbm9kZS5qcyAxNisuXG4vLyBGYWxscyBiYWNrIHRvIE5vZGUuanMgYnVpbHQtaW4gY3J5cHRvIGZvciBOb2RlLmpzIDw9djE0XG4vLyBTZWUgdXRpbHMudHMgZm9yIGRldGFpbHMuXG4vLyBAdHMtaWdub3JlXG5jb25zdCBuYyA9IHJlcXVpcmUoXCJub2RlOmNyeXB0b1wiKTtcbmV4cG9ydHMuY3J5cHRvID0gbmMgJiYgdHlwZW9mIG5jID09PSAnb2JqZWN0JyAmJiAnd2ViY3J5cHRvJyBpbiBuY1xuICAgID8gbmMud2ViY3J5cHRvXG4gICAgOiBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICdyYW5kb21CeXRlcycgaW4gbmNcbiAgICAgICAgPyBuY1xuICAgICAgICA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0b05vZGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3J5cHRvIiwibmMiLCJyZXF1aXJlIiwid2ViY3J5cHRvIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/hmac.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/hmac.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hmac = exports.HMAC = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\n// HMAC (RFC 2104)\nclass HMAC extends utils_js_1.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, _assert_js_1.ahash)(hash);\n        const key = (0, utils_js_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0, _assert_js_1.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.aexists)(this);\n        (0, _assert_js_1.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9obWFjLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxZQUFZLEdBQUdBLFlBQVksR0FBRyxLQUFLO0FBQ25DLE1BQU1JLGVBQWVDLG1CQUFPQSxDQUFDLG1FQUFjO0FBQzNDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLCtEQUFZO0FBQ3ZDLGtCQUFrQjtBQUNsQixNQUFNRixhQUFhRyxXQUFXQyxJQUFJO0lBQzlCQyxZQUFZQyxJQUFJLEVBQUVDLElBQUksQ0FBRTtRQUNwQixLQUFLO1FBQ0wsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDaEIsSUFBR1IsYUFBYVMsS0FBSyxFQUFFSjtRQUN4QixNQUFNSyxNQUFNLENBQUMsR0FBR1IsV0FBV1MsT0FBTyxFQUFFTDtRQUNwQyxJQUFJLENBQUNNLEtBQUssR0FBR1AsS0FBS1EsTUFBTTtRQUN4QixJQUFJLE9BQU8sSUFBSSxDQUFDRCxLQUFLLENBQUNFLE1BQU0sS0FBSyxZQUM3QixNQUFNLElBQUlDLE1BQU07UUFDcEIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSSxDQUFDSixLQUFLLENBQUNJLFFBQVE7UUFDbkMsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSSxDQUFDTCxLQUFLLENBQUNLLFNBQVM7UUFDckMsTUFBTUQsV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFDOUIsTUFBTUUsTUFBTSxJQUFJQyxXQUFXSDtRQUMzQix3Q0FBd0M7UUFDeENFLElBQUlFLEdBQUcsQ0FBQ1YsSUFBSVcsTUFBTSxHQUFHTCxXQUFXWCxLQUFLUSxNQUFNLEdBQUdDLE1BQU0sQ0FBQ0osS0FBS1ksTUFBTSxLQUFLWjtRQUNyRSxJQUFLLElBQUlhLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUM1QkwsR0FBRyxDQUFDSyxFQUFFLElBQUk7UUFDZCxJQUFJLENBQUNYLEtBQUssQ0FBQ0UsTUFBTSxDQUFDSTtRQUNsQixtSEFBbUg7UUFDbkgsSUFBSSxDQUFDTSxLQUFLLEdBQUduQixLQUFLUSxNQUFNO1FBQ3hCLHVDQUF1QztRQUN2QyxJQUFLLElBQUlVLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUM1QkwsR0FBRyxDQUFDSyxFQUFFLElBQUksT0FBTztRQUNyQixJQUFJLENBQUNDLEtBQUssQ0FBQ1YsTUFBTSxDQUFDSTtRQUNsQkEsSUFBSU8sSUFBSSxDQUFDO0lBQ2I7SUFDQVgsT0FBT1ksR0FBRyxFQUFFO1FBQ1AsSUFBRzFCLGFBQWEyQixPQUFPLEVBQUUsSUFBSTtRQUM5QixJQUFJLENBQUNmLEtBQUssQ0FBQ0UsTUFBTSxDQUFDWTtRQUNsQixPQUFPLElBQUk7SUFDZjtJQUNBRSxXQUFXQyxHQUFHLEVBQUU7UUFDWCxJQUFHN0IsYUFBYTJCLE9BQU8sRUFBRSxJQUFJO1FBQzdCLElBQUczQixhQUFhOEIsTUFBTSxFQUFFRCxLQUFLLElBQUksQ0FBQ1osU0FBUztRQUM1QyxJQUFJLENBQUNWLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNLLEtBQUssQ0FBQ2dCLFVBQVUsQ0FBQ0M7UUFDdEIsSUFBSSxDQUFDTCxLQUFLLENBQUNWLE1BQU0sQ0FBQ2U7UUFDbEIsSUFBSSxDQUFDTCxLQUFLLENBQUNJLFVBQVUsQ0FBQ0M7UUFDdEIsSUFBSSxDQUFDRSxPQUFPO0lBQ2hCO0lBQ0FULFNBQVM7UUFDTCxNQUFNTyxNQUFNLElBQUlWLFdBQVcsSUFBSSxDQUFDSyxLQUFLLENBQUNQLFNBQVM7UUFDL0MsSUFBSSxDQUFDVyxVQUFVLENBQUNDO1FBQ2hCLE9BQU9BO0lBQ1g7SUFDQUcsV0FBV0MsRUFBRSxFQUFFO1FBQ1gsbUdBQW1HO1FBQ25HQSxNQUFPQSxDQUFBQSxLQUFLdkMsT0FBT21CLE1BQU0sQ0FBQ25CLE9BQU93QyxjQUFjLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBQztRQUN6RCxNQUFNLEVBQUVWLEtBQUssRUFBRVosS0FBSyxFQUFFTCxRQUFRLEVBQUVDLFNBQVMsRUFBRVEsUUFBUSxFQUFFQyxTQUFTLEVBQUUsR0FBRyxJQUFJO1FBQ3ZFZ0IsS0FBS0E7UUFDTEEsR0FBRzFCLFFBQVEsR0FBR0E7UUFDZDBCLEdBQUd6QixTQUFTLEdBQUdBO1FBQ2Z5QixHQUFHakIsUUFBUSxHQUFHQTtRQUNkaUIsR0FBR2hCLFNBQVMsR0FBR0E7UUFDZmdCLEdBQUdULEtBQUssR0FBR0EsTUFBTVEsVUFBVSxDQUFDQyxHQUFHVCxLQUFLO1FBQ3BDUyxHQUFHckIsS0FBSyxHQUFHQSxNQUFNb0IsVUFBVSxDQUFDQyxHQUFHckIsS0FBSztRQUNwQyxPQUFPcUI7SUFDWDtJQUNBRixVQUFVO1FBQ04sSUFBSSxDQUFDdkIsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ2dCLEtBQUssQ0FBQ08sT0FBTztRQUNsQixJQUFJLENBQUNuQixLQUFLLENBQUNtQixPQUFPO0lBQ3RCO0FBQ0o7QUFDQW5DLFlBQVksR0FBR0c7QUFDZjs7Ozs7Ozs7O0NBU0MsR0FDRCxNQUFNRCxPQUFPLENBQUNPLE1BQU1LLEtBQUt5QixVQUFZLElBQUlwQyxLQUFLTSxNQUFNSyxLQUFLSSxNQUFNLENBQUNxQixTQUFTYixNQUFNO0FBQy9FMUIsWUFBWSxHQUFHRTtBQUNmRixtQkFBbUIsR0FBRyxDQUFDUyxNQUFNSyxNQUFRLElBQUlYLEtBQUtNLE1BQU1LLE1BQ3BELGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL211bHRpdmVyc3gtZGFwcC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2htYWMuanM/ZTQyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaG1hYyA9IGV4cG9ydHMuSE1BQyA9IHZvaWQgMDtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBITUFDIChSRkMgMjEwNClcbmNsYXNzIEhNQUMgZXh0ZW5kcyB1dGlsc19qc18xLkhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmFoYXNoKShoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYWV4aXN0cykodGhpcyk7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYWJ5dGVzKShvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG5leHBvcnRzLkhNQUMgPSBITUFDO1xuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG4gKiBpbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTInO1xuICogY29uc3QgbWFjMSA9IGhtYWMoc2hhMjU2LCAna2V5JywgJ21lc3NhZ2UnKTtcbiAqL1xuY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuZXhwb3J0cy5obWFjID0gaG1hYztcbmV4cG9ydHMuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJobWFjIiwiSE1BQyIsIl9hc3NlcnRfanNfMSIsInJlcXVpcmUiLCJ1dGlsc19qc18xIiwiSGFzaCIsImNvbnN0cnVjdG9yIiwiaGFzaCIsIl9rZXkiLCJmaW5pc2hlZCIsImRlc3Ryb3llZCIsImFoYXNoIiwia2V5IiwidG9CeXRlcyIsImlIYXNoIiwiY3JlYXRlIiwidXBkYXRlIiwiRXJyb3IiLCJibG9ja0xlbiIsIm91dHB1dExlbiIsInBhZCIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJsZW5ndGgiLCJkaWdlc3QiLCJpIiwib0hhc2giLCJmaWxsIiwiYnVmIiwiYWV4aXN0cyIsImRpZ2VzdEludG8iLCJvdXQiLCJhYnl0ZXMiLCJkZXN0cm95IiwiX2Nsb25lSW50byIsInRvIiwiZ2V0UHJvdG90eXBlT2YiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/pbkdf2.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/pbkdf2.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.pbkdf2 = pbkdf2;\nexports.pbkdf2Async = pbkdf2Async;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/hashes/_assert.js\");\nconst hmac_js_1 = __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/@noble/hashes/hmac.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0, _assert_js_1.ahash)(hash);\n    const opts = (0, utils_js_1.checkOpts)({\n        dkLen: 32,\n        asyncTick: 10\n    }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0, _assert_js_1.anumber)(c);\n    (0, _assert_js_1.anumber)(dkLen);\n    (0, _assert_js_1.anumber)(asyncTick);\n    if (c < 1) throw new Error(\"PBKDF2: iterations (c) should be >= 1\");\n    const password = (0, utils_js_1.toBytes)(_password);\n    const salt = (0, utils_js_1.toBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = hmac_js_1.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return {\n        c,\n        dkLen,\n        asyncTick,\n        DK,\n        PRF,\n        PRFSalt\n    };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW) prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */ function pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0, utils_js_1.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for(let ui = 1; ui < c; ui++){\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nasync function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0, utils_js_1.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, ()=>{\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n} //# sourceMappingURL=pbkdf2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9wYmtkZjIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBR0U7QUFDakJGLG1CQUFtQixHQUFHRztBQUN0QixNQUFNQyxlQUFlQyxtQkFBT0EsQ0FBQyxtRUFBYztBQUMzQyxNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQyw2REFBVztBQUNyQyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQywrREFBWTtBQUN2Qyx3REFBd0Q7QUFDeEQsU0FBU0csV0FBV0MsSUFBSSxFQUFFQyxTQUFTLEVBQUVDLEtBQUssRUFBRUMsS0FBSztJQUM1QyxJQUFHUixhQUFhUyxLQUFLLEVBQUVKO0lBQ3hCLE1BQU1LLE9BQU8sQ0FBQyxHQUFHUCxXQUFXUSxTQUFTLEVBQUU7UUFBRUMsT0FBTztRQUFJQyxXQUFXO0lBQUcsR0FBR0w7SUFDckUsTUFBTSxFQUFFTSxDQUFDLEVBQUVGLEtBQUssRUFBRUMsU0FBUyxFQUFFLEdBQUdIO0lBQy9CLElBQUdWLGFBQWFlLE9BQU8sRUFBRUQ7SUFDekIsSUFBR2QsYUFBYWUsT0FBTyxFQUFFSDtJQUN6QixJQUFHWixhQUFhZSxPQUFPLEVBQUVGO0lBQzFCLElBQUlDLElBQUksR0FDSixNQUFNLElBQUlFLE1BQU07SUFDcEIsTUFBTUMsV0FBVyxDQUFDLEdBQUdkLFdBQVdlLE9BQU8sRUFBRVo7SUFDekMsTUFBTWEsT0FBTyxDQUFDLEdBQUdoQixXQUFXZSxPQUFPLEVBQUVYO0lBQ3JDLDhDQUE4QztJQUM5QyxNQUFNYSxLQUFLLElBQUlDLFdBQVdUO0lBQzFCLDBDQUEwQztJQUMxQyxNQUFNVSxNQUFNcEIsVUFBVXFCLElBQUksQ0FBQ0MsTUFBTSxDQUFDbkIsTUFBTVk7SUFDeEMsTUFBTVEsVUFBVUgsSUFBSUksVUFBVSxHQUFHQyxNQUFNLENBQUNSO0lBQ3hDLE9BQU87UUFBRUw7UUFBR0Y7UUFBT0M7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R0QsR0FBR0ssTUFBTTtRQUM5QixNQUFNLENBQUMsR0FBR3pDLFdBQVc0QyxTQUFTLEVBQUVqQyxJQUFJLEdBQUdELFdBQVc7WUFDOUMsMkJBQTJCO1lBQzNCUyxJQUFJSSxVQUFVLENBQUNHLE1BQU1GLE1BQU0sQ0FBQ0csR0FBR1ksVUFBVSxDQUFDWjtZQUMxQyxJQUFLLElBQUlnQixJQUFJLEdBQUdBLElBQUlQLEdBQUdLLE1BQU0sRUFBRUUsSUFDM0JQLEVBQUUsQ0FBQ08sRUFBRSxJQUFJaEIsQ0FBQyxDQUFDZ0IsRUFBRTtRQUNyQjtJQUNKO0lBQ0EsT0FBT2xCLGFBQWFOLEtBQUtHLFNBQVNMLElBQUlTLE1BQU1DO0FBQ2hELEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXVsdGl2ZXJzeC1kYXBwLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvcGJrZGYyLmpzPzhiY2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBia2RmMiA9IHBia2RmMjtcbmV4cG9ydHMucGJrZGYyQXN5bmMgPSBwYmtkZjJBc3luYztcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCBobWFjX2pzXzEgPSByZXF1aXJlKFwiLi9obWFjLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gQ29tbW9uIHByb2xvZ3VlIGFuZCBlcGlsb2d1ZSBmb3Igc3luYy9hc3luYyBmdW5jdGlvbnNcbmZ1bmN0aW9uIHBia2RmMkluaXQoaGFzaCwgX3Bhc3N3b3JkLCBfc2FsdCwgX29wdHMpIHtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmFoYXNoKShoYXNoKTtcbiAgICBjb25zdCBvcHRzID0gKDAsIHV0aWxzX2pzXzEuY2hlY2tPcHRzKSh7IGRrTGVuOiAzMiwgYXN5bmNUaWNrOiAxMCB9LCBfb3B0cyk7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrIH0gPSBvcHRzO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYW51bWJlcikoYyk7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5hbnVtYmVyKShka0xlbik7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5hbnVtYmVyKShhc3luY1RpY2spO1xuICAgIGlmIChjIDwgMSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQktERjI6IGl0ZXJhdGlvbnMgKGMpIHNob3VsZCBiZSA+PSAxJyk7XG4gICAgY29uc3QgcGFzc3dvcmQgPSAoMCwgdXRpbHNfanNfMS50b0J5dGVzKShfcGFzc3dvcmQpO1xuICAgIGNvbnN0IHNhbHQgPSAoMCwgdXRpbHNfanNfMS50b0J5dGVzKShfc2FsdCk7XG4gICAgLy8gREsgPSBQQktERjIoUFJGLCBQYXNzd29yZCwgU2FsdCwgYywgZGtMZW4pO1xuICAgIGNvbnN0IERLID0gbmV3IFVpbnQ4QXJyYXkoZGtMZW4pO1xuICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgIGNvbnN0IFBSRiA9IGhtYWNfanNfMS5obWFjLmNyZWF0ZShoYXNoLCBwYXNzd29yZCk7XG4gICAgY29uc3QgUFJGU2FsdCA9IFBSRi5fY2xvbmVJbnRvKCkudXBkYXRlKHNhbHQpO1xuICAgIHJldHVybiB7IGMsIGRrTGVuLCBhc3luY1RpY2ssIERLLCBQUkYsIFBSRlNhbHQgfTtcbn1cbmZ1bmN0aW9uIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KSB7XG4gICAgUFJGLmRlc3Ryb3koKTtcbiAgICBQUkZTYWx0LmRlc3Ryb3koKTtcbiAgICBpZiAocHJmVylcbiAgICAgICAgcHJmVy5kZXN0cm95KCk7XG4gICAgdS5maWxsKDApO1xuICAgIHJldHVybiBESztcbn1cbi8qKlxuICogUEJLREYyLUhNQUM6IFJGQyAyODk4IGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gaGFzaCAtIGhhc2ggZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0gcGFzc3dvcmQgLSBwYXNzd29yZCBmcm9tIHdoaWNoIGEgZGVyaXZlZCBrZXkgaXMgZ2VuZXJhdGVkXG4gKiBAcGFyYW0gc2FsdCAtIGNyeXB0b2dyYXBoaWMgc2FsdFxuICogQHBhcmFtIG9wdHMgLSB7YywgZGtMZW59IHdoZXJlIGMgaXMgd29yayBmYWN0b3IgYW5kIGRrTGVuIGlzIG91dHB1dCBtZXNzYWdlIHNpemVcbiAqL1xuZnVuY3Rpb24gcGJrZGYyKGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgREssIFBSRiwgUFJGU2FsdCB9ID0gcGJrZGYySW5pdChoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgbGV0IHByZlc7IC8vIFdvcmtpbmcgY29weVxuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IHZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShhcnIpO1xuICAgIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheShQUkYub3V0cHV0TGVuKTtcbiAgICAvLyBESyA9IFQxICsgVDIgKyDii68gKyBUZGtsZW4vaGxlblxuICAgIGZvciAobGV0IHRpID0gMSwgcG9zID0gMDsgcG9zIDwgZGtMZW47IHRpKyssIHBvcyArPSBQUkYub3V0cHV0TGVuKSB7XG4gICAgICAgIC8vIFRpID0gRihQYXNzd29yZCwgU2FsdCwgYywgaSlcbiAgICAgICAgY29uc3QgVGkgPSBESy5zdWJhcnJheShwb3MsIHBvcyArIFBSRi5vdXRwdXRMZW4pO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIHRpLCBmYWxzZSk7XG4gICAgICAgIC8vIEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpID0gVTEgXiBVMiBeIOKLryBeIFVjXG4gICAgICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgICAgICAocHJmVyA9IFBSRlNhbHQuX2Nsb25lSW50byhwcmZXKSkudXBkYXRlKGFycikuZGlnZXN0SW50byh1KTtcbiAgICAgICAgVGkuc2V0KHUuc3ViYXJyYXkoMCwgVGkubGVuZ3RoKSk7XG4gICAgICAgIGZvciAobGV0IHVpID0gMTsgdWkgPCBjOyB1aSsrKSB7XG4gICAgICAgICAgICAvLyBVYyA9IFBSRihQYXNzd29yZCwgVWPiiJIxKVxuICAgICAgICAgICAgUFJGLl9jbG9uZUludG8ocHJmVykudXBkYXRlKHUpLmRpZ2VzdEludG8odSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRpLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIFRpW2ldIF49IHVbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBia2RmMkFzeW5jKGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgdmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKGFycik7XG4gICAgY29uc3QgdSA9IG5ldyBVaW50OEFycmF5KFBSRi5vdXRwdXRMZW4pO1xuICAgIC8vIERLID0gVDEgKyBUMiArIOKLryArIFRka2xlbi9obGVuXG4gICAgZm9yIChsZXQgdGkgPSAxLCBwb3MgPSAwOyBwb3MgPCBka0xlbjsgdGkrKywgcG9zICs9IFBSRi5vdXRwdXRMZW4pIHtcbiAgICAgICAgLy8gVGkgPSBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKVxuICAgICAgICBjb25zdCBUaSA9IERLLnN1YmFycmF5KHBvcywgcG9zICsgUFJGLm91dHB1dExlbik7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGksIGZhbHNlKTtcbiAgICAgICAgLy8gRihQYXNzd29yZCwgU2FsdCwgYywgaSkgPSBVMSBeIFUyIF4g4ouvIF4gVWNcbiAgICAgICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgICAgIChwcmZXID0gUFJGU2FsdC5fY2xvbmVJbnRvKHByZlcpKS51cGRhdGUoYXJyKS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICBUaS5zZXQodS5zdWJhcnJheSgwLCBUaS5sZW5ndGgpKTtcbiAgICAgICAgYXdhaXQgKDAsIHV0aWxzX2pzXzEuYXN5bmNMb29wKShjIC0gMSwgYXN5bmNUaWNrLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBVYyA9IFBSRihQYXNzd29yZCwgVWPiiJIxKVxuICAgICAgICAgICAgUFJGLl9jbG9uZUludG8ocHJmVykudXBkYXRlKHUpLmRpZ2VzdEludG8odSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRpLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIFRpW2ldIF49IHVbaV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGJrZGYyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBia2RmMiIsInBia2RmMkFzeW5jIiwiX2Fzc2VydF9qc18xIiwicmVxdWlyZSIsImhtYWNfanNfMSIsInV0aWxzX2pzXzEiLCJwYmtkZjJJbml0IiwiaGFzaCIsIl9wYXNzd29yZCIsIl9zYWx0IiwiX29wdHMiLCJhaGFzaCIsIm9wdHMiLCJjaGVja09wdHMiLCJka0xlbiIsImFzeW5jVGljayIsImMiLCJhbnVtYmVyIiwiRXJyb3IiLCJwYXNzd29yZCIsInRvQnl0ZXMiLCJzYWx0IiwiREsiLCJVaW50OEFycmF5IiwiUFJGIiwiaG1hYyIsImNyZWF0ZSIsIlBSRlNhbHQiLCJfY2xvbmVJbnRvIiwidXBkYXRlIiwicGJrZGYyT3V0cHV0IiwicHJmVyIsInUiLCJkZXN0cm95IiwiZmlsbCIsImFyciIsInZpZXciLCJjcmVhdGVWaWV3Iiwib3V0cHV0TGVuIiwidGkiLCJwb3MiLCJUaSIsInN1YmFycmF5Iiwic2V0SW50MzIiLCJkaWdlc3RJbnRvIiwic2V0IiwibGVuZ3RoIiwidWkiLCJpIiwiYXN5bmNMb29wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/pbkdf2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/sha256.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/sha256.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.sha224 = exports.sha256 = exports.SHA256 = void 0;\nconst _md_js_1 = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/@noble/hashes/_md.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per late 2024.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js_1.HashMD {\n    constructor(){\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = sigma0 + (0, _md_js_1.Maj)(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\nexports.SHA256 = SHA256;\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor(){\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */ exports.sha256 = (0, utils_js_1.wrapConstructor)(()=>new SHA256());\n/**\n * SHA2-224 hash function\n */ exports.sha224 = (0, utils_js_1.wrapConstructor)(()=>new SHA224()); //# sourceMappingURL=sha256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyNTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUN4RCxNQUFNSyxXQUFXQyxtQkFBT0EsQ0FBQywyREFBVTtBQUNuQyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQywrREFBWTtBQUN2QyxnRUFBZ0U7QUFDaEUsNEVBQTRFO0FBQzVFLG1CQUFtQjtBQUNuQix5RkFBeUY7QUFDekYsa0JBQWtCO0FBQ2xCLE1BQU1FLFdBQVcsYUFBYSxHQUFHLElBQUlDLFlBQVk7SUFDN0M7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0QsaUJBQWlCO0FBQ2pCLHdGQUF3RjtBQUN4RixrQkFBa0I7QUFDbEIsTUFBTUMsWUFBWSxhQUFhLEdBQUcsSUFBSUQsWUFBWTtJQUM5QztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0QsNERBQTREO0FBQzVELG1EQUFtRDtBQUNuRCxNQUFNRSxXQUFXLGFBQWEsR0FBRyxJQUFJRixZQUFZO0FBQ2pELE1BQU1MLGVBQWVDLFNBQVNPLE1BQU07SUFDaENDLGFB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VCxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQztJQUNsQztJQUNBbUIsYUFBYTtRQUNUN0IsU0FBUzhCLElBQUksQ0FBQztJQUNsQjtJQUNBQyxVQUFVO1FBQ04sSUFBSSxDQUFDbkIsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7UUFDOUIsSUFBSSxDQUFDb0IsTUFBTSxDQUFDRixJQUFJLENBQUM7SUFDckI7QUFDSjtBQUNBekMsY0FBYyxHQUFHSTtBQUNqQiw0RUFBNEU7QUFDNUUsTUFBTXdDLGVBQWV4QztJQUNqQlMsYUFBYztRQUNWLEtBQUs7UUFDTCxJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDd0IsU0FBUyxHQUFHO0lBQ3JCO0FBQ0o7QUFDQTs7O0NBR0MsR0FDRDdDLGNBQWMsR0FBRyxDQUFDLEdBQUdPLFdBQVd1QyxlQUFlLEVBQUUsSUFBTSxJQUFJMUM7QUFDM0Q7O0NBRUMsR0FDREosY0FBYyxHQUFHLENBQUMsR0FBR08sV0FBV3VDLGVBQWUsRUFBRSxJQUFNLElBQUlGLFdBQzNELGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL211bHRpdmVyc3gtZGFwcC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTI1Ni5qcz8yOTU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGEyMjQgPSBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHMuU0hBMjU2ID0gdm9pZCAwO1xuY29uc3QgX21kX2pzXzEgPSByZXF1aXJlKFwiLi9fbWQuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBTSEEyLTI1NiBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMgdG8gZXhlY3V0ZSBiaXJ0aGRheSBhdHRhY2suXG4vLyBCVEMgbmV0d29yayBpcyBkb2luZyAyXjcwIGhhc2hlcy9zZWMgKDJeOTUgaGFzaGVzL3llYXIpIGFzIHBlciBsYXRlIDIwMjQuXG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vLyBJbml0aWFsIHN0YXRlOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSVYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgX21kX2pzXzEuSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBTSEEyNTZfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBTSEEyNTZfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBTSEEyNTZfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBTSEEyNTZfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBTSEEyNTZfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBTSEEyNTZfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBTSEEyNTZfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBTSEEyNTZfSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gKDAsIHV0aWxzX2pzXzEucm90cikoVzE1LCA3KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9ICgwLCB1dGlsc19qc18xLnJvdHIpKFcyLCAxNykgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgNikgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShFLCAxMSkgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgKDAsIF9tZF9qc18xLkNoaSkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShBLCAyKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDEzKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArICgwLCBfbWRfanNfMS5NYWopKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuZXhwb3J0cy5TSEEyNTYgPSBTSEEyNTY7XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0cy5zaGEyNTYgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEEyNTYoKSk7XG4vKipcbiAqIFNIQTItMjI0IGhhc2ggZnVuY3Rpb25cbiAqL1xuZXhwb3J0cy5zaGEyMjQgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2hhMjI0Iiwic2hhMjU2IiwiU0hBMjU2IiwiX21kX2pzXzEiLCJyZXF1aXJlIiwidXRpbHNfanNfMSIsIlNIQTI1Nl9LIiwiVWludDMyQXJyYXkiLCJTSEEyNTZfSVYiLCJTSEEyNTZfVyIsIkhhc2hNRCIsImNvbnN0cnVjdG9yIiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJnZXQiLCJzZXQiLCJwcm9jZXNzIiwidmlldyIsIm9mZnNldCIsImkiLCJnZXRVaW50MzIiLCJXMTUiLCJXMiIsInMwIiwicm90ciIsInMxIiwic2lnbWExIiwiVDEiLCJDaGkiLCJzaWdtYTAiLCJUMiIsIk1haiIsInJvdW5kQ2xlYW4iLCJmaWxsIiwiZGVzdHJveSIsImJ1ZmZlciIsIlNIQTIyNCIsIm91dHB1dExlbiIsIndyYXBDb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/sha512.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/sha512.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA384 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA512 = void 0;\nconst _md_js_1 = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/@noble/hashes/_md.js\");\nconst _u64_js_1 = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/@noble/hashes/_u64.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (()=>_u64_js_1.default.split([\n        \"0x428a2f98d728ae22\",\n        \"0x7137449123ef65cd\",\n        \"0xb5c0fbcfec4d3b2f\",\n        \"0xe9b5dba58189dbbc\",\n        \"0x3956c25bf348b538\",\n        \"0x59f111f1b605d019\",\n        \"0x923f82a4af194f9b\",\n        \"0xab1c5ed5da6d8118\",\n        \"0xd807aa98a3030242\",\n        \"0x12835b0145706fbe\",\n        \"0x243185be4ee4b28c\",\n        \"0x550c7dc3d5ffb4e2\",\n        \"0x72be5d74f27b896f\",\n        \"0x80deb1fe3b1696b1\",\n        \"0x9bdc06a725c71235\",\n        \"0xc19bf174cf692694\",\n        \"0xe49b69c19ef14ad2\",\n        \"0xefbe4786384f25e3\",\n        \"0x0fc19dc68b8cd5b5\",\n        \"0x240ca1cc77ac9c65\",\n        \"0x2de92c6f592b0275\",\n        \"0x4a7484aa6ea6e483\",\n        \"0x5cb0a9dcbd41fbd4\",\n        \"0x76f988da831153b5\",\n        \"0x983e5152ee66dfab\",\n        \"0xa831c66d2db43210\",\n        \"0xb00327c898fb213f\",\n        \"0xbf597fc7beef0ee4\",\n        \"0xc6e00bf33da88fc2\",\n        \"0xd5a79147930aa725\",\n        \"0x06ca6351e003826f\",\n        \"0x142929670a0e6e70\",\n        \"0x27b70a8546d22ffc\",\n        \"0x2e1b21385c26c926\",\n        \"0x4d2c6dfc5ac42aed\",\n        \"0x53380d139d95b3df\",\n        \"0x650a73548baf63de\",\n        \"0x766a0abb3c77b2a8\",\n        \"0x81c2c92e47edaee6\",\n        \"0x92722c851482353b\",\n        \"0xa2bfe8a14cf10364\",\n        \"0xa81a664bbc423001\",\n        \"0xc24b8b70d0f89791\",\n        \"0xc76c51a30654be30\",\n        \"0xd192e819d6ef5218\",\n        \"0xd69906245565a910\",\n        \"0xf40e35855771202a\",\n        \"0x106aa07032bbd1b8\",\n        \"0x19a4c116b8d2d0c8\",\n        \"0x1e376c085141ab53\",\n        \"0x2748774cdf8eeb99\",\n        \"0x34b0bcb5e19b48a8\",\n        \"0x391c0cb3c5c95a63\",\n        \"0x4ed8aa4ae3418acb\",\n        \"0x5b9cca4f7763e373\",\n        \"0x682e6ff3d6b2b8a3\",\n        \"0x748f82ee5defb2fc\",\n        \"0x78a5636f43172f60\",\n        \"0x84c87814a1f0ab72\",\n        \"0x8cc702081a6439ec\",\n        \"0x90befffa23631e28\",\n        \"0xa4506cebde82bde9\",\n        \"0xbef9a3f7b2c67915\",\n        \"0xc67178f2e372532b\",\n        \"0xca273eceea26619c\",\n        \"0xd186b8c721c0c207\",\n        \"0xeada7dd6cde0eb1e\",\n        \"0xf57d4f7fee6ed178\",\n        \"0x06f067aa72176fba\",\n        \"0x0a637dc5a2c898a6\",\n        \"0x113f9804bef90dae\",\n        \"0x1b710b35131c471b\",\n        \"0x28db77f523047d84\",\n        \"0x32caab7b40c72493\",\n        \"0x3c9ebe0a15c9bebc\",\n        \"0x431d67c49c100d4c\",\n        \"0x4cc5d4becb3e42b6\",\n        \"0x597f299cfc657e2a\",\n        \"0x5fcb6fab3ad6faec\",\n        \"0x6c44198c4a475817\"\n    ].map((n)=>BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_js_1.HashMD {\n    constructor(){\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [\n            Ah,\n            Al,\n            Bh,\n            Bl,\n            Ch,\n            Cl,\n            Dh,\n            Dl,\n            Eh,\n            El,\n            Fh,\n            Fl,\n            Gh,\n            Gl,\n            Hh,\n            Hl\n        ];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4){\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32(offset += 4);\n        }\n        for(let i = 16; i < 80; i++){\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);\n            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);\n            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for(let i = 0; i < 80; i++){\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = Eh & Fh ^ ~Eh & Gh;\n            const CHIl = El & Fl ^ ~El & Gl;\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);\n            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;\n            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexports.SHA512 = SHA512;\nclass SHA512_224 extends SHA512 {\n    constructor(){\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nexports.SHA512_224 = SHA512_224;\nclass SHA512_256 extends SHA512 {\n    constructor(){\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nexports.SHA512_256 = SHA512_256;\nclass SHA384 extends SHA512 {\n    constructor(){\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nexports.SHA384 = SHA384;\nexports.sha512 = (0, utils_js_1.wrapConstructor)(()=>new SHA512());\nexports.sha512_224 = (0, utils_js_1.wrapConstructor)(()=>new SHA512_224());\nexports.sha512_256 = (0, utils_js_1.wrapConstructor)(()=>new SHA512_256());\nexports.sha384 = (0, utils_js_1.wrapConstructor)(()=>new SHA384()); //# sourceMappingURL=sha512.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGE1MTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUM3SixNQUFNVSxXQUFXQyxtQkFBT0EsQ0FBQywyREFBVTtBQUNuQyxNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQyw2REFBVztBQUNyQyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQywrREFBWTtBQUN2QywwR0FBMEc7QUFDMUcsa0JBQWtCO0FBQ2xCLE1BQU0sQ0FBQ0csV0FBV0MsVUFBVSxHQUFtQixhQUFILEdBQUksS0FBTUgsVUFBVUksT0FBTyxDQUFDQyxLQUFLLENBQUM7UUFDMUU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7S0FDckUsQ0FBQ0MsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQyxPQUFPRCxJQUFHO0FBQ3JCLDREQUE0RDtBQUM1RCxNQUFNRSxhQUFhLGFBQWEsR0FBRyxJQUFJQyxZQUFZO0FBQ25ELE1BQU1DLGFBQWEsYUFBYSxHQUFHLElBQUlELFlBQVk7QUFDbkQsTUFBTWIsZUFBZUMsU0FBU2MsTUFBTTtJQUNoQ0MsYUFBYztRQUNWLEtBQUssQ0FBQyxLQUFLLElBQUksSUFBSTtRQUNuQix3SEFBd0g7UUFDeEgscURBQXFEO1FBQ3JELHlHQUF5RztRQUN6RyxzQ0FBc0M7UUFDdEMsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtJQUMzQjtJQUNBLGtCQUFrQjtJQUNsQkMsTUFBTTtRQUNGLE1BQU0sRUFBRWhCLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRSxHQUFHLElBQUk7UUFDL0UsT0FBTztZQUFDZjtZQUFJQztZQUFJQztZQUFJQztZQUFJQztZQUFJQztZQUFJQztZQUFJQztZQUFJQztZQUFJQztZQUFJQztZQUFJQztZQUFJQztZQUFJQztZQUFJQztZQUFJQztTQUFHO0lBQzNFO0lBQ0Esa0JBQWtCO0lBQ2xCRSxJQUFJakIsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFO1FBQ2hFLElBQUksQ0FBQ2YsRUFBRSxHQUFHQSxLQUFLO1FBQ2YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBLEtBQUs7UUFDZixJQUFJLENBQUNDLEVBQUUsR0FBR0EsS0FBSztRQUNmLElBQUksQ0FBQ0MsRUFBRSxHQUFHQSxLQUFLO1FBQ2YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBLEtBQUs7UUFDZixJQUFJLENBQUNDLEVBQUUsR0FBR0EsS0FBSztRQUNmLElBQUksQ0FBQ0MsRUFBRSxHQUFHQSxLQUFLO1FBQ2YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBLEtBQUs7UUFDZixJQUFJLENBQUNDLEVBQUUsR0FBR0EsS0FBSztRQUNmLElBQUksQ0FBQ0MsRUFBRSxHQUFHQSxLQUFLO1FBQ2YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBLEtBQUs7UUFDZixJQUFJLENBQUNDLEVBQUUsR0FBR0EsS0FBSztRQUNmLElBQUksQ0FBQ0MsRUFBRSxHQUFHQSxLQUFLO1FBQ2YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBLEtBQUs7UUFDZixJQUFJ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LElBQUksQ0FBQ0MsRUFBRSxHQUFHLEdBQUdELEtBQUssR0FBR0MsS0FBSyxFQUFDO1FBQ2pGLEdBQUVtRCxHQUFHbEQsRUFBRSxFQUFFbUQsR0FBR2xELEVBQUUsRUFBRSxHQUFHbkIsVUFBVUksT0FBTyxDQUFDa0UsR0FBRyxDQUFDLElBQUksQ0FBQ3BELEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQ0MsRUFBRSxHQUFHLEdBQUdELEtBQUssR0FBR0MsS0FBSyxFQUFDO1FBQ2pGLEdBQUVpRCxHQUFHaEQsRUFBRSxFQUFFaUQsR0FBR2hELEVBQUUsRUFBRSxHQUFHckIsVUFBVUksT0FBTyxDQUFDa0UsR0FBRyxDQUFDLElBQUksQ0FBQ2xELEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQ0MsRUFBRSxHQUFHLEdBQUdELEtBQUssR0FBR0MsS0FBSyxFQUFDO1FBQ2pGLEdBQUUrQyxHQUFHOUMsRUFBRSxFQUFFK0MsR0FBRzlDLEVBQUUsRUFBRSxHQUFHdkIsVUFBVUksT0FBTyxDQUFDa0UsR0FBRyxDQUFDLElBQUksQ0FBQ2hELEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQ0MsRUFBRSxHQUFHLEdBQUdELEtBQUssR0FBR0MsS0FBSyxFQUFDO1FBQ2pGLEdBQUU2QyxHQUFHNUMsRUFBRSxFQUFFNkMsR0FBRzVDLEVBQUUsRUFBRSxHQUFHekIsVUFBVUksT0FBTyxDQUFDa0UsR0FBRyxDQUFDLElBQUksQ0FBQzlDLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQ0MsRUFBRSxHQUFHLEdBQUdELEtBQUssR0FBR0MsS0FBSyxFQUFDO1FBQ2pGLEdBQUUyQyxHQUFHMUMsRUFBRSxFQUFFMkMsR0FBRzFDLEVBQUUsRUFBRSxHQUFHM0IsVUFBVUksT0FBTyxDQUFDa0UsR0FBRyxDQUFDLElBQUksQ0FBQzVDLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQ0MsRUFBRSxHQUFHLEdBQUdELEtBQUssR0FBR0MsS0FBSyxFQUFDO1FBQ2pGLEdBQUV5QyxHQUFHeEMsRUFBRSxFQUFFeUMsR0FBR3hDLEVBQUUsRUFBRSxHQUFHN0Is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RSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDaUQsU0FBUyxHQUFHO0lBQ3JCO0FBQ0o7QUFDQTFGLGNBQWMsR0FBR007QUFDakJOLGNBQWMsR0FBRyxDQUFDLEdBQUdhLFdBQVc4RSxlQUFlLEVBQUUsSUFBTSxJQUFJbEY7QUFDM0RULGtCQUFrQixHQUFHLENBQUMsR0FBR2EsV0FBVzhFLGVBQWUsRUFBRSxJQUFNLElBQUluRjtBQUMvRFIsa0JBQWtCLEdBQUcsQ0FBQyxHQUFHYSxXQUFXOEUsZUFBZSxFQUFFLElBQU0sSUFBSXBGO0FBQy9EUCxjQUFjLEdBQUcsQ0FBQyxHQUFHYSxXQUFXOEUsZUFBZSxFQUFFLElBQU0sSUFBSXJGLFdBQzNELGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL211bHRpdmVyc3gtZGFwcC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTUxMi5qcz9lNzEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGEzODQgPSBleHBvcnRzLnNoYTUxMl8yNTYgPSBleHBvcnRzLnNoYTUxMl8yMjQgPSBleHBvcnRzLnNoYTUxMiA9IGV4cG9ydHMuU0hBMzg0ID0gZXhwb3J0cy5TSEE1MTJfMjU2ID0gZXhwb3J0cy5TSEE1MTJfMjI0ID0gZXhwb3J0cy5TSEE1MTIgPSB2b2lkIDA7XG5jb25zdCBfbWRfanNfMSA9IHJlcXVpcmUoXCIuL19tZC5qc1wiKTtcbmNvbnN0IF91NjRfanNfMSA9IHJlcXVpcmUoXCIuL191NjQuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBSb3VuZCBjb250YW50cyAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgODAgcHJpbWVzIDIuLjQwOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFtTSEE1MTJfS2gsIFNIQTUxMl9LbF0gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IF91NjRfanNfMS5kZWZhdWx0LnNwbGl0KFtcbiAgICAnMHg0MjhhMmY5OGQ3MjhhZTIyJywgJzB4NzEzNzQ0OTEyM2VmNjVjZCcsICcweGI1YzBmYmNmZWM0ZDNiMmYnLCAnMHhlOWI1ZGJhNTgxODlkYmJjJyxcbiAgICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcbiAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcbiAgICAnMHg3MmJlNWQ3NGYyN2I4OTZmJywgJzB4ODBkZWIxZmUzYjE2OTZiMScsICcweDliZGMwNmE3MjVjNzEyMzUnLCAnMHhjMTliZjE3NGNmNjkyNjk0JyxcbiAgICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcbiAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcbiAgICAnMHg5ODNlNTE1MmVlNjZkZmFiJywgJzB4YTgzMWM2NmQyZGI0MzIxMCcsICcweGIwMDMyN2M4OThmYjIxM2YnLCAnMHhiZjU5N2ZjN2JlZWYwZWU0JyxcbiAgICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcbiAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcbiAgICAnMHg2NTBhNzM1NDhiYWY2M2RlJywgJzB4NzY2YTBhYmIzYzc3YjJhOCcsICcweDgxYzJjOTJlNDdlZGFlZTYnLCAnMHg5MjcyMmM4NTE0ODIzNTNiJyxcbiAgICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcbiAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcbiAgICAnMHgxOWE0YzExNmI4ZDJkMGM4JywgJzB4MWUzNzZjMDg1MTQxYWI1MycsICcweDI3NDg3NzRjZGY4ZWViOTknLCAnMHgzNGIwYmNiNWUxOWI0OGE4JyxcbiAgICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcbiAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcbiAgICAnMHg5MGJlZmZmYTIzNjMxZTI4JywgJzB4YTQ1MDZjZWJkZTgyYmRlOScsICcweGJlZjlhM2Y3YjJjNjc5MTUnLCAnMHhjNjcxNzhmMmUzNzI1MzJiJyxcbiAgICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcbiAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcbiAgICAnMHgyOGRiNzdmNTIzMDQ3ZDg0JywgJzB4MzJjYWFiN2I0MGM3MjQ5MycsICcweDNjOWViZTBhMTVjOWJlYmMnLCAnMHg0MzFkNjdjNDljMTAwZDRjJyxcbiAgICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xuXS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY2xhc3MgU0hBNTEyIGV4dGVuZHMgX21kX2pzXzEuSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMTI4LCA2NCwgMTYsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZSB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIC8vIEFsc28gbG9va3MgY2xlYW5lciBhbmQgZWFzaWVyIHRvIHZlcmlmeSB3aXRoIHNwZWMuXG4gICAgICAgIC8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHg2YTA5ZTY2NyB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGYzYmNjOTA4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4YmI2N2FlODUgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHg4NGNhYTczYiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDNjNmVmMzcyIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4ZmU5NGY4MmIgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHhhNTRmZjUzYSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDVmMWQzNmYxIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NTEwZTUyN2YgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhZGU2ODJkMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDliMDU2ODhjIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4MmIzZTZjMWYgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgxZjgzZDlhYiB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweGZiNDFiZDZiIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NWJlMGNkMTkgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHgxMzdlMjE3OSB8IDA7XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCkge1xuICAgICAgICB0aGlzLkFoID0gQWggfCAwO1xuICAgICAgICB0aGlzLkFsID0gQWwgfCAwO1xuICAgICAgICB0aGlzLkJoID0gQmggfCAwO1xuICAgICAgICB0aGlzLkJsID0gQmwgfCAwO1xuICAgICAgICB0aGlzLkNoID0gQ2ggfCAwO1xuICAgICAgICB0aGlzLkNsID0gQ2wgfCAwO1xuICAgICAgICB0aGlzLkRoID0gRGggfCAwO1xuICAgICAgICB0aGlzLkRsID0gRGwgfCAwO1xuICAgICAgICB0aGlzLkVoID0gRWggfCAwO1xuICAgICAgICB0aGlzLkVsID0gRWwgfCAwO1xuICAgICAgICB0aGlzLkZoID0gRmggfCAwO1xuICAgICAgICB0aGlzLkZsID0gRmwgfCAwO1xuICAgICAgICB0aGlzLkdoID0gR2ggfCAwO1xuICAgICAgICB0aGlzLkdsID0gR2wgfCAwO1xuICAgICAgICB0aGlzLkhoID0gSGggfCAwO1xuICAgICAgICB0aGlzLkhsID0gSGwgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXG4gICAgICAgICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczBoID0gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKFcxNWgsIFcxNWwsIDgpIF4gX3U2NF9qc18xLmRlZmF1bHQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICBjb25zdCBzMGwgPSBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0woVzE1aCwgVzE1bCwgOCkgXiBfdTY0X2pzXzEuZGVmYXVsdC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXG4gICAgICAgICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMWggPSBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJCSChXMmgsIFcybCwgNjEpIF4gX3U2NF9qc18xLmRlZmF1bHQuc2hyU0goVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgY29uc3QgczFsID0gX3U2NF9qc18xLmRlZmF1bHQucm90clNMKFcyaCwgVzJsLCAxOSkgXiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyQkwoVzJoLCBXMmwsIDYxKSBeIF91NjRfanNfMS5kZWZhdWx0LnNoclNMKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG4gICAgICAgICAgICBjb25zdCBTVU1sID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IF91NjRfanNfMS5kZWZhdWx0LmFkZDRIKFNVTWwsIHMwaCwgczFoLCBTSEE1MTJfV19IW2kgLSA3XSwgU0hBNTEyX1dfSFtpIC0gMTZdKTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSBTVU1oIHwgMDtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSBTVU1sIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBTMSA6PSAoZSByaWdodHJvdGF0ZSAxNCkgeG9yIChlIHJpZ2h0cm90YXRlIDE4KSB4b3IgKGUgcmlnaHRyb3RhdGUgNDEpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTFoID0gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKEVoLCBFbCwgMTQpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKEVoLCBFbCwgMTgpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90ckJIKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExbCA9IF91NjRfanNfMS5kZWZhdWx0LnJvdHJTTChFaCwgRWwsIDE0KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJTTChFaCwgRWwsIDE4KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJCTChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIC8vY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IENISWggPSAoRWggJiBGaCkgXiAofkVoICYgR2gpO1xuICAgICAgICAgICAgY29uc3QgQ0hJbCA9IChFbCAmIEZsKSBeICh+RWwgJiBHbCk7XG4gICAgICAgICAgICAvLyBUMSA9IEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEE1MTJfS1tpXSArIFNIQTUxMl9XW2ldXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFQxbGwgPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxaCA9IF91NjRfanNfMS5kZWZhdWx0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKEFoLCBBbCwgMjgpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90ckJIKEFoLCBBbCwgMzQpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IF91NjRfanNfMS5kZWZhdWx0LnJvdHJTTChBaCwgQWwsIDI4KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJCTChBaCwgQWwsIDM0KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQoRGggfCAwLCBEbCB8IDAsIFQxaCB8IDAsIFQxbCB8IDApKTtcbiAgICAgICAgICAgIERoID0gQ2ggfCAwO1xuICAgICAgICAgICAgRGwgPSBDbCB8IDA7XG4gICAgICAgICAgICBDaCA9IEJoIHwgMDtcbiAgICAgICAgICAgIENsID0gQmwgfCAwO1xuICAgICAgICAgICAgQmggPSBBaCB8IDA7XG4gICAgICAgICAgICBCbCA9IEFsIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IEFsbCA9IF91NjRfanNfMS5kZWZhdWx0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XG4gICAgICAgICAgICBBaCA9IF91NjRfanNfMS5kZWZhdWx0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IF91NjRfanNfMS5kZWZhdWx0LmFkZCh0aGlzLkFoIHwgMCwgdGhpcy5BbCB8IDAsIEFoIHwgMCwgQWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEJoLCBsOiBCbCB9ID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgQmggfCAwLCBCbCB8IDApKTtcbiAgICAgICAgKHsgaDogQ2gsIGw6IENsIH0gPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IF91NjRfanNfMS5kZWZhdWx0LmFkZCh0aGlzLkRoIHwgMCwgdGhpcy5EbCB8IDAsIERoIHwgMCwgRGwgfCAwKSk7XG4gICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgRWggfCAwLCBFbCB8IDApKTtcbiAgICAgICAgKHsgaDogRmgsIGw6IEZsIH0gPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IF91NjRfanNfMS5kZWZhdWx0LmFkZCh0aGlzLkdoIHwgMCwgdGhpcy5HbCB8IDAsIEdoIHwgMCwgR2wgfCAwKSk7XG4gICAgICAgICh7IGg6IEhoLCBsOiBIbCB9ID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgSGggfCAwLCBIbCB8IDApKTtcbiAgICAgICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEE1MTJfV19ILmZpbGwoMCk7XG4gICAgICAgIFNIQTUxMl9XX0wuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5TSEE1MTIgPSBTSEE1MTI7XG5jbGFzcyBTSEE1MTJfMjI0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4OGMzZDM3YzggfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHgxOTU0NGRhMiB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDczZTE5OTY2IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODlkY2Q0ZDYgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgxZGZhYjdhZSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMyZmY5YzgyIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4Njc5ZGQ1MTQgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ODJmOWZjZiB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDBmNmQyYjY5IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4N2JkNDRkYTggfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg3N2UzNmY3MyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDA0YzQ4OTQyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4M2Y5ZDg1YTggfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2YTFkMzZjOCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDExMTJlNmFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4OTFkNjkyYTEgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBNTEyXzIyNCA9IFNIQTUxMl8yMjQ7XG5jbGFzcyBTSEE1MTJfMjU2IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4MjIzMTIxOTQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhmYzJiZjcyYyB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDlmNTU1ZmEzIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4Yzg0YzY0YzIgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgyMzkzYjg2YiB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDZmNTNiMTUxIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4OTYzODc3MTkgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1OTQwZWFiZCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDk2MjgzZWUyIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4YTg4ZWZmZTMgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHhiZTVlMWUyNSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDUzODYzOTkyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4MmIwMTk5ZmMgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHgyYzg1YjhhYSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDBlYjcyZGRjIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4ODFjNTJjYTIgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDMyO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBNTEyXzI1NiA9IFNIQTUxMl8yNTY7XG5jbGFzcyBTSEEzODQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHhjYmJiOWQ1ZCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4NjI5YTI5MmEgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDkxNTkwMTVhIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHgxNTJmZWNkOCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NjczMzI2NjcgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDhlYjQ0YTg3IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHhkYjBjMmUwZCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NDdiNTQ4MWQgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gNDg7XG4gICAgfVxufVxuZXhwb3J0cy5TSEEzODQgPSBTSEEzODQ7XG5leHBvcnRzLnNoYTUxMiA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IFNIQTUxMigpKTtcbmV4cG9ydHMuc2hhNTEyXzIyNCA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IFNIQTUxMl8yMjQoKSk7XG5leHBvcnRzLnNoYTUxMl8yNTYgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEE1MTJfMjU2KCkpO1xuZXhwb3J0cy5zaGEzODQgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEEzODQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGE1MTIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2hhMzg0Iiwic2hhNTEyXzI1NiIsInNoYTUxMl8yMjQiLCJzaGE1MTIiLCJTSEEzODQiLCJTSEE1MTJfMjU2IiwiU0hBNTEyXzIyNCIsIlNIQTUxMiIsIl9tZF9qc18xIiwicmVxdWlyZSIsIl91NjRfanNfMSIsInV0aWxzX2pzXzEiLCJTSEE1MTJfS2giLCJTSEE1MTJfS2wiLCJkZWZhdWx0Iiwic3BsaXQiLCJtYXAiLCJuIiwiQmlnSW50IiwiU0hBNTEyX1dfSCIsIlVpbnQzMkFycmF5IiwiU0hBNTEyX1dfTCIsIkhhc2hNRCIsImNvbnN0cnVjdG9yIiwiQWgiLCJBbCIsIkJoIiwiQmwiLCJDaCIsIkNsIiwiRGgiLCJEbCIsIkVoIiwiRWwiLCJGaCIsIkZsIiwiR2giLCJHbCIsIkhoIiwiSGwiLCJnZXQiLCJzZXQiLCJwcm9jZXNzIiwidmlldyIsIm9mZnNldCIsImkiLCJnZXRVaW50MzIiLCJXMTVoIiwiVzE1bCIsInMwaCIsInJvdHJTSCIsInNoclNIIiwiczBsIiwicm90clNMIiwic2hyU0wiLCJXMmgiLCJXMmwiLCJzMWgiLCJyb3RyQkgiLCJzMWwiLCJyb3RyQkwiLCJTVU1sIiwiYWRkNEwiLCJTVU1oIiwiYWRkNEgiLCJzaWdtYTFoIiwic2lnbWExbCIsIkNISWgiLCJDSElsIiwiVDFsbCIsImFkZDVMIiwiVDFoIiwiYWRkNUgiLCJUMWwiLCJzaWdtYTBoIiwic2lnbWEwbCIsIk1BSmgiLCJNQUpsIiwiaCIsImwiLCJhZGQiLCJBbGwiLCJhZGQzTCIsImFkZDNIIiwicm91bmRDbGVhbiIsImZpbGwiLCJkZXN0cm95IiwiYnVmZmVyIiwib3V0cHV0TGVuIiwid3JhcENvbnN0cnVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/sha512.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/@noble/hashes/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Hash = exports.nextTick = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\nexports.isBytes = isBytes;\nexports.byteSwap32 = byteSwap32;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.asyncLoop = asyncLoop;\nexports.utf8ToBytes = utf8ToBytes;\nexports.toBytes = toBytes;\nexports.concatBytes = concatBytes;\nexports.checkOpts = checkOpts;\nexports.wrapConstructor = wrapConstructor;\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\nexports.randomBytes = randomBytes;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@noble/hashes/cryptoNode.js\");\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/hashes/_assert.js\");\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\n// Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift)=>word << 32 - shift | word >>> shift;\nexports.rotr = rotr;\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift)=>word << shift | word >>> 32 - shift >>> 0;\nexports.rotl = rotl;\nexports.isLE = (()=>new Uint8Array(new Uint32Array([\n        0x11223344\n    ]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nconst byteSwap = (word)=>word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;\nexports.byteSwap = byteSwap;\n// Conditionally byte swap if on a big-endian platform\nexports.byteSwapIfBE = exports.isLE ? (n)=>n : (n)=>(0, exports.byteSwap)(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for(let i = 0; i < arr.length; i++){\n        arr[i] = (0, exports.byteSwap)(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    (0, _assert_js_1.abytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(\"utf8ToBytes expected string, got \" + typeof str);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    (0, _assert_js_1.abytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        (0, _assert_js_1.abytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && ({}).toString.call(opts) !== \"[object Object]\") throw new Error(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === \"function\") {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === \"function\") {\n        return crypto_1.crypto.randomBytes(bytesLength);\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLG9FQUFvRSxHQUNwRUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELFlBQVksR0FBR0EsZ0JBQWdCLEdBQUdBLG9CQUFvQixHQUFHQSxnQkFBZ0IsR0FBR0EsWUFBWSxHQUFHQSxZQUFZLEdBQUdBLFlBQVksR0FBR0Esa0JBQWtCLEdBQUdBLFdBQVcsR0FBR0EsVUFBVSxHQUFHLEtBQUs7QUFDOUtBLGVBQWUsR0FBR1k7QUFDbEJaLGtCQUFrQixHQUFHYTtBQUNyQmIsa0JBQWtCLEdBQUdjO0FBQ3JCZCxrQkFBa0IsR0FBR2U7QUFDckJmLGlCQUFpQixHQUFHZ0I7QUFDcEJoQixtQkFBbUIsR0FBR2lCO0FBQ3RCakIsZUFBZSxHQUFHa0I7QUFDbEJsQixtQkFBbUIsR0FBR21CO0FBQ3RCbkIsaUJBQWlCLEdBQUdvQjtBQUNwQnBCLHVCQUF1QixHQUFHcUI7QUFDMUJyQiwrQkFBK0IsR0FBR3NCO0FBQ2xDdEIsa0NBQWtDLEdBQUd1QjtBQUNyQ3ZCLG1CQUFtQixHQUFHd0I7QUFDdEIsb0ZBQW9GO0FBQ3BGLHNFQUFzRTtBQUN0RSxrRUFBa0U7QUFDbEUsOERBQThEO0FBQzlELCtEQUErRDtBQUMvRCwyRUFBMkU7QUFDM0UsTUFBTUMsV0FBV0MsbUJBQU9BLENBQUMsOEVBQXNCO0FBQy9DLE1BQU1DLGVBQWVELG1CQUFPQSxDQUFDLG1FQUFjO0FBQzNDLDBDQUEwQztBQUMxQyxvRkFBb0Y7QUFDcEYsU0FBU2QsUUFBUWdCLENBQUM7SUFDZCxPQUFPQSxhQUFhQyxjQUFlQyxZQUFZQyxNQUFNLENBQUNILE1BQU1BLEVBQUVJLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLO0FBQ3ZGO0FBQ0EsK0JBQStCO0FBQy9CLE1BQU10QixLQUFLLENBQUN1QixNQUFRLElBQUlMLFdBQVdLLElBQUlDLE1BQU0sRUFBRUQsSUFBSUUsVUFBVSxF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Q0QsU0FBUzNFLFlBQVltRixjQUFjLEVBQUU7SUFDakMsSUFBSWxGLFNBQVNtRixNQUFNLElBQUksT0FBT25GLFNBQVNtRixNQUFNLENBQUNDLGVBQWUsS0FBSyxZQUFZO1FBQzFFLE9BQU9wRixTQUFTbUYsTUFBTSxDQUFDQyxlQUFlLENBQUMsSUFBSWhGLFdBQVc4RTtJQUMxRDtJQUNBLCtCQUErQjtJQUMvQixJQUFJbEYsU0FBU21GLE1BQU0sSUFBSSxPQUFPbkYsU0FBU21GLE1BQU0sQ0FBQ3BGLFdBQVcsS0FBSyxZQUFZO1FBQ3RFLE9BQU9DLFNBQVNtRixNQUFNLENBQUNwRixXQUFXLENBQUNtRjtJQUN2QztJQUNBLE1BQU0sSUFBSTNDLE1BQU07QUFDcEIsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tdWx0aXZlcnN4LWRhcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy91dGlscy5qcz81NTEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IYXNoID0gZXhwb3J0cy5uZXh0VGljayA9IGV4cG9ydHMuYnl0ZVN3YXBJZkJFID0gZXhwb3J0cy5ieXRlU3dhcCA9IGV4cG9ydHMuaXNMRSA9IGV4cG9ydHMucm90bCA9IGV4cG9ydHMucm90ciA9IGV4cG9ydHMuY3JlYXRlVmlldyA9IGV4cG9ydHMudTMyID0gZXhwb3J0cy51OCA9IHZvaWQgMDtcbmV4cG9ydHMuaXNCeXRlcyA9IGlzQnl0ZXM7XG5leHBvcnRzLmJ5dGVTd2FwMzIgPSBieXRlU3dhcDMyO1xuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG5leHBvcnRzLmFzeW5jTG9vcCA9IGFzeW5jTG9vcDtcbmV4cG9ydHMudXRmOFRvQnl0ZXMgPSB1dGY4VG9CeXRlcztcbmV4cG9ydHMudG9CeXRlcyA9IHRvQnl0ZXM7XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG5leHBvcnRzLmNoZWNrT3B0cyA9IGNoZWNrT3B0cztcbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gd3JhcENvbnN0cnVjdG9yO1xuZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzO1xuZXhwb3J0cy53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzO1xuZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkICgyMDI1LTA0LTMwKSwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9jcnlwdG9cIik7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuLy8gZXhwb3J0IHsgaXNCeXRlcyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG4vLyBXZSBjYW4ndCByZXVzZSBpc0J5dGVzIGZyb20gX2Fzc2VydCwgYmVjYXVzZSBzb21laG93IHRoaXMgY2F1c2VzIGh1Z2UgcGVyZiBpc3N1ZXNcbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiBhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKTtcbn1cbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMudTggPSB1ODtcbmNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbmV4cG9ydHMudTMyID0gdTMyO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5jb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnRzLmNyZWF0ZVZpZXcgPSBjcmVhdGVWaWV3O1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbmV4cG9ydHMucm90ciA9IHJvdHI7XG4vLyBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RsID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCBzaGlmdCkgfCAoKHdvcmQgPj4+ICgzMiAtIHNoaWZ0KSkgPj4+IDApO1xuZXhwb3J0cy5yb3RsID0gcm90bDtcbmV4cG9ydHMuaXNMRSA9ICgoKSA9PiBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0KSgpO1xuLy8gVGhlIGJ5dGUgc3dhcCBvcGVyYXRpb24gZm9yIHVpbnQzMlxuY29uc3QgYnl0ZVN3YXAgPSAod29yZCkgPT4gKCh3b3JkIDw8IDI0KSAmIDB4ZmYwMDAwMDApIHxcbiAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICgod29yZCA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAoKHdvcmQgPj4+IDI0KSAmIDB4ZmYpO1xuZXhwb3J0cy5ieXRlU3dhcCA9IGJ5dGVTd2FwO1xuLy8gQ29uZGl0aW9uYWxseSBieXRlIHN3YXAgaWYgb24gYSBiaWctZW5kaWFuIHBsYXRmb3JtXG5leHBvcnRzLmJ5dGVTd2FwSWZCRSA9IGV4cG9ydHMuaXNMRSA/IChuKSA9PiBuIDogKG4pID0+ICgwLCBleHBvcnRzLmJ5dGVTd2FwKShuKTtcbi8vIEluIHBsYWNlIGJ5dGUgc3dhcCBmb3IgVWludDMyQXJyYXlcbmZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gKDAsIGV4cG9ydHMuYnl0ZVN3YXApKGFycltpXSk7XG4gICAgfVxufVxuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYWJ5dGVzKShieXRlcyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBBOiA2NSwgRjogNzAsIGE6IDk3LCBmOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2gpIHtcbiAgICBpZiAoY2ggPj0gYXNjaWlzLl8wICYmIGNoIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoIC0gYXNjaWlzLl8wOyAvLyAnMicgPT4gNTAtNDhcbiAgICBpZiAoY2ggPj0gYXNjaWlzLkEgJiYgY2ggPD0gYXNjaWlzLkYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuQSAtIDEwKTsgLy8gJ0InID0+IDY2LSg2NS0xMClcbiAgICBpZiAoY2ggPj0gYXNjaWlzLmEgJiYgY2ggPD0gYXNjaWlzLmYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcbiAgICByZXR1cm47XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yOyAvLyBtdWx0aXBseSBmaXJzdCBvY3RldCwgZS5nLiAnYTMnID0+IDEwKjE2KzMgPT4gMTYwICsgMyA9PiAxNjNcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG5leHBvcnRzLm5leHRUaWNrID0gbmV4dFRpY2s7XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5hc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgKDAsIGV4cG9ydHMubmV4dFRpY2spKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJyArIHR5cGVvZiBzdHIpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5mdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5hYnl0ZXMpKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5hYnl0ZXMpKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB7fS50b1N0cmluZy5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8gJiYgdHlwZW9mIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgLy8gTGVnYWN5IE5vZGUuanMgY29tcGF0aWJpbGl0eVxuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8gJiYgdHlwZW9mIGNyeXB0b18xLmNyeXB0by5yYW5kb21CeXRlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuY3J5cHRvLnJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSGFzaCIsIm5leHRUaWNrIiwiYnl0ZVN3YXBJZkJFIiwiYnl0ZVN3YXAiLCJpc0xFIiwicm90bCIsInJvdHIiLCJjcmVhdGVWaWV3IiwidTMyIiwidTgiLCJpc0J5dGVzIiwiYnl0ZVN3YXAzMiIsImJ5dGVzVG9IZXgiLCJoZXhUb0J5dGVzIiwiYXN5bmNMb29wIiwidXRmOFRvQnl0ZXMiLCJ0b0J5dGVzIiwiY29uY2F0Qnl0ZXMiLCJjaGVja09wdHMiLCJ3cmFwQ29uc3RydWN0b3IiLCJ3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyIsIndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzIiwicmFuZG9tQnl0ZXMiLCJjcnlwdG9fMSIsInJlcXVpcmUiLCJfYXNzZXJ0X2pzXzEiLCJhIiwiVWludDhBcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiYXJyIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJVaW50MzJBcnJheSIsIk1hdGgiLCJmbG9vciIsIkRhdGFWaWV3Iiwid29yZCIsInNoaWZ0IiwibiIsImkiLCJsZW5ndGgiLCJoZXhlcyIsIkFycmF5IiwiZnJvbSIsIl8iLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYnl0ZXMiLCJhYnl0ZXMiLCJoZXgiLCJhc2NpaXMiLCJfMCIsIl85IiwiQSIsIkYiLCJmIiwiYXNjaWlUb0Jhc2UxNiIsImNoIiwiRXJyb3IiLCJobCIsImFsIiwiYXJyYXkiLCJhaSIsImhpIiwibjEiLCJjaGFyQ29kZUF0IiwibjIiLCJ1bmRlZmluZWQiLCJjaGFyIiwiaXRlcnMiLCJ0aWNrIiwiY2IiLCJ0cyIsIkRhdGUiLCJub3ciLCJkaWZmIiwic3RyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJkYXRhIiwiYXJyYXlzIiwic3VtIiwicmVzIiwicGFkIiwic2V0IiwiY2xvbmUiLCJfY2xvbmVJbnRvIiwiZGVmYXVsdHMiLCJvcHRzIiwiY2FsbCIsIm1lcmdlZCIsImFzc2lnbiIsImhhc2hDb25zIiwiaGFzaEMiLCJtc2ciLCJ1cGRhdGUiLCJkaWdlc3QiLCJ0bXAiLCJvdXRwdXRMZW4iLCJibG9ja0xlbiIsImNyZWF0ZSIsImJ5dGVzTGVuZ3RoIiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/ed25519/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/ed25519/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: () => (/* binding */ CURVE),\n/* harmony export */   ExtendedPoint: () => (/* binding */ Point),\n/* harmony export */   etc: () => (/* binding */ etc),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getPublicKeyAsync: () => (/* binding */ getPublicKeyAsync),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   signAsync: () => (/* binding */ signAsync),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   verify: () => (/* binding */ verify),\n/* harmony export */   verifyAsync: () => (/* binding */ verifyAsync)\n/* harmony export */ });\n/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ const P = 2n ** 255n - 19n; // ed25519 is twisted edwards curve\nconst N = 2n ** 252n + 27742317777372353535851937790883648493n; // curve's (group) order\nconst Gx = 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an; // base point x\nconst Gy = 0x6666666666666666666666666666666666666666666666666666666666666658n; // base point y\nconst CURVE = {\n    a: -1n,\n    d: 37095705934669439343138083508754565189542113879843219016388785533085940283555n,\n    p: P,\n    n: N,\n    h: 8,\n    Gx,\n    Gy\n};\nconst err = (m = \"\")=>{\n    throw new Error(m);\n}; // error helper, messes-up stack trace\nconst str = (s)=>typeof s === \"string\"; // is string\nconst isu8 = (a)=>a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\nconst au8 = (a, l)=>!isu8(a) || typeof l === \"number\" && l > 0 && a.length !== l ? err(\"Uint8Array of valid length expected\") : a;\nconst u8n = (data)=>new Uint8Array(data); // creates Uint8Array\nconst toU8 = (a, len)=>au8(str(a) ? h2b(a) : u8n(au8(a)), len); // norm(hex/u8a) to u8a\nconst mod = (a, b = P)=>{\n    let r = a % b;\n    return r >= 0n ? r : b + r;\n}; // mod division\nconst isPoint = (p)=>p instanceof Point ? p : err(\"Point expected\"); // is xyzt point\nclass Point {\n    constructor(ex, ey, ez, et){\n        this.ex = ex;\n        this.ey = ey;\n        this.ez = ez;\n        this.et = et;\n    }\n    static fromAffine(p) {\n        return new Point(p.x, p.y, 1n, mod(p.x * p.y));\n    }\n    static fromHex(hex, zip215 = false) {\n        const { d } = CURVE;\n        hex = toU8(hex, 32);\n        const normed = hex.slice(); // copy the array to not mess it up\n        const lastByte = hex[31];\n        normed[31] = lastByte & ~0x80; // adjust first LE byte = last BE byte\n        const y = b2n_LE(normed); // decode as little-endian, convert to num\n        if (zip215 && !(0n <= y && y < 2n ** 256n)) err(\"bad y coord 1\"); // zip215=true  [1..2^256-1]\n        if (!zip215 && !(0n <= y && y < P)) err(\"bad y coord 2\"); // zip215=false [1..P-1]\n        const y2 = mod(y * y); // y\n        const u = mod(y2 - 1n); // u=y-1\n        const v = mod(d * y2 + 1n); // v=dy+1\n        let { isValid, value: x } = uvRatio(u, v); // (uv)(uv)^(p-5)/8; square root\n        if (!isValid) err(\"bad y coordinate 3\"); // not square root: bad point\n        const isXOdd = (x & 1n) === 1n; // adjust sign of x coordinate\n        const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n        if (!zip215 && x === 0n && isLastByteOdd) err(\"bad y coord 3\"); // x=0 and x_0 = 1\n        if (isLastByteOdd !== isXOdd) x = mod(-x);\n        return new Point(x, y, 1n, mod(x * y)); // Z=1, T=xy\n    }\n    get x() {\n        return this.toAffine().x;\n    }\n    get y() {\n        return this.toAffine().y;\n    }\n    equals(other) {\n        const { ex: X1, ey: Y1, ez: Z1 } = this;\n        const { ex: X2, ey: Y2, ez: Z2 } = isPoint(other); // isPoint() checks class equality\n        const X1Z2 = mod(X1 * Z2), X2Z1 = mod(X2 * Z1);\n        const Y1Z2 = mod(Y1 * Z2), Y2Z1 = mod(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    is0() {\n        return this.equals(I);\n    }\n    negate() {\n        return new Point(mod(-this.ex), this.ey, this.ez, mod(-this.et));\n    }\n    double() {\n        const { ex: X1, ey: Y1, ez: Z1 } = this; // Cost: 4M + 4S + 1*a + 6add + 1*2\n        const { a } = CURVE; // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(2n * mod(Z1 * Z1));\n        const D = mod(a * A);\n        const x1y1 = X1 + Y1;\n        const E = mod(mod(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new Point(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this; // Cost: 8M + 1*k + 8add + 1*2.\n        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = isPoint(other); // doesn't check if other on-curve\n        const { a, d } = CURVE; // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3\n        const A = mod(X1 * X2);\n        const B = mod(Y1 * Y2);\n        const C = mod(T1 * d * T2);\n        const D = mod(Z1 * Z2);\n        const E = mod((X1 + Y1) * (X2 + Y2) - A - B);\n        const F = mod(D - C);\n        const G = mod(D + C);\n        const H = mod(B - a * A);\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new Point(X3, Y3, Z3, T3);\n    }\n    mul(n, safe = true) {\n        if (n === 0n) return safe === true ? err(\"cannot multiply by 0\") : I;\n        if (!(typeof n === \"bigint\" && 0n < n && n < N)) err(\"invalid scalar, must be < L\");\n        if (!safe && this.is0() || n === 1n) return this; // safe=true bans 0. safe=false allows 0.\n        if (this.equals(G)) return wNAF(n).p; // use wNAF precomputes for base points\n        let p = I, f = G; // init result point & fake point\n        for(let d = this; n > 0n; d = d.double(), n >>= 1n){\n            if (n & 1n) p = p.add(d); // if bit is present, add to point\n            else if (safe) f = f.add(d); // if not, add to fake for timing safety\n        }\n        return p;\n    }\n    multiply(scalar) {\n        return this.mul(scalar);\n    }\n    clearCofactor() {\n        return this.mul(BigInt(CURVE.h), false);\n    }\n    isSmallOrder() {\n        return this.clearCofactor().is0();\n    }\n    isTorsionFree() {\n        let p = this.mul(N / 2n, false).double(); // ensures the point is not \"bad\".\n        if (N % 2n) p = p.add(this); // P^(N+1)             // P*N == (P*(N/2))*2+P\n        return p.is0();\n    }\n    toAffine() {\n        const { ex: x, ey: y, ez: z } = this; // (x, y, z, t)  (x=x/z, y=y/z, t=xy)\n        if (this.equals(I)) return {\n            x: 0n,\n            y: 1n\n        }; // fast-path for zero point\n        const iz = invert(z); // z^-1: invert z\n        if (mod(z * iz) !== 1n) err(\"invalid inverse\"); // (z * z^-1) must be 1, otherwise bad math\n        return {\n            x: mod(x * iz),\n            y: mod(y * iz)\n        }; // x = x*z^-1; y = y*z^-1\n    }\n    toRawBytes() {\n        const { x, y } = this.toAffine(); // convert to affine 2d point\n        const b = n2b_32LE(y); // encode number to 32 bytes\n        b[31] |= x & 1n ? 0x80 : 0; // store sign in first LE byte\n        return b;\n    }\n    toHex() {\n        return b2h(this.toRawBytes());\n    }\n}\nPoint.BASE = new Point(Gx, Gy, 1n, mod(Gx * Gy)); // Generator / Base point\nPoint.ZERO = new Point(0n, 1n, 1n, 0n); // Identity / Zero point\nconst { BASE: G, ZERO: I } = Point; // Generator, identity points\nconst padh = (num, pad)=>num.toString(16).padStart(pad, \"0\");\nconst b2h = (b)=>Array.from(b).map((e)=>padh(e, 2)).join(\"\"); // bytes to hex\nconst h2b = (hex)=>{\n    const l = hex.length; // error if not string,\n    if (!str(hex) || l % 2) err(\"hex invalid 1\"); // or has odd length like 3, 5.\n    const arr = u8n(l / 2); // create result array\n    for(let i = 0; i < arr.length; i++){\n        const j = i * 2;\n        const h = hex.slice(j, j + 2); // hexByte. slice is faster than substr\n        const b = Number.parseInt(h, 16); // byte, created from string part\n        if (Number.isNaN(b) || b < 0) err(\"hex invalid 2\"); // byte must be valid 0 <= byte < 256\n        arr[i] = b;\n    }\n    return arr;\n};\nconst n2b_32LE = (num)=>h2b(padh(num, 32 * 2)).reverse(); // number to bytes LE\nconst b2n_LE = (b)=>BigInt(\"0x\" + b2h(u8n(au8(b)).reverse())); // bytes LE to num\nconst concatB = (...arrs)=>{\n    const r = u8n(arrs.reduce((sum, a)=>sum + au8(a).length, 0)); // create u8a of summed length\n    let pad = 0; // walk through each array,\n    arrs.forEach((a)=>{\n        r.set(a, pad);\n        pad += a.length;\n    }); // ensure they have proper type\n    return r;\n};\nconst invert = (num, md = P)=>{\n    if (num === 0n || md <= 0n) err(\"no inverse n=\" + num + \" mod=\" + md); // no neg exponent for now\n    let a = mod(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;\n    while(a !== 0n){\n        const q = b / a, r = b % a; // not constant-time\n        const m = x - u * q, n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    return b === 1n ? mod(x, md) : err(\"no inverse\"); // b is gcd at this point\n};\nconst pow2 = (x, power)=>{\n    let r = x;\n    while(power-- > 0n){\n        r *= r;\n        r %= P;\n    }\n    return r;\n};\nconst pow_2_252_3 = (x)=>{\n    const x2 = x * x % P; // x^2,       bits 1\n    const b2 = x2 * x % P; // x^3,       bits 11\n    const b4 = pow2(b2, 2n) * b2 % P; // x^(2^4-1), bits 1111\n    const b5 = pow2(b4, 1n) * x % P; // x^(2^5-1), bits 11111\n    const b10 = pow2(b5, 5n) * b5 % P; // x^(2^10)\n    const b20 = pow2(b10, 10n) * b10 % P; // x^(2^20)\n    const b40 = pow2(b20, 20n) * b20 % P; // x^(2^40)\n    const b80 = pow2(b40, 40n) * b40 % P; // x^(2^80)\n    const b160 = pow2(b80, 80n) * b80 % P; // x^(2^160)\n    const b240 = pow2(b160, 80n) * b80 % P; // x^(2^240)\n    const b250 = pow2(b240, 10n) * b10 % P; // x^(2^250)\n    const pow_p_5_8 = pow2(b250, 2n) * x % P; // < To pow to (p+3)/8, multiply it by x.\n    return {\n        pow_p_5_8,\n        b2\n    };\n};\nconst RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // -1\nconst uvRatio = (u, v)=>{\n    const v3 = mod(v * v * v); // v\n    const v7 = mod(v3 * v3 * v); // v\n    const pow = pow_2_252_3(u * v7).pow_p_5_8; // (uv)^(p-5)/8\n    let x = mod(u * v3 * pow); // (uv)(uv)^(p-5)/8\n    const vx2 = mod(v * x * x); // vx\n    const root1 = x; // First root candidate\n    const root2 = mod(x * RM1); // Second root candidate; RM1 is -1\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * RM1); // There is no valid root, vx = -u-1\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((mod(x) & 1n) === 1n) x = mod(-x); // edIsNegative\n    return {\n        isValid: useRoot1 || useRoot2,\n        value: x\n    };\n};\nconst modL_LE = (hash)=>mod(b2n_LE(hash), N); // modulo L; but little-endian\nlet _shaS;\nconst sha512a = (...m)=>etc.sha512Async(...m); // Async SHA512\nconst sha512s = (...m)=>typeof _shaS === \"function\" ? _shaS(...m) : err(\"etc.sha512Sync not set\");\nconst hash2extK = (hashed)=>{\n    const head = hashed.slice(0, 32); // slice creates a copy, unlike subarray\n    head[0] &= 248; // Clamp bits: 0b1111_1000,\n    head[31] &= 127; // 0b0111_1111,\n    head[31] |= 64; // 0b0100_0000\n    const prefix = hashed.slice(32, 64); // private key \"prefix\"\n    const scalar = modL_LE(head); // modular division over curve order\n    const point = G.mul(scalar); // public key point\n    const pointBytes = point.toRawBytes(); // point serialized to Uint8Array\n    return {\n        head,\n        prefix,\n        scalar,\n        point,\n        pointBytes\n    };\n};\n// RFC8032 5.1.5; getPublicKey async, sync. Hash priv key and extract point.\nconst getExtendedPublicKeyAsync = (priv)=>sha512a(toU8(priv, 32)).then(hash2extK);\nconst getExtendedPublicKey = (priv)=>hash2extK(sha512s(toU8(priv, 32)));\nconst getPublicKeyAsync = (priv)=>getExtendedPublicKeyAsync(priv).then((p)=>p.pointBytes);\nconst getPublicKey = (priv)=>getExtendedPublicKey(priv).pointBytes;\nfunction hashFinish(asynchronous, res) {\n    if (asynchronous) return sha512a(res.hashable).then(res.finish);\n    return res.finish(sha512s(res.hashable));\n}\nconst _sign = (e, rBytes, msg)=>{\n    const { pointBytes: P, scalar: s } = e;\n    const r = modL_LE(rBytes); // r was created outside, reduce it modulo L\n    const R = G.mul(r).toRawBytes(); // R = [r]B\n    const hashable = concatB(R, P, msg); // dom2(F, C) || R || A || PH(M)\n    const finish = (hashed)=>{\n        const S = mod(r + modL_LE(hashed) * s, N); // S = (r + k * s) mod L; 0 <= s < l\n        return au8(concatB(R, n2b_32LE(S)), 64); // 64-byte sig: 32b R.x + 32b LE(S)\n    };\n    return {\n        hashable,\n        finish\n    };\n};\nconst signAsync = async (msg, privKey)=>{\n    const m = toU8(msg); // RFC8032 5.1.6: sign msg with key async\n    const e = await getExtendedPublicKeyAsync(privKey); // pub,prfx\n    const rBytes = await sha512a(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return hashFinish(true, _sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\nconst sign = (msg, privKey)=>{\n    const m = toU8(msg); // RFC8032 5.1.6: sign msg with key sync\n    const e = getExtendedPublicKey(privKey); // pub,prfx\n    const rBytes = sha512s(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return hashFinish(false, _sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\nconst dvo = {\n    zip215: true\n};\nconst _verify = (sig, msg, pub, opts = dvo)=>{\n    msg = toU8(msg); // Message hex str/Bytes\n    sig = toU8(sig, 64); // Signature hex str/Bytes, must be 64 bytes\n    const { zip215 } = opts; // switch between zip215 and rfc8032 verif\n    let A, R, s, SB, hashable = new Uint8Array();\n    try {\n        A = Point.fromHex(pub, zip215); // public key A decoded\n        R = Point.fromHex(sig.slice(0, 32), zip215); // 0 <= R < 2^256: ZIP215 R can be >= P\n        s = b2n_LE(sig.slice(32, 64)); // Decode second half as an integer S\n        SB = G.mul(s, false); // in the range 0 <= s < L\n        hashable = concatB(R.toRawBytes(), A.toRawBytes(), msg); // dom2(F, C) || R || A || PH(M)\n    } catch (error) {}\n    const finish = (hashed)=>{\n        if (SB == null) return false; // false if try-catch catched an error\n        if (!zip215 && A.isSmallOrder()) return false; // false for SBS: Strongly Binding Signature\n        const k = modL_LE(hashed); // decode in little-endian, modulo L\n        const RkA = R.add(A.mul(k, false)); // [8]R + [8][k]A'\n        return RkA.add(SB.negate()).clearCofactor().is0(); // [8][S]B = [8]R + [8][k]A'\n    };\n    return {\n        hashable,\n        finish\n    };\n};\n// RFC8032 5.1.7: verification async, sync\nconst verifyAsync = async (s, m, p, opts = dvo)=>hashFinish(true, _verify(s, m, p, opts));\nconst verify = (s, m, p, opts = dvo)=>hashFinish(false, _verify(s, m, p, opts));\nconst cr = ()=>typeof globalThis === \"object\" && \"crypto\" in globalThis ? globalThis.crypto : undefined;\nconst etc = {\n    bytesToHex: b2h,\n    hexToBytes: h2b,\n    concatBytes: concatB,\n    mod,\n    invert,\n    randomBytes: (len = 32)=>{\n        const crypto = cr(); // Can be shimmed in node.js <= 18 to prevent error:\n        // import { webcrypto } from 'node:crypto';\n        // if (!globalThis.crypto) globalThis.crypto = webcrypto;\n        if (!crypto || !crypto.getRandomValues) err(\"crypto.getRandomValues must be defined\");\n        return crypto.getRandomValues(u8n(len));\n    },\n    sha512Async: async (...messages)=>{\n        const crypto = cr();\n        if (!crypto || !crypto.subtle) err(\"crypto.subtle or etc.sha512Async must be defined\");\n        const m = concatB(...messages);\n        return u8n(await crypto.subtle.digest(\"SHA-512\", m.buffer));\n    },\n    sha512Sync: undefined\n};\nObject.defineProperties(etc, {\n    sha512Sync: {\n        configurable: false,\n        get () {\n            return _shaS;\n        },\n        set (f) {\n            if (!_shaS) _shaS = f;\n        }\n    }\n});\nconst utils = {\n    getExtendedPublicKeyAsync,\n    getExtendedPublicKey,\n    randomPrivateKey: ()=>etc.randomBytes(32),\n    precompute (w = 8, p = G) {\n        p.multiply(3n);\n        w;\n        return p;\n    }\n};\nconst W = 8; // Precomputes-related code. W = window size\nconst precompute = ()=>{\n    const points = []; // 10x sign(), 2x verify(). To achieve this,\n    const windows = 256 / W + 1; // app needs to spend 40ms+ to calculate\n    let p = G, b = p; // a lot of points related to base point G.\n    for(let w = 0; w < windows; w++){\n        b = p; // any time Gx multiplication is done.\n        points.push(b); // They consume 16-32 MiB of RAM.\n        for(let i = 1; i < 2 ** (W - 1); i++){\n            b = b.add(p);\n            points.push(b);\n        }\n        p = b.double(); // Precomputes don't speed-up getSharedKey,\n    } // which multiplies user point by scalar,\n    return points; // when precomputes are using base point\n};\nlet Gpows = undefined; // precomputes for base point G\nconst wNAF = (n)=>{\n    // Compared to other point mult methods,\n    const comp = Gpows || (Gpows = precompute()); // stores 2x less points using subtraction\n    const neg = (cnd, p)=>{\n        let n = p.negate();\n        return cnd ? n : p;\n    }; // negate\n    let p = I, f = G; // f must be G, or could become I in the end\n    const windows = 1 + 256 / W; // W=8 17 windows\n    const wsize = 2 ** (W - 1); // W=8 128 window size\n    const mask = BigInt(2 ** W - 1); // W=8 will create mask 0b11111111\n    const maxNum = 2 ** W; // W=8 256\n    const shiftBy = BigInt(W); // W=8 8\n    for(let w = 0; w < windows; w++){\n        const off = w * wsize;\n        let wbits = Number(n & mask); // extract W bits.\n        n >>= shiftBy; // shift number by W bits.\n        if (wbits > wsize) {\n            wbits -= maxNum;\n            n += 1n;\n        } // split if bits > max: +224 => 256-32\n        const off1 = off, off2 = off + Math.abs(wbits) - 1; // offsets, evaluate both\n        const cnd1 = w % 2 !== 0, cnd2 = wbits < 0; // conditions, evaluate both\n        if (wbits === 0) {\n            f = f.add(neg(cnd1, comp[off1])); // bits are 0: add garbage to fake point\n        } else {\n            p = p.add(neg(cnd2, comp[off2])); // bits are 1: add to result point\n        }\n    }\n    return {\n        p,\n        f\n    }; // return both real and fake points for JIT\n}; // !! you can disable precomputes by commenting-out call of the wNAF() inside Point#mul()\n // envs like browser console\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2VkMjU1MTkvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBLHFFQUFxRSxHQUNyRSxNQUFNQSxJQUFJLEVBQUUsSUFBSSxJQUFJLEdBQUcsR0FBRyxFQUFFLG1DQUFtQztBQUMvRCxNQUFNQyxJQUFJLEVBQUUsSUFBSSxJQUFJLEdBQUcsdUNBQXVDLEVBQUUsd0JBQXdCO0FBQ3hGLE1BQU1DLEtBQUssbUVBQW1FLEVBQUUsZUFBZTtBQUMvRixNQUFNQyxLQUFLLG1FQUFtRSxFQUFFLGVBQWU7QUFDL0YsTUFBTUMsUUFBUTtJQUNWQyxHQUFHLENBQUMsRUFBRTtJQUNOQyxHQUFHLDhFQUE4RTtJQUNqRkMsR0FBR1A7SUFBR1EsR0FBR1A7SUFBR1EsR0FBRztJQUFHUDtJQUFJQztBQUMxQjtBQUNBLE1BQU1PLE1BQU0sQ0FBQ0MsSUFBSSxFQUFFO0lBQU8sTUFBTSxJQUFJQyxNQUFNRDtBQUFJLEdBQUcsc0NBQXNDO0FBQ3ZGLE1BQU1FLE1BQU0sQ0FBQ0MsSUFBTSxPQUFPQSxNQUFNLFVBQVUsWUFBWTtBQUN0RCxNQUFNQyxPQUFPLENBQUNWLElBQU9BLGFBQWFXLGNBQzdCWCxLQUFLLFFBQVEsT0FBT0EsTUFBTSxZQUFZQSxFQUFFWSxXQUFXLENBQUNDLElBQUksS0FBSztBQUNsRSxNQUFNQyxNQUFNLENBQUNkLEdBQUdlLElBQ2YsQ0FBQ0wsS0FBS1YsTUFBTyxPQUFPZSxNQUFNLFlBQVlBLElBQUksS0FBS2YsRUFBRWdCLE1BQU0sS0FBS0QsSUFDekRWLElBQUkseUNBQXlDTDtBQUNqRCxNQUFNaUIsTUFBTSxDQUFDQyxPQUFTLElBQUlQLFdBQVdPLE9BQU8scUJBQXFCO0FBQ2pFLE1BQU1DLE9BQU8sQ0FBQ25CLEdBQUdvQixNQUFRTixJQUFJTixJQUFJUixLQUFLcUIsSUFBSXJCLEtBQUtpQixJQUFJSCxJQUFJZCxLQUFLb0IsTUFBTSx1QkFBdUI7QUFDekYsTUFBTUUsTUFBTSxDQUFD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QjtJQUNsRCxNQUFNUyxPQUFPeEksT0FBTyxLQUFLK0gsSUFBSSxJQUFJLGtDQUFrQztJQUNuRSxNQUFNVSxTQUFTLEtBQUtWLEdBQUcsVUFBVTtJQUNqQyxNQUFNVyxVQUFVMUksT0FBTytILElBQUksUUFBUTtJQUNuQyxJQUFLLElBQUlELElBQUksR0FBR0EsSUFBSUcsU0FBU0gsSUFBSztRQUM5QixNQUFNYSxNQUFNYixJQUFJUztRQUNoQixJQUFJSyxRQUFRbkgsT0FBTy9HLElBQUk4TixPQUFPLGtCQUFrQjtRQUNoRDlOLE1BQU1nTyxTQUFTLDBCQUEwQjtRQUN6QyxJQUFJRSxRQUFRTCxPQUFPO1lBQ2ZLLFNBQVNIO1lBQ1QvTixLQUFLLEVBQUU7UUFDWCxFQUFFLHNDQUFzQztRQUN4QyxNQUFNbU8sT0FBT0YsS0FBS0csT0FBT0gsTUFBTUksS0FBS0MsR0FBRyxDQUFDSixTQUFTLEdBQUcseUJBQXlCO1FBQzdFLE1BQU1LLE9BQU9uQixJQUFJLE1BQU0sR0FBR29CLE9BQU9OLFFBQVEsR0FBRyw0QkFBNEI7UUFDeEUsSUFBSUEsVUFBVSxHQUFHO1lBQ2JoSixJQUFJQSxFQUFFTixHQUFHLENBQUMrSSxJQUFJWSxNQUFNYixJQUFJLENBQUNTLEtBQUssSUFBSSx3Q0FBd0M7UUFDOUUsT0FDSztZQUNEcE8sSUFBSUEsRUFBRTZFLEdBQUcsQ0FBQytJLElBQUlhLE1BQU1kLElBQUksQ0FBQ1UsS0FBSyxJQUFJLGtDQUFrQztRQUN4RTtJQUNKO0lBQ0EsT0FBTztRQUFFck87UUFBR21GO0lBQUUsR0FBRywyQ0FBMkM7QUFDaEUsR0FBRyx5RkFBeUY7QUFFeEIsQ0FBQyw0QkFBNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tdWx0aXZlcnN4LWRhcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2VkMjU1MTkvaW5kZXguanM/OWU2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtZWQyNTUxOSAtIE1JVCBMaWNlbnNlIChjKSAyMDE5IFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgUCA9IDJuICoqIDI1NW4gLSAxOW47IC8vIGVkMjU1MTkgaXMgdHdpc3RlZCBlZHdhcmRzIGN1cnZlXG5jb25zdCBOID0gMm4gKiogMjUybiArIDI3NzQyMzE3Nzc3MzcyMzUzNTM1ODUxOTM3NzkwODgzNjQ4NDkzbjsgLy8gY3VydmUncyAoZ3JvdXApIG9yZGVyXG5jb25zdCBHeCA9IDB4MjE2OTM2ZDNjZDZlNTNmZWMwYTRlMjMxZmRkNmRjNWM2OTJjYzc2MDk1MjVhN2IyYzk1NjJkNjA4ZjI1ZDUxYW47IC8vIGJhc2UgcG9pbnQgeFxuY29uc3QgR3kgPSAweDY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NThuOyAvLyBiYXNlIHBvaW50IHlcbmNvbnN0IENVUlZFID0ge1xuICAgIGE6IC0xbiwgLy8gd2hlcmUgYT0tMSwgZCA9IC0oMTIxNjY1LzEyMTY2NikgPT0gLSgxMjE2NjUgKiBpbnYoMTIxNjY2KSkgbW9kIFBcbiAgICBkOiAzNzA5NTcwNTkzNDY2OTQzOTM0MzEzODA4MzUwODc1NDU2NTE4OTU0MjExMzg3OTg0MzIxOTAxNjM4ODc4NTUzMzA4NTk0MDI4MzU1NW4sXG4gICAgcDogUCwgbjogTiwgaDogOCwgR3gsIEd5IC8vIGZpZWxkIHByaW1lLCBjdXJ2ZSAoZ3JvdXApIG9yZGVyLCBjb2ZhY3RvclxufTtcbmNvbnN0IGVyciA9IChtID0gJycpID0+IHsgdGhyb3cgbmV3IEVycm9yKG0pOyB9OyAvLyBlcnJvciBoZWxwZXIsIG1lc3Nlcy11cCBzdGFjayB0cmFjZVxuY29uc3Qgc3RyID0gKHMpID0+IHR5cGVvZiBzID09PSAnc3RyaW5nJzsgLy8gaXMgc3RyaW5nXG5jb25zdCBpc3U4ID0gKGEpID0+IChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG5jb25zdCBhdTggPSAoYSwgbCkgPT4gLy8gaXMgVWludDhBcnJheSAob2Ygc3BlY2lmaWMgbGVuZ3RoKVxuICFpc3U4KGEpIHx8ICh0eXBlb2YgbCA9PT0gJ251bWJlcicgJiYgbCA+IDAgJiYgYS5sZW5ndGggIT09IGwpID9cbiAgICBlcnIoJ1VpbnQ4QXJyYXkgb2YgdmFsaWQgbGVuZ3RoIGV4cGVjdGVkJykgOiBhO1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHRvVTggPSAoYSwgbGVuKSA9PiBhdTgoc3RyKGEpID8gaDJiKGEpIDogdThuKGF1OChhKSksIGxlbik7IC8vIG5vcm0oaGV4L3U4YSkgdG8gdThhXG5jb25zdCBtb2QgPSAoYSwgYiA9IFApID0+IHsgbGV0IHIgPSBhICUgYjsgcmV0dXJuIHIgPj0gMG4gPyByIDogYiArIHI7IH07IC8vIG1vZCBkaXZpc2lvblxuY29uc3QgaXNQb2ludCA9IChwKSA9PiAocCBpbnN0YW5jZW9mIFBvaW50ID8gcCA6IGVycignUG9pbnQgZXhwZWN0ZWQnKSk7IC8vIGlzIHh5enQgcG9pbnRcbmNsYXNzIFBvaW50IHtcbiAgICBjb25zdHJ1Y3RvcihleCwgZXksIGV6LCBldCkge1xuICAgICAgICB0aGlzLmV4ID0gZXg7XG4gICAgICAgIHRoaXMuZXkgPSBleTtcbiAgICAgICAgdGhpcy5leiA9IGV6O1xuICAgICAgICB0aGlzLmV0ID0gZXQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHsgcmV0dXJuIG5ldyBQb2ludChwLngsIHAueSwgMW4sIG1vZChwLnggKiBwLnkpKTsgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCwgemlwMjE1ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgeyBkIH0gPSBDVVJWRTtcbiAgICAgICAgaGV4ID0gdG9VOChoZXgsIDMyKTtcbiAgICAgICAgY29uc3Qgbm9ybWVkID0gaGV4LnNsaWNlKCk7IC8vIGNvcHkgdGhlIGFycmF5IHRvIG5vdCBtZXNzIGl0IHVwXG4gICAgICAgIGNvbnN0IGxhc3RCeXRlID0gaGV4WzMxXTtcbiAgICAgICAgbm9ybWVkWzMxXSA9IGxhc3RCeXRlICYgfjB4ODA7IC8vIGFkanVzdCBmaXJzdCBMRSBieXRlID0gbGFzdCBCRSBieXRlXG4gICAgICAgIGNvbnN0IHkgPSBiMm5fTEUobm9ybWVkKTsgLy8gZGVjb2RlIGFzIGxpdHRsZS1lbmRpYW4sIGNvbnZlcnQgdG8gbnVtXG4gICAgICAgIGlmICh6aXAyMTUgJiYgISgwbiA8PSB5ICYmIHkgPCAybiAqKiAyNTZuKSlcbiAgICAgICAgICAgIGVycignYmFkIHkgY29vcmQgMScpOyAvLyB6aXAyMTU9dHJ1ZSAgWzEuLjJeMjU2LTFdXG4gICAgICAgIGlmICghemlwMjE1ICYmICEoMG4gPD0geSAmJiB5IDwgUCkpXG4gICAgICAgICAgICBlcnIoJ2JhZCB5IGNvb3JkIDInKTsgLy8gemlwMjE1PWZhbHNlIFsxLi5QLTFdXG4gICAgICAgIGNvbnN0IHkyID0gbW9kKHkgKiB5KTsgLy8gecKyXG4gICAgICAgIGNvbnN0IHUgPSBtb2QoeTIgLSAxbik7IC8vIHU9ecKyLTFcbiAgICAgICAgY29uc3QgdiA9IG1vZChkICogeTIgKyAxbik7IC8vIHY9ZHnCsisxXG4gICAgICAgIGxldCB7IGlzVmFsaWQsIHZhbHVlOiB4IH0gPSB1dlJhdGlvKHUsIHYpOyAvLyAodXbCsykodXbigbcpXihwLTUpLzg7IHNxdWFyZSByb290XG4gICAgICAgIGlmICghaXNWYWxpZClcbiAgICAgICAgICAgIGVycignYmFkIHkgY29vcmRpbmF0ZSAzJyk7IC8vIG5vdCBzcXVhcmUgcm9vdDogYmFkIHBvaW50XG4gICAgICAgIGNvbnN0IGlzWE9kZCA9ICh4ICYgMW4pID09PSAxbjsgLy8gYWRqdXN0IHNpZ24gb2YgeCBjb29yZGluYXRlXG4gICAgICAgIGNvbnN0IGlzTGFzdEJ5dGVPZGQgPSAobGFzdEJ5dGUgJiAweDgwKSAhPT0gMDsgLy8geF8wLCBsYXN0IGJpdFxuICAgICAgICBpZiAoIXppcDIxNSAmJiB4ID09PSAwbiAmJiBpc0xhc3RCeXRlT2RkKVxuICAgICAgICAgICAgZXJyKCdiYWQgeSBjb29yZCAzJyk7IC8vIHg9MCBhbmQgeF8wID0gMVxuICAgICAgICBpZiAoaXNMYXN0Qnl0ZU9kZCAhPT0gaXNYT2RkKVxuICAgICAgICAgICAgeCA9IG1vZCgteCk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgMW4sIG1vZCh4ICogeSkpOyAvLyBaPTEsIFQ9eHlcbiAgICB9XG4gICAgZ2V0IHgoKSB7IHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDsgfSAvLyAueCwgLnkgd2lsbCBjYWxsIGV4cGVuc2l2ZSB0b0FmZmluZS5cbiAgICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55OyB9IC8vIFNob3VsZCBiZSB1c2VkIHdpdGggY2FyZS5cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgY29uc3QgeyBleDogWDEsIGV5OiBZMSwgZXo6IFoxIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGV4OiBYMiwgZXk6IFkyLCBlejogWjIgfSA9IGlzUG9pbnQob3RoZXIpOyAvLyBpc1BvaW50KCkgY2hlY2tzIGNsYXNzIGVxdWFsaXR5XG4gICAgICAgIGNvbnN0IFgxWjIgPSBtb2QoWDEgKiBaMiksIFgyWjEgPSBtb2QoWDIgKiBaMSk7XG4gICAgICAgIGNvbnN0IFkxWjIgPSBtb2QoWTEgKiBaMiksIFkyWjEgPSBtb2QoWTIgKiBaMSk7XG4gICAgICAgIHJldHVybiBYMVoyID09PSBYMloxICYmIFkxWjIgPT09IFkyWjE7XG4gICAgfVxuICAgIGlzMCgpIHsgcmV0dXJuIHRoaXMuZXF1YWxzKEkpOyB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KG1vZCgtdGhpcy5leCksIHRoaXMuZXksIHRoaXMuZXosIG1vZCgtdGhpcy5ldCkpO1xuICAgIH1cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIGNvbnN0IHsgZXg6IFgxLCBleTogWTEsIGV6OiBaMSB9ID0gdGhpczsgLy8gQ29zdDogNE0gKyA0UyArIDEqYSArIDZhZGQgKyAxKjJcbiAgICAgICAgY29uc3QgeyBhIH0gPSBDVVJWRTsgLy8gaHR0cHM6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC5odG1sI2RvdWJsaW5nLWRibC0yMDA4LWh3Y2RcbiAgICAgICAgY29uc3QgQSA9IG1vZChYMSAqIFgxKTtcbiAgICAgICAgY29uc3QgQiA9IG1vZChZMSAqIFkxKTtcbiAgICAgICAgY29uc3QgQyA9IG1vZCgybiAqIG1vZChaMSAqIFoxKSk7XG4gICAgICAgIGNvbnN0IEQgPSBtb2QoYSAqIEEpO1xuICAgICAgICBjb25zdCB4MXkxID0gWDEgKyBZMTtcbiAgICAgICAgY29uc3QgRSA9IG1vZChtb2QoeDF5MSAqIHgxeTEpIC0gQSAtIEIpO1xuICAgICAgICBjb25zdCBHID0gRCArIEI7XG4gICAgICAgIGNvbnN0IEYgPSBHIC0gQztcbiAgICAgICAgY29uc3QgSCA9IEQgLSBCO1xuICAgICAgICBjb25zdCBYMyA9IG1vZChFICogRik7XG4gICAgICAgIGNvbnN0IFkzID0gbW9kKEcgKiBIKTtcbiAgICAgICAgY29uc3QgVDMgPSBtb2QoRSAqIEgpO1xuICAgICAgICBjb25zdCBaMyA9IG1vZChGICogRyk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMywgVDMpO1xuICAgIH1cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgeyBleDogWDEsIGV5OiBZMSwgZXo6IFoxLCBldDogVDEgfSA9IHRoaXM7IC8vIENvc3Q6IDhNICsgMSprICsgOGFkZCArIDEqMi5cbiAgICAgICAgY29uc3QgeyBleDogWDIsIGV5OiBZMiwgZXo6IFoyLCBldDogVDIgfSA9IGlzUG9pbnQob3RoZXIpOyAvLyBkb2Vzbid0IGNoZWNrIGlmIG90aGVyIG9uLWN1cnZlXG4gICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7IC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC0xLmh0bWwjYWRkaXRpb24tYWRkLTIwMDgtaHdjZC0zXG4gICAgICAgIGNvbnN0IEEgPSBtb2QoWDEgKiBYMik7XG4gICAgICAgIGNvbnN0IEIgPSBtb2QoWTEgKiBZMik7XG4gICAgICAgIGNvbnN0IEMgPSBtb2QoVDEgKiBkICogVDIpO1xuICAgICAgICBjb25zdCBEID0gbW9kKFoxICogWjIpO1xuICAgICAgICBjb25zdCBFID0gbW9kKChYMSArIFkxKSAqIChYMiArIFkyKSAtIEEgLSBCKTtcbiAgICAgICAgY29uc3QgRiA9IG1vZChEIC0gQyk7XG4gICAgICAgIGNvbnN0IEcgPSBtb2QoRCArIEMpO1xuICAgICAgICBjb25zdCBIID0gbW9kKEIgLSBhICogQSk7XG4gICAgICAgIGNvbnN0IFgzID0gbW9kKEUgKiBGKTtcbiAgICAgICAgY29uc3QgWTMgPSBtb2QoRyAqIEgpO1xuICAgICAgICBjb25zdCBUMyA9IG1vZChFICogSCk7XG4gICAgICAgIGNvbnN0IFozID0gbW9kKEYgKiBHKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgfVxuICAgIG11bChuLCBzYWZlID0gdHJ1ZSkge1xuICAgICAgICBpZiAobiA9PT0gMG4pXG4gICAgICAgICAgICByZXR1cm4gc2FmZSA9PT0gdHJ1ZSA/IGVycignY2Fubm90IG11bHRpcGx5IGJ5IDAnKSA6IEk7XG4gICAgICAgIGlmICghKHR5cGVvZiBuID09PSAnYmlnaW50JyAmJiAwbiA8IG4gJiYgbiA8IE4pKVxuICAgICAgICAgICAgZXJyKCdpbnZhbGlkIHNjYWxhciwgbXVzdCBiZSA8IEwnKTtcbiAgICAgICAgaWYgKCFzYWZlICYmIHRoaXMuaXMwKCkgfHwgbiA9PT0gMW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gc2FmZT10cnVlIGJhbnMgMC4gc2FmZT1mYWxzZSBhbGxvd3MgMC5cbiAgICAgICAgaWYgKHRoaXMuZXF1YWxzKEcpKVxuICAgICAgICAgICAgcmV0dXJuIHdOQUYobikucDsgLy8gdXNlIHdOQUYgcHJlY29tcHV0ZXMgZm9yIGJhc2UgcG9pbnRzXG4gICAgICAgIGxldCBwID0gSSwgZiA9IEc7IC8vIGluaXQgcmVzdWx0IHBvaW50ICYgZmFrZSBwb2ludFxuICAgICAgICBmb3IgKGxldCBkID0gdGhpczsgbiA+IDBuOyBkID0gZC5kb3VibGUoKSwgbiA+Pj0gMW4pIHsgLy8gZG91YmxlLWFuZC1hZGQgbGFkZGVyXG4gICAgICAgICAgICBpZiAobiAmIDFuKVxuICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTsgLy8gaWYgYml0IGlzIHByZXNlbnQsIGFkZCB0byBwb2ludFxuICAgICAgICAgICAgZWxzZSBpZiAoc2FmZSlcbiAgICAgICAgICAgICAgICBmID0gZi5hZGQoZCk7IC8vIGlmIG5vdCwgYWRkIHRvIGZha2UgZm9yIHRpbWluZyBzYWZldHlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgbXVsdGlwbHkoc2NhbGFyKSB7IHJldHVybiB0aGlzLm11bChzY2FsYXIpOyB9IC8vIEFsaWFzZXMgZm9yIGNvbXBhdGliaWx0eVxuICAgIGNsZWFyQ29mYWN0b3IoKSB7IHJldHVybiB0aGlzLm11bChCaWdJbnQoQ1VSVkUuaCksIGZhbHNlKTsgfSAvLyBtdWx0aXBseSBieSBjb2ZhY3RvclxuICAgIGlzU21hbGxPcmRlcigpIHsgcmV0dXJuIHRoaXMuY2xlYXJDb2ZhY3RvcigpLmlzMCgpOyB9IC8vIGNoZWNrIGlmIFAgaXMgc21hbGwgb3JkZXJcbiAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICBsZXQgcCA9IHRoaXMubXVsKE4gLyAybiwgZmFsc2UpLmRvdWJsZSgpOyAvLyBlbnN1cmVzIHRoZSBwb2ludCBpcyBub3QgXCJiYWRcIi5cbiAgICAgICAgaWYgKE4gJSAybilcbiAgICAgICAgICAgIHAgPSBwLmFkZCh0aGlzKTsgLy8gUF4oTisxKSAgICAgICAgICAgICAvLyBQKk4gPT0gKFAqKE4vMikpKjIrUFxuICAgICAgICByZXR1cm4gcC5pczAoKTtcbiAgICB9XG4gICAgdG9BZmZpbmUoKSB7XG4gICAgICAgIGNvbnN0IHsgZXg6IHgsIGV5OiB5LCBlejogeiB9ID0gdGhpczsgLy8gKHgsIHksIHosIHQpIOKIiyAoeD14L3osIHk9eS96LCB0PXh5KVxuICAgICAgICBpZiAodGhpcy5lcXVhbHMoSSkpXG4gICAgICAgICAgICByZXR1cm4geyB4OiAwbiwgeTogMW4gfTsgLy8gZmFzdC1wYXRoIGZvciB6ZXJvIHBvaW50XG4gICAgICAgIGNvbnN0IGl6ID0gaW52ZXJ0KHopOyAvLyB6Xi0xOiBpbnZlcnQgelxuICAgICAgICBpZiAobW9kKHogKiBpeikgIT09IDFuKVxuICAgICAgICAgICAgZXJyKCdpbnZhbGlkIGludmVyc2UnKTsgLy8gKHogKiB6Xi0xKSBtdXN0IGJlIDEsIG90aGVyd2lzZSBiYWQgbWF0aFxuICAgICAgICByZXR1cm4geyB4OiBtb2QoeCAqIGl6KSwgeTogbW9kKHkgKiBpeikgfTsgLy8geCA9IHgqel4tMTsgeSA9IHkqel4tMVxuICAgIH1cbiAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTsgLy8gY29udmVydCB0byBhZmZpbmUgMmQgcG9pbnRcbiAgICAgICAgY29uc3QgYiA9IG4yYl8zMkxFKHkpOyAvLyBlbmNvZGUgbnVtYmVyIHRvIDMyIGJ5dGVzXG4gICAgICAgIGJbMzFdIHw9IHggJiAxbiA/IDB4ODAgOiAwOyAvLyBzdG9yZSBzaWduIGluIGZpcnN0IExFIGJ5dGVcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHRvSGV4KCkgeyByZXR1cm4gYjJoKHRoaXMudG9SYXdCeXRlcygpKTsgfSAvLyBlbmNvZGUgdG8gaGV4IHN0cmluZ1xufVxuUG9pbnQuQkFTRSA9IG5ldyBQb2ludChHeCwgR3ksIDFuLCBtb2QoR3ggKiBHeSkpOyAvLyBHZW5lcmF0b3IgLyBCYXNlIHBvaW50XG5Qb2ludC5aRVJPID0gbmV3IFBvaW50KDBuLCAxbiwgMW4sIDBuKTsgLy8gSWRlbnRpdHkgLyBaZXJvIHBvaW50XG5jb25zdCB7IEJBU0U6IEcsIFpFUk86IEkgfSA9IFBvaW50OyAvLyBHZW5lcmF0b3IsIGlkZW50aXR5IHBvaW50c1xuY29uc3QgcGFkaCA9IChudW0sIHBhZCkgPT4gbnVtLnRvU3RyaW5nKDE2KS5wYWRTdGFydChwYWQsICcwJyk7XG5jb25zdCBiMmggPSAoYikgPT4gQXJyYXkuZnJvbShiKS5tYXAoZSA9PiBwYWRoKGUsIDIpKS5qb2luKCcnKTsgLy8gYnl0ZXMgdG8gaGV4XG5jb25zdCBoMmIgPSAoaGV4KSA9PiB7XG4gICAgY29uc3QgbCA9IGhleC5sZW5ndGg7IC8vIGVycm9yIGlmIG5vdCBzdHJpbmcsXG4gICAgaWYgKCFzdHIoaGV4KSB8fCBsICUgMilcbiAgICAgICAgZXJyKCdoZXggaW52YWxpZCAxJyk7IC8vIG9yIGhhcyBvZGQgbGVuZ3RoIGxpa2UgMywgNS5cbiAgICBjb25zdCBhcnIgPSB1OG4obCAvIDIpOyAvLyBjcmVhdGUgcmVzdWx0IGFycmF5XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoID0gaGV4LnNsaWNlKGosIGogKyAyKTsgLy8gaGV4Qnl0ZS4gc2xpY2UgaXMgZmFzdGVyIHRoYW4gc3Vic3RyXG4gICAgICAgIGNvbnN0IGIgPSBOdW1iZXIucGFyc2VJbnQoaCwgMTYpOyAvLyBieXRlLCBjcmVhdGVkIGZyb20gc3RyaW5nIHBhcnRcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihiKSB8fCBiIDwgMClcbiAgICAgICAgICAgIGVycignaGV4IGludmFsaWQgMicpOyAvLyBieXRlIG11c3QgYmUgdmFsaWQgMCA8PSBieXRlIDwgMjU2XG4gICAgICAgIGFycltpXSA9IGI7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59O1xuY29uc3QgbjJiXzMyTEUgPSAobnVtKSA9PiBoMmIocGFkaChudW0sIDMyICogMikpLnJldmVyc2UoKTsgLy8gbnVtYmVyIHRvIGJ5dGVzIExFXG5jb25zdCBiMm5fTEUgPSAoYikgPT4gQmlnSW50KCcweCcgKyBiMmgodThuKGF1OChiKSkucmV2ZXJzZSgpKSk7IC8vIGJ5dGVzIExFIHRvIG51bVxuY29uc3QgY29uY2F0QiA9ICguLi5hcnJzKSA9PiB7XG4gICAgY29uc3QgciA9IHU4bihhcnJzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhdTgoYSkubGVuZ3RoLCAwKSk7IC8vIGNyZWF0ZSB1OGEgb2Ygc3VtbWVkIGxlbmd0aFxuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBhcnJheSxcbiAgICBhcnJzLmZvckVhY2goYSA9PiB7IHIuc2V0KGEsIHBhZCk7IHBhZCArPSBhLmxlbmd0aDsgfSk7IC8vIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICByZXR1cm4gcjtcbn07XG5jb25zdCBpbnZlcnQgPSAobnVtLCBtZCA9IFApID0+IHtcbiAgICBpZiAobnVtID09PSAwbiB8fCBtZCA8PSAwbilcbiAgICAgICAgZXJyKCdubyBpbnZlcnNlIG49JyArIG51bSArICcgbW9kPScgKyBtZCk7IC8vIG5vIG5lZyBleHBvbmVudCBmb3Igbm93XG4gICAgbGV0IGEgPSBtb2QobnVtLCBtZCksIGIgPSBtZCwgeCA9IDBuLCB5ID0gMW4sIHUgPSAxbiwgdiA9IDBuO1xuICAgIHdoaWxlIChhICE9PSAwbikgeyAvLyB1c2VzIGV1Y2xpZGVhbiBnY2QgYWxnb3JpdGhtXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYSwgciA9IGIgJSBhOyAvLyBub3QgY29uc3RhbnQtdGltZVxuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxLCBuID0geSAtIHYgKiBxO1xuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICByZXR1cm4gYiA9PT0gMW4gPyBtb2QoeCwgbWQpIDogZXJyKCdubyBpbnZlcnNlJyk7IC8vIGIgaXMgZ2NkIGF0IHRoaXMgcG9pbnRcbn07XG5jb25zdCBwb3cyID0gKHgsIHBvd2VyKSA9PiB7XG4gICAgbGV0IHIgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gMG4pIHtcbiAgICAgICAgciAqPSByO1xuICAgICAgICByICU9IFA7XG4gICAgfVxuICAgIHJldHVybiByO1xufTtcbmNvbnN0IHBvd18yXzI1Ml8zID0gKHgpID0+IHtcbiAgICBjb25zdCB4MiA9ICh4ICogeCkgJSBQOyAvLyB4XjIsICAgICAgIGJpdHMgMVxuICAgIGNvbnN0IGIyID0gKHgyICogeCkgJSBQOyAvLyB4XjMsICAgICAgIGJpdHMgMTFcbiAgICBjb25zdCBiNCA9IChwb3cyKGIyLCAybikgKiBiMikgJSBQOyAvLyB4XigyXjQtMSksIGJpdHMgMTExMVxuICAgIGNvbnN0IGI1ID0gKHBvdzIoYjQsIDFuKSAqIHgpICUgUDsgLy8geF4oMl41LTEpLCBiaXRzIDExMTExXG4gICAgY29uc3QgYjEwID0gKHBvdzIoYjUsIDVuKSAqIGI1KSAlIFA7IC8vIHheKDJeMTApXG4gICAgY29uc3QgYjIwID0gKHBvdzIoYjEwLCAxMG4pICogYjEwKSAlIFA7IC8vIHheKDJeMjApXG4gICAgY29uc3QgYjQwID0gKHBvdzIoYjIwLCAyMG4pICogYjIwKSAlIFA7IC8vIHheKDJeNDApXG4gICAgY29uc3QgYjgwID0gKHBvdzIoYjQwLCA0MG4pICogYjQwKSAlIFA7IC8vIHheKDJeODApXG4gICAgY29uc3QgYjE2MCA9IChwb3cyKGI4MCwgODBuKSAqIGI4MCkgJSBQOyAvLyB4XigyXjE2MClcbiAgICBjb25zdCBiMjQwID0gKHBvdzIoYjE2MCwgODBuKSAqIGI4MCkgJSBQOyAvLyB4XigyXjI0MClcbiAgICBjb25zdCBiMjUwID0gKHBvdzIoYjI0MCwgMTBuKSAqIGIxMCkgJSBQOyAvLyB4XigyXjI1MClcbiAgICBjb25zdCBwb3dfcF81XzggPSAocG93MihiMjUwLCAybikgKiB4KSAlIFA7IC8vIDwgVG8gcG93IHRvIChwKzMpLzgsIG11bHRpcGx5IGl0IGJ5IHguXG4gICAgcmV0dXJuIHsgcG93X3BfNV84LCBiMiB9O1xufTtcbmNvbnN0IFJNMSA9IDE5NjgxMTYxMzc2NzA3NTA1OTU2ODA3MDc5MzA0OTg4NTQyMDE1NDQ2MDY2NTE1OTIzODkwMTYyNzQ0MDIxMDczMTIzODI5Nzg0NzUybjsgLy8g4oiaLTFcbmNvbnN0IHV2UmF0aW8gPSAodSwgdikgPT4ge1xuICAgIGNvbnN0IHYzID0gbW9kKHYgKiB2ICogdik7IC8vIHbCs1xuICAgIGNvbnN0IHY3ID0gbW9kKHYzICogdjMgKiB2KTsgLy8gduKBt1xuICAgIGNvbnN0IHBvdyA9IHBvd18yXzI1Ml8zKHUgKiB2NykucG93X3BfNV84OyAvLyAodXbigbcpXihwLTUpLzhcbiAgICBsZXQgeCA9IG1vZCh1ICogdjMgKiBwb3cpOyAvLyAodXbCsykodXbigbcpXihwLTUpLzhcbiAgICBjb25zdCB2eDIgPSBtb2QodiAqIHggKiB4KTsgLy8gdnjCslxuICAgIGNvbnN0IHJvb3QxID0geDsgLy8gRmlyc3Qgcm9vdCBjYW5kaWRhdGVcbiAgICBjb25zdCByb290MiA9IG1vZCh4ICogUk0xKTsgLy8gU2Vjb25kIHJvb3QgY2FuZGlkYXRlOyBSTTEgaXMg4oiaLTFcbiAgICBjb25zdCB1c2VSb290MSA9IHZ4MiA9PT0gdTsgLy8gSWYgdnjCsiA9IHUgKG1vZCBwKSwgeCBpcyBhIHNxdWFyZSByb290XG4gICAgY29uc3QgdXNlUm9vdDIgPSB2eDIgPT09IG1vZCgtdSk7IC8vIElmIHZ4wrIgPSAtdSwgc2V0IHggPC0tIHggKiAyXigocC0xKS80KVxuICAgIGNvbnN0IG5vUm9vdCA9IHZ4MiA9PT0gbW9kKC11ICogUk0xKTsgLy8gVGhlcmUgaXMgbm8gdmFsaWQgcm9vdCwgdnjCsiA9IC114oiaLTFcbiAgICBpZiAodXNlUm9vdDEpXG4gICAgICAgIHggPSByb290MTtcbiAgICBpZiAodXNlUm9vdDIgfHwgbm9Sb290KVxuICAgICAgICB4ID0gcm9vdDI7IC8vIFdlIHJldHVybiByb290MiBhbnl3YXksIGZvciBjb25zdC10aW1lXG4gICAgaWYgKChtb2QoeCkgJiAxbikgPT09IDFuKVxuICAgICAgICB4ID0gbW9kKC14KTsgLy8gZWRJc05lZ2F0aXZlXG4gICAgcmV0dXJuIHsgaXNWYWxpZDogdXNlUm9vdDEgfHwgdXNlUm9vdDIsIHZhbHVlOiB4IH07XG59O1xuY29uc3QgbW9kTF9MRSA9IChoYXNoKSA9PiBtb2QoYjJuX0xFKGhhc2gpLCBOKTsgLy8gbW9kdWxvIEw7IGJ1dCBsaXR0bGUtZW5kaWFuXG5sZXQgX3NoYVM7XG5jb25zdCBzaGE1MTJhID0gKC4uLm0pID0+IGV0Yy5zaGE1MTJBc3luYyguLi5tKTsgLy8gQXN5bmMgU0hBNTEyXG5jb25zdCBzaGE1MTJzID0gKC4uLm0pID0+IC8vIFN5bmMgU0hBNTEyLCBub3Qgc2V0IGJ5IGRlZmF1bHRcbiB0eXBlb2YgX3NoYVMgPT09ICdmdW5jdGlvbicgPyBfc2hhUyguLi5tKSA6IGVycignZXRjLnNoYTUxMlN5bmMgbm90IHNldCcpO1xuY29uc3QgaGFzaDJleHRLID0gKGhhc2hlZCkgPT4ge1xuICAgIGNvbnN0IGhlYWQgPSBoYXNoZWQuc2xpY2UoMCwgMzIpOyAvLyBzbGljZSBjcmVhdGVzIGEgY29weSwgdW5saWtlIHN1YmFycmF5XG4gICAgaGVhZFswXSAmPSAyNDg7IC8vIENsYW1wIGJpdHM6IDBiMTExMV8xMDAwLFxuICAgIGhlYWRbMzFdICY9IDEyNzsgLy8gMGIwMTExXzExMTEsXG4gICAgaGVhZFszMV0gfD0gNjQ7IC8vIDBiMDEwMF8wMDAwXG4gICAgY29uc3QgcHJlZml4ID0gaGFzaGVkLnNsaWNlKDMyLCA2NCk7IC8vIHByaXZhdGUga2V5IFwicHJlZml4XCJcbiAgICBjb25zdCBzY2FsYXIgPSBtb2RMX0xFKGhlYWQpOyAvLyBtb2R1bGFyIGRpdmlzaW9uIG92ZXIgY3VydmUgb3JkZXJcbiAgICBjb25zdCBwb2ludCA9IEcubXVsKHNjYWxhcik7IC8vIHB1YmxpYyBrZXkgcG9pbnRcbiAgICBjb25zdCBwb2ludEJ5dGVzID0gcG9pbnQudG9SYXdCeXRlcygpOyAvLyBwb2ludCBzZXJpYWxpemVkIHRvIFVpbnQ4QXJyYXlcbiAgICByZXR1cm4geyBoZWFkLCBwcmVmaXgsIHNjYWxhciwgcG9pbnQsIHBvaW50Qnl0ZXMgfTtcbn07XG4vLyBSRkM4MDMyIDUuMS41OyBnZXRQdWJsaWNLZXkgYXN5bmMsIHN5bmMuIEhhc2ggcHJpdiBrZXkgYW5kIGV4dHJhY3QgcG9pbnQuXG5jb25zdCBnZXRFeHRlbmRlZFB1YmxpY0tleUFzeW5jID0gKHByaXYpID0+IHNoYTUxMmEodG9VOChwcml2LCAzMikpLnRoZW4oaGFzaDJleHRLKTtcbmNvbnN0IGdldEV4dGVuZGVkUHVibGljS2V5ID0gKHByaXYpID0+IGhhc2gyZXh0SyhzaGE1MTJzKHRvVTgocHJpdiwgMzIpKSk7XG5jb25zdCBnZXRQdWJsaWNLZXlBc3luYyA9IChwcml2KSA9PiBnZXRFeHRlbmRlZFB1YmxpY0tleUFzeW5jKHByaXYpLnRoZW4ocCA9PiBwLnBvaW50Qnl0ZXMpO1xuY29uc3QgZ2V0UHVibGljS2V5ID0gKHByaXYpID0+IGdldEV4dGVuZGVkUHVibGljS2V5KHByaXYpLnBvaW50Qnl0ZXM7XG5mdW5jdGlvbiBoYXNoRmluaXNoKGFzeW5jaHJvbm91cywgcmVzKSB7XG4gICAgaWYgKGFzeW5jaHJvbm91cylcbiAgICAgICAgcmV0dXJuIHNoYTUxMmEocmVzLmhhc2hhYmxlKS50aGVuKHJlcy5maW5pc2gpO1xuICAgIHJldHVybiByZXMuZmluaXNoKHNoYTUxMnMocmVzLmhhc2hhYmxlKSk7XG59XG5jb25zdCBfc2lnbiA9IChlLCByQnl0ZXMsIG1zZykgPT4ge1xuICAgIGNvbnN0IHsgcG9pbnRCeXRlczogUCwgc2NhbGFyOiBzIH0gPSBlO1xuICAgIGNvbnN0IHIgPSBtb2RMX0xFKHJCeXRlcyk7IC8vIHIgd2FzIGNyZWF0ZWQgb3V0c2lkZSwgcmVkdWNlIGl0IG1vZHVsbyBMXG4gICAgY29uc3QgUiA9IEcubXVsKHIpLnRvUmF3Qnl0ZXMoKTsgLy8gUiA9IFtyXUJcbiAgICBjb25zdCBoYXNoYWJsZSA9IGNvbmNhdEIoUiwgUCwgbXNnKTsgLy8gZG9tMihGLCBDKSB8fCBSIHx8IEEgfHwgUEgoTSlcbiAgICBjb25zdCBmaW5pc2ggPSAoaGFzaGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IFMgPSBtb2QociArIG1vZExfTEUoaGFzaGVkKSAqIHMsIE4pOyAvLyBTID0gKHIgKyBrICogcykgbW9kIEw7IDAgPD0gcyA8IGxcbiAgICAgICAgcmV0dXJuIGF1OChjb25jYXRCKFIsIG4yYl8zMkxFKFMpKSwgNjQpOyAvLyA2NC1ieXRlIHNpZzogMzJiIFIueCArIDMyYiBMRShTKVxuICAgIH07XG4gICAgcmV0dXJuIHsgaGFzaGFibGUsIGZpbmlzaCB9O1xufTtcbmNvbnN0IHNpZ25Bc3luYyA9IGFzeW5jIChtc2csIHByaXZLZXkpID0+IHtcbiAgICBjb25zdCBtID0gdG9VOChtc2cpOyAvLyBSRkM4MDMyIDUuMS42OiBzaWduIG1zZyB3aXRoIGtleSBhc3luY1xuICAgIGNvbnN0IGUgPSBhd2FpdCBnZXRFeHRlbmRlZFB1YmxpY0tleUFzeW5jKHByaXZLZXkpOyAvLyBwdWIscHJmeFxuICAgIGNvbnN0IHJCeXRlcyA9IGF3YWl0IHNoYTUxMmEoZS5wcmVmaXgsIG0pOyAvLyByID0gU0hBNTEyKGRvbTIoRiwgQykgfHwgcHJlZml4IHx8IFBIKE0pKVxuICAgIHJldHVybiBoYXNoRmluaXNoKHRydWUsIF9zaWduKGUsIHJCeXRlcywgbSkpOyAvLyBnZW4gUiwgaywgUywgdGhlbiA2NC1ieXRlIHNpZ25hdHVyZVxufTtcbmNvbnN0IHNpZ24gPSAobXNnLCBwcml2S2V5KSA9PiB7XG4gICAgY29uc3QgbSA9IHRvVTgobXNnKTsgLy8gUkZDODAzMiA1LjEuNjogc2lnbiBtc2cgd2l0aCBrZXkgc3luY1xuICAgIGNvbnN0IGUgPSBnZXRFeHRlbmRlZFB1YmxpY0tleShwcml2S2V5KTsgLy8gcHViLHByZnhcbiAgICBjb25zdCByQnl0ZXMgPSBzaGE1MTJzKGUucHJlZml4LCBtKTsgLy8gciA9IFNIQTUxMihkb20yKEYsIEMpIHx8IHByZWZpeCB8fCBQSChNKSlcbiAgICByZXR1cm4gaGFzaEZpbmlzaChmYWxzZSwgX3NpZ24oZSwgckJ5dGVzLCBtKSk7IC8vIGdlbiBSLCBrLCBTLCB0aGVuIDY0LWJ5dGUgc2lnbmF0dXJlXG59O1xuY29uc3QgZHZvID0geyB6aXAyMTU6IHRydWUgfTtcbmNvbnN0IF92ZXJpZnkgPSAoc2lnLCBtc2csIHB1Yiwgb3B0cyA9IGR2bykgPT4ge1xuICAgIG1zZyA9IHRvVTgobXNnKTsgLy8gTWVzc2FnZSBoZXggc3RyL0J5dGVzXG4gICAgc2lnID0gdG9VOChzaWcsIDY0KTsgLy8gU2lnbmF0dXJlIGhleCBzdHIvQnl0ZXMsIG11c3QgYmUgNjQgYnl0ZXNcbiAgICBjb25zdCB7IHppcDIxNSB9ID0gb3B0czsgLy8gc3dpdGNoIGJldHdlZW4gemlwMjE1IGFuZCByZmM4MDMyIHZlcmlmXG4gICAgbGV0IEEsIFIsIHMsIFNCLCBoYXNoYWJsZSA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgdHJ5IHtcbiAgICAgICAgQSA9IFBvaW50LmZyb21IZXgocHViLCB6aXAyMTUpOyAvLyBwdWJsaWMga2V5IEEgZGVjb2RlZFxuICAgICAgICBSID0gUG9pbnQuZnJvbUhleChzaWcuc2xpY2UoMCwgMzIpLCB6aXAyMTUpOyAvLyAwIDw9IFIgPCAyXjI1NjogWklQMjE1IFIgY2FuIGJlID49IFBcbiAgICAgICAgcyA9IGIybl9MRShzaWcuc2xpY2UoMzIsIDY0KSk7IC8vIERlY29kZSBzZWNvbmQgaGFsZiBhcyBhbiBpbnRlZ2VyIFNcbiAgICAgICAgU0IgPSBHLm11bChzLCBmYWxzZSk7IC8vIGluIHRoZSByYW5nZSAwIDw9IHMgPCBMXG4gICAgICAgIGhhc2hhYmxlID0gY29uY2F0QihSLnRvUmF3Qnl0ZXMoKSwgQS50b1Jhd0J5dGVzKCksIG1zZyk7IC8vIGRvbTIoRiwgQykgfHwgUiB8fCBBIHx8IFBIKE0pXG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgY29uc3QgZmluaXNoID0gKGhhc2hlZCkgPT4ge1xuICAgICAgICBpZiAoU0IgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gZmFsc2UgaWYgdHJ5LWNhdGNoIGNhdGNoZWQgYW4gZXJyb3JcbiAgICAgICAgaWYgKCF6aXAyMTUgJiYgQS5pc1NtYWxsT3JkZXIoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gZmFsc2UgZm9yIFNCUzogU3Ryb25nbHkgQmluZGluZyBTaWduYXR1cmVcbiAgICAgICAgY29uc3QgayA9IG1vZExfTEUoaGFzaGVkKTsgLy8gZGVjb2RlIGluIGxpdHRsZS1lbmRpYW4sIG1vZHVsbyBMXG4gICAgICAgIGNvbnN0IFJrQSA9IFIuYWRkKEEubXVsKGssIGZhbHNlKSk7IC8vIFs4XVIgKyBbOF1ba11BJ1xuICAgICAgICByZXR1cm4gUmtBLmFkZChTQi5uZWdhdGUoKSkuY2xlYXJDb2ZhY3RvcigpLmlzMCgpOyAvLyBbOF1bU11CID0gWzhdUiArIFs4XVtrXUEnXG4gICAgfTtcbiAgICByZXR1cm4geyBoYXNoYWJsZSwgZmluaXNoIH07XG59O1xuLy8gUkZDODAzMiA1LjEuNzogdmVyaWZpY2F0aW9uIGFzeW5jLCBzeW5jXG5jb25zdCB2ZXJpZnlBc3luYyA9IGFzeW5jIChzLCBtLCBwLCBvcHRzID0gZHZvKSA9PiBoYXNoRmluaXNoKHRydWUsIF92ZXJpZnkocywgbSwgcCwgb3B0cykpO1xuY29uc3QgdmVyaWZ5ID0gKHMsIG0sIHAsIG9wdHMgPSBkdm8pID0+IGhhc2hGaW5pc2goZmFsc2UsIF92ZXJpZnkocywgbSwgcCwgb3B0cykpO1xuY29uc3QgY3IgPSAoKSA9PiAvLyBXZSBzdXBwb3J0OiAxKSBicm93c2VycyAyKSBub2RlLmpzIDE5K1xuIHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5jcnlwdG8gOiB1bmRlZmluZWQ7XG5jb25zdCBldGMgPSB7XG4gICAgYnl0ZXNUb0hleDogYjJoLCBoZXhUb0J5dGVzOiBoMmIsIGNvbmNhdEJ5dGVzOiBjb25jYXRCLFxuICAgIG1vZCwgaW52ZXJ0LFxuICAgIHJhbmRvbUJ5dGVzOiAobGVuID0gMzIpID0+IHtcbiAgICAgICAgY29uc3QgY3J5cHRvID0gY3IoKTsgLy8gQ2FuIGJlIHNoaW1tZWQgaW4gbm9kZS5qcyA8PSAxOCB0byBwcmV2ZW50IGVycm9yOlxuICAgICAgICAvLyBpbXBvcnQgeyB3ZWJjcnlwdG8gfSBmcm9tICdub2RlOmNyeXB0byc7XG4gICAgICAgIC8vIGlmICghZ2xvYmFsVGhpcy5jcnlwdG8pIGdsb2JhbFRoaXMuY3J5cHRvID0gd2ViY3J5cHRvO1xuICAgICAgICBpZiAoIWNyeXB0byB8fCAhY3J5cHRvLmdldFJhbmRvbVZhbHVlcylcbiAgICAgICAgICAgIGVycignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXModThuKGxlbikpO1xuICAgIH0sXG4gICAgc2hhNTEyQXN5bmM6IGFzeW5jICguLi5tZXNzYWdlcykgPT4ge1xuICAgICAgICBjb25zdCBjcnlwdG8gPSBjcigpO1xuICAgICAgICBpZiAoIWNyeXB0byB8fCAhY3J5cHRvLnN1YnRsZSlcbiAgICAgICAgICAgIGVycignY3J5cHRvLnN1YnRsZSBvciBldGMuc2hhNTEyQXN5bmMgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIGNvbnN0IG0gPSBjb25jYXRCKC4uLm1lc3NhZ2VzKTtcbiAgICAgICAgcmV0dXJuIHU4bihhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTUxMicsIG0uYnVmZmVyKSk7XG4gICAgfSxcbiAgICBzaGE1MTJTeW5jOiB1bmRlZmluZWQsIC8vIEFjdHVhbCBsb2dpYyBiZWxvd1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGV0YywgeyBzaGE1MTJTeW5jOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsIGdldCgpIHsgcmV0dXJuIF9zaGFTOyB9LCBzZXQoZikgeyBpZiAoIV9zaGFTKVxuICAgICAgICAgICAgX3NoYVMgPSBmOyB9LFxuICAgIH0gfSk7XG5jb25zdCB1dGlscyA9IHtcbiAgICBnZXRFeHRlbmRlZFB1YmxpY0tleUFzeW5jLCBnZXRFeHRlbmRlZFB1YmxpY0tleSxcbiAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiBldGMucmFuZG9tQnl0ZXMoMzIpLFxuICAgIHByZWNvbXB1dGUodyA9IDgsIHAgPSBHKSB7IHAubXVsdGlwbHkoM24pOyB3OyByZXR1cm4gcDsgfSwgLy8gbm8tb3Bcbn07XG5jb25zdCBXID0gODsgLy8gUHJlY29tcHV0ZXMtcmVsYXRlZCBjb2RlLiBXID0gd2luZG93IHNpemVcbmNvbnN0IHByZWNvbXB1dGUgPSAoKSA9PiB7XG4gICAgY29uc3QgcG9pbnRzID0gW107IC8vIDEweCBzaWduKCksIDJ4IHZlcmlmeSgpLiBUbyBhY2hpZXZlIHRoaXMsXG4gICAgY29uc3Qgd2luZG93cyA9IDI1NiAvIFcgKyAxOyAvLyBhcHAgbmVlZHMgdG8gc3BlbmQgNDBtcysgdG8gY2FsY3VsYXRlXG4gICAgbGV0IHAgPSBHLCBiID0gcDsgLy8gYSBsb3Qgb2YgcG9pbnRzIHJlbGF0ZWQgdG8gYmFzZSBwb2ludCBHLlxuICAgIGZvciAobGV0IHcgPSAwOyB3IDwgd2luZG93czsgdysrKSB7IC8vIFBvaW50cyBhcmUgc3RvcmVkIGluIGFycmF5IGFuZCB1c2VkXG4gICAgICAgIGIgPSBwOyAvLyBhbnkgdGltZSBHeCBtdWx0aXBsaWNhdGlvbiBpcyBkb25lLlxuICAgICAgICBwb2ludHMucHVzaChiKTsgLy8gVGhleSBjb25zdW1lIDE2LTMyIE1pQiBvZiBSQU0uXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgMiAqKiAoVyAtIDEpOyBpKyspIHtcbiAgICAgICAgICAgIGIgPSBiLmFkZChwKTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGIpO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBiLmRvdWJsZSgpOyAvLyBQcmVjb21wdXRlcyBkb24ndCBzcGVlZC11cCBnZXRTaGFyZWRLZXksXG4gICAgfSAvLyB3aGljaCBtdWx0aXBsaWVzIHVzZXIgcG9pbnQgYnkgc2NhbGFyLFxuICAgIHJldHVybiBwb2ludHM7IC8vIHdoZW4gcHJlY29tcHV0ZXMgYXJlIHVzaW5nIGJhc2UgcG9pbnRcbn07XG5sZXQgR3Bvd3MgPSB1bmRlZmluZWQ7IC8vIHByZWNvbXB1dGVzIGZvciBiYXNlIHBvaW50IEdcbmNvbnN0IHdOQUYgPSAobikgPT4ge1xuICAgIC8vIENvbXBhcmVkIHRvIG90aGVyIHBvaW50IG11bHQgbWV0aG9kcyxcbiAgICBjb25zdCBjb21wID0gR3Bvd3MgfHwgKEdwb3dzID0gcHJlY29tcHV0ZSgpKTsgLy8gc3RvcmVzIDJ4IGxlc3MgcG9pbnRzIHVzaW5nIHN1YnRyYWN0aW9uXG4gICAgY29uc3QgbmVnID0gKGNuZCwgcCkgPT4geyBsZXQgbiA9IHAubmVnYXRlKCk7IHJldHVybiBjbmQgPyBuIDogcDsgfTsgLy8gbmVnYXRlXG4gICAgbGV0IHAgPSBJLCBmID0gRzsgLy8gZiBtdXN0IGJlIEcsIG9yIGNvdWxkIGJlY29tZSBJIGluIHRoZSBlbmRcbiAgICBjb25zdCB3aW5kb3dzID0gMSArIDI1NiAvIFc7IC8vIFc9OCAxNyB3aW5kb3dzXG4gICAgY29uc3Qgd3NpemUgPSAyICoqIChXIC0gMSk7IC8vIFc9OCAxMjggd2luZG93IHNpemVcbiAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBXPTggd2lsbCBjcmVhdGUgbWFzayAwYjExMTExMTExXG4gICAgY29uc3QgbWF4TnVtID0gMiAqKiBXOyAvLyBXPTggMjU2XG4gICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTsgLy8gVz04IDhcbiAgICBmb3IgKGxldCB3ID0gMDsgdyA8IHdpbmRvd3M7IHcrKykge1xuICAgICAgICBjb25zdCBvZmYgPSB3ICogd3NpemU7XG4gICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7IC8vIGV4dHJhY3QgVyBiaXRzLlxuICAgICAgICBuID4+PSBzaGlmdEJ5OyAvLyBzaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICBpZiAod2JpdHMgPiB3c2l6ZSkge1xuICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtO1xuICAgICAgICAgICAgbiArPSAxbjtcbiAgICAgICAgfSAvLyBzcGxpdCBpZiBiaXRzID4gbWF4OiArMjI0ID0+IDI1Ni0zMlxuICAgICAgICBjb25zdCBvZmYxID0gb2ZmLCBvZmYyID0gb2ZmICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gb2Zmc2V0cywgZXZhbHVhdGUgYm90aFxuICAgICAgICBjb25zdCBjbmQxID0gdyAlIDIgIT09IDAsIGNuZDIgPSB3Yml0cyA8IDA7IC8vIGNvbmRpdGlvbnMsIGV2YWx1YXRlIGJvdGhcbiAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICBmID0gZi5hZGQobmVnKGNuZDEsIGNvbXBbb2ZmMV0pKTsgLy8gYml0cyBhcmUgMDogYWRkIGdhcmJhZ2UgdG8gZmFrZSBwb2ludFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyAgICAgICAgICBeIGNhbid0IGFkZCBvZmYyLCBvZmYyID0gSVxuICAgICAgICAgICAgcCA9IHAuYWRkKG5lZyhjbmQyLCBjb21wW29mZjJdKSk7IC8vIGJpdHMgYXJlIDE6IGFkZCB0byByZXN1bHQgcG9pbnRcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBwLCBmIH07IC8vIHJldHVybiBib3RoIHJlYWwgYW5kIGZha2UgcG9pbnRzIGZvciBKSVRcbn07IC8vICEhIHlvdSBjYW4gZGlzYWJsZSBwcmVjb21wdXRlcyBieSBjb21tZW50aW5nLW91dCBjYWxsIG9mIHRoZSB3TkFGKCkgaW5zaWRlIFBvaW50I211bCgpXG5leHBvcnQgeyBnZXRQdWJsaWNLZXksIGdldFB1YmxpY0tleUFzeW5jLCBzaWduLCB2ZXJpZnksIC8vIFJlbW92ZSB0aGUgZXhwb3J0IHRvIGVhc2lseSB1c2UgaW4gUkVQTFxuc2lnbkFzeW5jLCB2ZXJpZnlBc3luYywgQ1VSVkUsIGV0YywgdXRpbHMsIFBvaW50IGFzIEV4dGVuZGVkUG9pbnQgfTsgLy8gZW52cyBsaWtlIGJyb3dzZXIgY29uc29sZVxuIl0sIm5hbWVzIjpbIlAiLCJOIiwiR3giLCJHeSIsIkNVUlZFIiwiYSIsImQiLCJwIiwibiIsImgiLCJlcnIiLCJtIiwiRXJyb3IiLCJzdHIiLCJzIiwiaXN1OCIsIlVpbnQ4QXJyYXkiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJhdTgiLCJsIiwibGVuZ3RoIiwidThuIiwiZGF0YSIsInRvVTgiLCJsZW4iLCJoMmIiLCJtb2QiLCJiIiwiciIsImlzUG9pbnQiLCJQb2ludCIsImV4IiwiZXkiLCJleiIsImV0IiwiZnJvbUFmZmluZSIsIngiLCJ5IiwiZnJvbUhleCIsImhleCIsInppcDIxNSIsIm5vcm1lZCIsInNsaWNlIiwibGFzdEJ5dGUiLCJiMm5fTEUiLCJ5MiIsInUiLCJ2IiwiaXNWYWxpZCIsInZhbHVlIiwidXZSYXRpbyIsImlzWE9kZCIsImlzTGFzdEJ5dGVPZGQiLCJ0b0FmZmluZSIsImVxdWFscyIsIm90aGVyIiwiWDEiLCJZMSIsIloxIiwiWDIiLCJZMiIsIloyIiwiWDFaMiIsIlgyWjEiLCJZMVoyIiwiWTJaMSIsImlzMCIsIkkiLCJuZWdhdGUiLCJkb3VibGUiLCJBIiwiQiIsIkMiLCJEIiwieDF5MSIsIkUiLCJHIiwiRiIsIkgiLCJYMyIsIlkzIiwiVDMiLCJaMyIsImFkZCIsIlQxIiwiVDIiLCJtdWwiLCJzYWZlIiwid05BRiIsImYiLCJtdWx0aXBseSIsInNjYWxhciIsImNsZWFyQ29mYWN0b3IiLCJCaWdJbnQiLCJpc1NtYWxsT3JkZXIiLCJpc1RvcnNpb25GcmVlIiwieiIsIml6IiwiaW52ZXJ0IiwidG9SYXdCeXRlcyIsIm4yYl8zMkxFIiwidG9IZXgiLCJiMmgiLCJCQVNFIiwiWkVSTyIsInBhZGgiLCJudW0iLCJwYWQiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiQXJyYXkiLCJmcm9tIiwibWFwIiwiZSIsImpvaW4iLCJhcnIiLCJpIiwiaiIsIk51bWJlciIsInBhcnNlSW50IiwiaXNOYU4iLCJyZXZlcnNlIiwiY29uY2F0QiIsImFycnMiLCJyZWR1Y2UiLCJzdW0iLCJmb3JFYWNoIiwic2V0IiwibWQiLCJxIiwicG93MiIsInBvd2VyIiwicG93XzJfMjUyXzMiLCJ4MiIsImIyIiwiYjQiLCJiNSIsImIxMCIsImIyMCIsImI0MCIsImI4MCIsImIxNjAiLCJiMjQwIiwiYjI1MCIsInBvd19wXzVfOCIsIlJNMSIsInYzIiwidjciLCJwb3ciLCJ2eDIiLCJyb290MSIsInJvb3QyIiwidXNlUm9vdDEiLCJ1c2VSb290MiIsIm5vUm9vdCIsIm1vZExfTEUiLCJoYXNoIiwiX3NoYVMiLCJzaGE1MTJhIiwiZXRjIiwic2hhNTEyQXN5bmMiLCJzaGE1MTJzIiwiaGFzaDJleHRLIiwiaGFzaGVkIiwiaGVhZCIsInByZWZpeCIsInBvaW50IiwicG9pbnRCeXRlcyIsImdldEV4dGVuZGVkUHVibGljS2V5QXN5bmMiLCJwcml2IiwidGhlbiIsImdldEV4dGVuZGVkUHVibGljS2V5IiwiZ2V0UHVibGljS2V5QXN5bmMiLCJnZXRQdWJsaWNLZXkiLCJoYXNoRmluaXNoIiwiYXN5bmNocm9ub3VzIiwicmVzIiwiaGFzaGFibGUiLCJmaW5pc2giLCJfc2lnbiIsInJCeXRlcyIsIm1zZyIsIlIiLCJTIiwic2lnbkFzeW5jIiwicHJpdktleSIsInNpZ24iLCJkdm8iLCJfdmVyaWZ5Iiwic2lnIiwicHViIiwib3B0cyIsIlNCIiwiZXJyb3IiLCJrIiwiUmtBIiwidmVyaWZ5QXN5bmMiLCJ2ZXJpZnkiLCJjciIsImdsb2JhbFRoaXMiLCJjcnlwdG8iLCJ1bmRlZmluZWQiLCJieXRlc1RvSGV4IiwiaGV4VG9CeXRlcyIsImNvbmNhdEJ5dGVzIiwicmFuZG9tQnl0ZXMiLCJnZXRSYW5kb21WYWx1ZXMiLCJtZXNzYWdlcyIsInN1YnRsZSIsImRpZ2VzdCIsImJ1ZmZlciIsInNoYTUxMlN5bmMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY29uZmlndXJhYmxlIiwiZ2V0IiwidXRpbHMiLCJyYW5kb21Qcml2YXRlS2V5IiwicHJlY29tcHV0ZSIsInciLCJXIiwicG9pbnRzIiwid2luZG93cyIsInB1c2giLCJHcG93cyIsImNvbXAiLCJuZWciLCJjbmQiLCJ3c2l6ZSIsIm1hc2siLCJtYXhOdW0iLCJzaGlmdEJ5Iiwib2ZmIiwid2JpdHMiLCJvZmYxIiwib2ZmMiIsIk1hdGgiLCJhYnMiLCJjbmQxIiwiY25kMiIsIkV4dGVuZGVkUG9pbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/ed25519/index.js\n");

/***/ })

};
;