"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reduxjs";
exports.ids = ["vendor-chunks/@reduxjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MiddlewareArray: () => (/* binding */ MiddlewareArray),\n/* harmony export */   TaskAbortError: () => (/* binding */ TaskAbortError),\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes),\n/* harmony export */   addListener: () => (/* binding */ addListener),\n/* harmony export */   applyMiddleware: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware),\n/* harmony export */   bindActionCreators: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators),\n/* harmony export */   clearAllListeners: () => (/* binding */ clearAllListeners),\n/* harmony export */   combineReducers: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers),\n/* harmony export */   compose: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose),\n/* harmony export */   configureStore: () => (/* binding */ configureStore),\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   createAsyncThunk: () => (/* binding */ createAsyncThunk),\n/* harmony export */   createDraftSafeSelector: () => (/* binding */ createDraftSafeSelector),\n/* harmony export */   createEntityAdapter: () => (/* binding */ createEntityAdapter),\n/* harmony export */   createImmutableStateInvariantMiddleware: () => (/* binding */ createImmutableStateInvariantMiddleware),\n/* harmony export */   createListenerMiddleware: () => (/* binding */ createListenerMiddleware),\n/* harmony export */   createNextState: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   createReducer: () => (/* binding */ createReducer),\n/* harmony export */   createSelector: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector),\n/* harmony export */   createSerializableStateInvariantMiddleware: () => (/* binding */ createSerializableStateInvariantMiddleware),\n/* harmony export */   createSlice: () => (/* binding */ createSlice),\n/* harmony export */   createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore),\n/* harmony export */   current: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current),\n/* harmony export */   findNonSerializableValue: () => (/* binding */ findNonSerializableValue),\n/* harmony export */   freeze: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze),\n/* harmony export */   getDefaultMiddleware: () => (/* binding */ getDefaultMiddleware),\n/* harmony export */   getType: () => (/* binding */ getType),\n/* harmony export */   isAllOf: () => (/* binding */ isAllOf),\n/* harmony export */   isAnyOf: () => (/* binding */ isAnyOf),\n/* harmony export */   isAsyncThunkAction: () => (/* binding */ isAsyncThunkAction),\n/* harmony export */   isDraft: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft),\n/* harmony export */   isFulfilled: () => (/* binding */ isFulfilled),\n/* harmony export */   isImmutableDefault: () => (/* binding */ isImmutableDefault),\n/* harmony export */   isPending: () => (/* binding */ isPending),\n/* harmony export */   isPlain: () => (/* binding */ isPlain),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRejected: () => (/* binding */ isRejected),\n/* harmony export */   isRejectedWithValue: () => (/* binding */ isRejectedWithValue),\n/* harmony export */   legacy_createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore),\n/* harmony export */   miniSerializeError: () => (/* binding */ miniSerializeError),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   original: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original),\n/* harmony export */   removeListener: () => (/* binding */ removeListener),\n/* harmony export */   unwrapResult: () => (/* binding */ unwrapResult)\n/* harmony export */ });\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.esm.mjs\");\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/es/redux.js\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/@reduxjs/toolkit/node_modules/reselect/es/index.js\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/redux-thunk/es/index.js\");\nvar __extends = undefined && undefined.__extends || function() {\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n    };\n    return function(d, b) {\n        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar __generator = undefined && undefined.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar __spreadArray = undefined && undefined.__spreadArray || function(to, from) {\n    for(var i = 0, il = from.length, j = to.length; i < il; i++, j++)to[j] = from[i];\n    return to;\n};\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function(obj, key, value) {\n    return key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __spreadValues = function(a, b) {\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for(var _i = 0, _c = __getOwnPropSymbols(b); _i < _c.length; _i++){\n        var prop = _c[_i];\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __spreadProps = function(a, b) {\n    return __defProps(a, __getOwnPropDescs(b));\n};\nvar __async = function(__this, __arguments, generator) {\n    return new Promise(function(resolve, reject) {\n        var fulfilled = function(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var rejected = function(value) {\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var step = function(x) {\n            return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n        };\n        step((generator = generator.apply(__this, __arguments)).next());\n    });\n};\n// src/index.ts\n\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelector = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    var selector = reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector.apply(void 0, args);\n    var wrappedSelector = function(value) {\n        var rest = [];\n        for(var _i = 1; _i < arguments.length; _i++){\n            rest[_i - 1] = arguments[_i];\n        }\n        return selector.apply(void 0, __spreadArray([\n            (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value\n        ], rest));\n    };\n    return wrappedSelector;\n};\n// src/configureStore.ts\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools =  false ? 0 : function() {\n    if (arguments.length === 0) return void 0;\n    if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer =  false ? 0 : function() {\n    return function(noop2) {\n        return noop2;\n    };\n};\n// src/isPlainObject.ts\nfunction isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) return false;\n    var proto = Object.getPrototypeOf(value);\n    if (proto === null) return true;\n    var baseProto = proto;\n    while(Object.getPrototypeOf(baseProto) !== null){\n        baseProto = Object.getPrototypeOf(baseProto);\n    }\n    return proto === baseProto;\n}\n// src/getDefaultMiddleware.ts\n\n// src/utils.ts\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n    var elapsed = 0;\n    return {\n        measureTime: function(fn) {\n            var started = Date.now();\n            try {\n                return fn();\n            } finally{\n                var finished = Date.now();\n                elapsed += finished - started;\n            }\n        },\n        warnIfExceeded: function() {\n            if (elapsed > maxDelay) {\n                console.warn(fnName + \" took \" + elapsed + \"ms, which is more than the warning threshold of \" + maxDelay + \"ms. \\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\\nIt is disabled in production builds, so you don't need to worry about that.\");\n            }\n        }\n    };\n}\nvar MiddlewareArray = /** @class */ function(_super) {\n    __extends(MiddlewareArray, _super);\n    function MiddlewareArray() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        var _this = _super.apply(this, args) || this;\n        Object.setPrototypeOf(_this, MiddlewareArray.prototype);\n        return _this;\n    }\n    Object.defineProperty(MiddlewareArray, Symbol.species, {\n        get: function() {\n            return MiddlewareArray;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MiddlewareArray.prototype.concat = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        return _super.prototype.concat.apply(this, arr);\n    };\n    MiddlewareArray.prototype.prepend = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([\n                void 0\n            ], arr[0].concat(this))))();\n        }\n        return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([\n            void 0\n        ], arr.concat(this))))();\n    };\n    return MiddlewareArray;\n}(Array);\n// src/immutableStateInvariantMiddleware.ts\nvar isProduction = \"development\" === \"production\";\nvar prefix = \"Invariant failed\";\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    throw new Error(prefix + \": \" + (message || \"\"));\n}\nfunction stringify(obj, serializer, indent, decycler) {\n    return JSON.stringify(obj, getSerialize(serializer, decycler), indent);\n}\nfunction getSerialize(serializer, decycler) {\n    var stack = [], keys = [];\n    if (!decycler) decycler = function(_, value) {\n        if (stack[0] === value) return \"[Circular ~]\";\n        return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n    };\n    return function(key, value) {\n        if (stack.length > 0) {\n            var thisPos = stack.indexOf(this);\n            ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n            ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n            if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n        } else stack.push(value);\n        return serializer == null ? value : serializer.call(this, key, value);\n    };\n}\nfunction isImmutableDefault(value) {\n    return typeof value !== \"object\" || value === null || typeof value === \"undefined\" || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n    var trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n    return {\n        detectMutations: function() {\n            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n        }\n    };\n}\nfunction trackProperties(isImmutable, ignorePaths, obj, path) {\n    if (ignorePaths === void 0) {\n        ignorePaths = [];\n    }\n    if (path === void 0) {\n        path = \"\";\n    }\n    var tracked = {\n        value: obj\n    };\n    if (!isImmutable(obj)) {\n        tracked.children = {};\n        for(var key in obj){\n            var childPath = path ? path + \".\" + key : key;\n            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n                continue;\n            }\n            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n        }\n    }\n    return tracked;\n}\nfunction detectMutations(isImmutable, ignorePaths, trackedProperty, obj, sameParentRef, path) {\n    if (ignorePaths === void 0) {\n        ignorePaths = [];\n    }\n    if (sameParentRef === void 0) {\n        sameParentRef = false;\n    }\n    if (path === void 0) {\n        path = \"\";\n    }\n    var prevObj = trackedProperty ? trackedProperty.value : void 0;\n    var sameRef = prevObj === obj;\n    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n        return {\n            wasMutated: true,\n            path: path\n        };\n    }\n    if (isImmutable(prevObj) || isImmutable(obj)) {\n        return {\n            wasMutated: false\n        };\n    }\n    var keysToDetect = {};\n    for(var key in trackedProperty.children){\n        keysToDetect[key] = true;\n    }\n    for(var key in obj){\n        keysToDetect[key] = true;\n    }\n    for(var key in keysToDetect){\n        var childPath = path ? path + \".\" + key : key;\n        if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n            continue;\n        }\n        var result = detectMutations(isImmutable, ignorePaths, trackedProperty.children[key], obj[key], sameRef, childPath);\n        if (result.wasMutated) {\n            return result;\n        }\n    }\n    return {\n        wasMutated: false\n    };\n}\nfunction createImmutableStateInvariantMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (false) {}\n    var _c = options.isImmutable, isImmutable = _c === void 0 ? isImmutableDefault : _c, ignoredPaths = options.ignoredPaths, _d = options.warnAfter, warnAfter = _d === void 0 ? 32 : _d, ignore = options.ignore;\n    ignoredPaths = ignoredPaths || ignore;\n    var track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n    return function(_c) {\n        var getState = _c.getState;\n        var state = getState();\n        var tracker = track(state);\n        var result;\n        return function(next) {\n            return function(action) {\n                var measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n                measureUtils.measureTime(function() {\n                    state = getState();\n                    result = tracker.detectMutations();\n                    tracker = track(state);\n                    invariant(!result.wasMutated, \"A state mutation was detected between dispatches, in the path '\" + (result.path || \"\") + \"'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\");\n                });\n                var dispatchedAction = next(action);\n                measureUtils.measureTime(function() {\n                    state = getState();\n                    result = tracker.detectMutations();\n                    tracker = track(state);\n                    result.wasMutated && invariant(!result.wasMutated, \"A state mutation was detected inside a dispatch, in the path: \" + (result.path || \"\") + \". Take a look at the reducer(s) handling the action \" + stringify(action) + \". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\");\n                });\n                measureUtils.warnIfExceeded();\n                return dispatchedAction;\n            };\n        };\n    };\n}\n// src/serializableStateInvariantMiddleware.ts\nfunction isPlain(val) {\n    var type = typeof val;\n    return type === \"undefined\" || val === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || isPlainObject(val);\n}\nfunction findNonSerializableValue(value, path, isSerializable, getEntries, ignoredPaths) {\n    if (path === void 0) {\n        path = \"\";\n    }\n    if (isSerializable === void 0) {\n        isSerializable = isPlain;\n    }\n    if (ignoredPaths === void 0) {\n        ignoredPaths = [];\n    }\n    var foundNestedSerializable;\n    if (!isSerializable(value)) {\n        return {\n            keyPath: path || \"<root>\",\n            value: value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    var entries = getEntries != null ? getEntries(value) : Object.entries(value);\n    var hasIgnoredPaths = ignoredPaths.length > 0;\n    for(var _i = 0, entries_1 = entries; _i < entries_1.length; _i++){\n        var _c = entries_1[_i], key = _c[0], nestedValue = _c[1];\n        var nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath) >= 0) {\n            continue;\n        }\n        if (!isSerializable(nestedValue)) {\n            return {\n                keyPath: nestedPath,\n                value: nestedValue\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths);\n            if (foundNestedSerializable) {\n                return foundNestedSerializable;\n            }\n        }\n    }\n    return false;\n}\nfunction createSerializableStateInvariantMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (false) {}\n    var _c = options.isSerializable, isSerializable = _c === void 0 ? isPlain : _c, getEntries = options.getEntries, _d = options.ignoredActions, ignoredActions = _d === void 0 ? [] : _d, _e = options.ignoredActionPaths, ignoredActionPaths = _e === void 0 ? [\n        \"meta.arg\",\n        \"meta.baseQueryMeta\"\n    ] : _e, _f = options.ignoredPaths, ignoredPaths = _f === void 0 ? [] : _f, _g = options.warnAfter, warnAfter = _g === void 0 ? 32 : _g, _h = options.ignoreState, ignoreState = _h === void 0 ? false : _h, _j = options.ignoreActions, ignoreActions = _j === void 0 ? false : _j;\n    return function(storeAPI) {\n        return function(next) {\n            return function(action) {\n                var result = next(action);\n                var measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n                if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n                    measureUtils.measureTime(function() {\n                        var foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths);\n                        if (foundActionNonSerializableValue) {\n                            var keyPath = foundActionNonSerializableValue.keyPath, value = foundActionNonSerializableValue.value;\n                            console.error(\"A non-serializable value was detected in an action, in the path: `\" + keyPath + \"`. Value:\", value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n                        }\n                    });\n                }\n                if (!ignoreState) {\n                    measureUtils.measureTime(function() {\n                        var state = storeAPI.getState();\n                        var foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths);\n                        if (foundStateNonSerializableValue) {\n                            var keyPath = foundStateNonSerializableValue.keyPath, value = foundStateNonSerializableValue.value;\n                            console.error(\"A non-serializable value was detected in the state, in the path: `\" + keyPath + \"`. Value:\", value, \"\\nTake a look at the reducer(s) handling this action type: \" + action.type + \".\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)\");\n                        }\n                    });\n                    measureUtils.warnIfExceeded();\n                }\n                return result;\n            };\n        };\n    };\n}\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n    return typeof x === \"boolean\";\n}\nfunction curryGetDefaultMiddleware() {\n    return function curriedGetDefaultMiddleware(options) {\n        return getDefaultMiddleware(options);\n    };\n}\nfunction getDefaultMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _c = options.thunk, thunk = _c === void 0 ? true : _c, _d = options.immutableCheck, immutableCheck = _d === void 0 ? true : _d, _e = options.serializableCheck, serializableCheck = _e === void 0 ? true : _e;\n    var middlewareArray = new MiddlewareArray();\n    if (thunk) {\n        if (isBoolean(thunk)) {\n            middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n        } else {\n            middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__[\"default\"].withExtraArgument(thunk.extraArgument));\n        }\n    }\n    if (true) {\n        if (immutableCheck) {\n            var immutableOptions = {};\n            if (!isBoolean(immutableCheck)) {\n                immutableOptions = immutableCheck;\n            }\n            middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n        }\n        if (serializableCheck) {\n            var serializableOptions = {};\n            if (!isBoolean(serializableCheck)) {\n                serializableOptions = serializableCheck;\n            }\n            middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n        }\n    }\n    return middlewareArray;\n}\n// src/configureStore.ts\nvar IS_PRODUCTION = \"development\" === \"production\";\nfunction configureStore(options) {\n    var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();\n    var _c = options || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c.middleware, middleware = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;\n    var rootReducer;\n    if (typeof reducer === \"function\") {\n        rootReducer = reducer;\n    } else if (isPlainObject(reducer)) {\n        rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n    } else {\n        throw new Error('\"reducer\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');\n    }\n    var finalMiddleware = middleware;\n    if (typeof finalMiddleware === \"function\") {\n        finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);\n        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n            throw new Error(\"when using a middleware builder function, an array of middleware must be returned\");\n        }\n    }\n    if (!IS_PRODUCTION && finalMiddleware.some(function(item) {\n        return typeof item !== \"function\";\n    })) {\n        throw new Error(\"each middleware provided to configureStore must be a function\");\n    }\n    var middlewareEnhancer = redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware.apply(void 0, finalMiddleware);\n    var finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    if (devTools) {\n        finalCompose = composeWithDevTools(__spreadValues({\n            trace: !IS_PRODUCTION\n        }, typeof devTools === \"object\" && devTools));\n    }\n    var storeEnhancers = [\n        middlewareEnhancer\n    ];\n    if (Array.isArray(enhancers)) {\n        storeEnhancers = __spreadArray([\n            middlewareEnhancer\n        ], enhancers);\n    } else if (typeof enhancers === \"function\") {\n        storeEnhancers = enhancers(storeEnhancers);\n    }\n    var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n    function actionCreator() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        if (prepareAction) {\n            var prepared = prepareAction.apply(void 0, args);\n            if (!prepared) {\n                throw new Error(\"prepareAction did not return an object\");\n            }\n            return __spreadValues(__spreadValues({\n                type: type,\n                payload: prepared.payload\n            }, \"meta\" in prepared && {\n                meta: prepared.meta\n            }), \"error\" in prepared && {\n                error: prepared.error\n            });\n        }\n        return {\n            type: type,\n            payload: args[0]\n        };\n    }\n    actionCreator.toString = function() {\n        return \"\" + type;\n    };\n    actionCreator.type = type;\n    actionCreator.match = function(action) {\n        return action.type === type;\n    };\n    return actionCreator;\n}\nfunction isFSA(action) {\n    return isPlainObject(action) && typeof action.type === \"string\" && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n    return [\n        \"type\",\n        \"payload\",\n        \"error\",\n        \"meta\"\n    ].indexOf(key) > -1;\n}\nfunction getType(actionCreator) {\n    return \"\" + actionCreator;\n}\n// src/createReducer.ts\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n    var actionsMap = {};\n    var actionMatchers = [];\n    var defaultCaseReducer;\n    var builder = {\n        addCase: function(typeOrActionCreator, reducer) {\n            if (true) {\n                if (actionMatchers.length > 0) {\n                    throw new Error(\"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n                }\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            var type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n            if (type in actionsMap) {\n                throw new Error(\"addCase cannot be called with two reducers for the same action type\");\n            }\n            actionsMap[type] = reducer;\n            return builder;\n        },\n        addMatcher: function(matcher, reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            actionMatchers.push({\n                matcher: matcher,\n                reducer: reducer\n            });\n            return builder;\n        },\n        addDefaultCase: function(reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addDefaultCase` can only be called once\");\n                }\n            }\n            defaultCaseReducer = reducer;\n            return builder;\n        }\n    };\n    builderCallback(builder);\n    return [\n        actionsMap,\n        actionMatchers,\n        defaultCaseReducer\n    ];\n}\n// src/createReducer.ts\nfunction isStateFunction(x) {\n    return typeof x === \"function\";\n}\nfunction createReducer(initialState, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {\n    if (actionMatchers === void 0) {\n        actionMatchers = [];\n    }\n    var _c = typeof mapOrBuilderCallback === \"function\" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [\n        mapOrBuilderCallback,\n        actionMatchers,\n        defaultCaseReducer\n    ], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];\n    var getInitialState;\n    if (isStateFunction(initialState)) {\n        getInitialState = function() {\n            return (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(initialState(), function() {});\n        };\n    } else {\n        var frozenInitialState_1 = (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(initialState, function() {});\n        getInitialState = function() {\n            return frozenInitialState_1;\n        };\n    }\n    function reducer(state, action) {\n        if (state === void 0) {\n            state = getInitialState();\n        }\n        var caseReducers = __spreadArray([\n            actionsMap[action.type]\n        ], finalActionMatchers.filter(function(_c) {\n            var matcher = _c.matcher;\n            return matcher(action);\n        }).map(function(_c) {\n            var reducer2 = _c.reducer;\n            return reducer2;\n        }));\n        if (caseReducers.filter(function(cr) {\n            return !!cr;\n        }).length === 0) {\n            caseReducers = [\n                finalDefaultCaseReducer\n            ];\n        }\n        return caseReducers.reduce(function(previousState, caseReducer) {\n            if (caseReducer) {\n                if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n                    var draft = previousState;\n                    var result = caseReducer(draft, action);\n                    if (typeof result === \"undefined\") {\n                        return previousState;\n                    }\n                    return result;\n                } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n                    var result = caseReducer(previousState, action);\n                    if (typeof result === \"undefined\") {\n                        if (previousState === null) {\n                            return previousState;\n                        }\n                        throw Error(\"A case reducer on a non-draftable value must not return undefined\");\n                    }\n                    return result;\n                } else {\n                    return (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(previousState, function(draft) {\n                        return caseReducer(draft, action);\n                    });\n                }\n            }\n            return previousState;\n        }, state);\n    }\n    reducer.getInitialState = getInitialState;\n    return reducer;\n}\n// src/createSlice.ts\nfunction getType2(slice, actionKey) {\n    return slice + \"/\" + actionKey;\n}\nfunction createSlice(options) {\n    var name = options.name;\n    if (!name) {\n        throw new Error(\"`name` is a required option for createSlice\");\n    }\n    var initialState = typeof options.initialState == \"function\" ? options.initialState : (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(options.initialState, function() {});\n    var reducers = options.reducers || {};\n    var reducerNames = Object.keys(reducers);\n    var sliceCaseReducersByName = {};\n    var sliceCaseReducersByType = {};\n    var actionCreators = {};\n    reducerNames.forEach(function(reducerName) {\n        var maybeReducerWithPrepare = reducers[reducerName];\n        var type = getType2(name, reducerName);\n        var caseReducer;\n        var prepareCallback;\n        if (\"reducer\" in maybeReducerWithPrepare) {\n            caseReducer = maybeReducerWithPrepare.reducer;\n            prepareCallback = maybeReducerWithPrepare.prepare;\n        } else {\n            caseReducer = maybeReducerWithPrepare;\n        }\n        sliceCaseReducersByName[reducerName] = caseReducer;\n        sliceCaseReducersByType[type] = caseReducer;\n        actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);\n    });\n    function buildReducer() {\n        var _c = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [\n            options.extraReducers\n        ], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e = _c[1], actionMatchers = _e === void 0 ? [] : _e, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;\n        var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);\n        return createReducer(initialState, finalCaseReducers, actionMatchers, defaultCaseReducer);\n    }\n    var _reducer;\n    return {\n        name: name,\n        reducer: function(state, action) {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer(state, action);\n        },\n        actions: actionCreators,\n        caseReducers: sliceCaseReducersByName,\n        getInitialState: function() {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer.getInitialState();\n        }\n    };\n}\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n    return {\n        ids: [],\n        entities: {}\n    };\n}\nfunction createInitialStateFactory() {\n    function getInitialState(additionalState) {\n        if (additionalState === void 0) {\n            additionalState = {};\n        }\n        return Object.assign(getInitialEntityState(), additionalState);\n    }\n    return {\n        getInitialState: getInitialState\n    };\n}\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n    function getSelectors(selectState) {\n        var selectIds = function(state) {\n            return state.ids;\n        };\n        var selectEntities = function(state) {\n            return state.entities;\n        };\n        var selectAll = createDraftSafeSelector(selectIds, selectEntities, function(ids, entities) {\n            return ids.map(function(id) {\n                return entities[id];\n            });\n        });\n        var selectId = function(_, id) {\n            return id;\n        };\n        var selectById = function(entities, id) {\n            return entities[id];\n        };\n        var selectTotal = createDraftSafeSelector(selectIds, function(ids) {\n            return ids.length;\n        });\n        if (!selectState) {\n            return {\n                selectIds: selectIds,\n                selectEntities: selectEntities,\n                selectAll: selectAll,\n                selectTotal: selectTotal,\n                selectById: createDraftSafeSelector(selectEntities, selectId, selectById)\n            };\n        }\n        var selectGlobalizedEntities = createDraftSafeSelector(selectState, selectEntities);\n        return {\n            selectIds: createDraftSafeSelector(selectState, selectIds),\n            selectEntities: selectGlobalizedEntities,\n            selectAll: createDraftSafeSelector(selectState, selectAll),\n            selectTotal: createDraftSafeSelector(selectState, selectTotal),\n            selectById: createDraftSafeSelector(selectGlobalizedEntities, selectId, selectById)\n        };\n    }\n    return {\n        getSelectors: getSelectors\n    };\n}\n// src/entities/state_adapter.ts\n\nfunction createSingleArgumentStateOperator(mutator) {\n    var operator = createStateOperator(function(_, state) {\n        return mutator(state);\n    });\n    return function operation(state) {\n        return operator(state, void 0);\n    };\n}\nfunction createStateOperator(mutator) {\n    return function operation(state, arg) {\n        function isPayloadActionArgument(arg2) {\n            return isFSA(arg2);\n        }\n        var runMutator = function(draft) {\n            if (isPayloadActionArgument(arg)) {\n                mutator(arg.payload, draft);\n            } else {\n                mutator(arg, draft);\n            }\n        };\n        if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(state)) {\n            runMutator(state);\n            return state;\n        } else {\n            return (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state, runMutator);\n        }\n    };\n}\n// src/entities/utils.ts\nfunction selectIdValue(entity, selectId) {\n    var key = selectId(entity);\n    if ( true && key === void 0) {\n        console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n    }\n    return key;\n}\nfunction ensureEntitiesArray(entities) {\n    if (!Array.isArray(entities)) {\n        entities = Object.values(entities);\n    }\n    return entities;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    var added = [];\n    var updated = [];\n    for(var _i = 0, newEntities_1 = newEntities; _i < newEntities_1.length; _i++){\n        var entity = newEntities_1[_i];\n        var id = selectIdValue(entity, selectId);\n        if (id in state.entities) {\n            updated.push({\n                id: id,\n                changes: entity\n            });\n        } else {\n            added.push(entity);\n        }\n    }\n    return [\n        added,\n        updated\n    ];\n}\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n    function addOneMutably(entity, state) {\n        var key = selectIdValue(entity, selectId);\n        if (key in state.entities) {\n            return;\n        }\n        state.ids.push(key);\n        state.entities[key] = entity;\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for(var _i = 0, newEntities_2 = newEntities; _i < newEntities_2.length; _i++){\n            var entity = newEntities_2[_i];\n            addOneMutably(entity, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        var key = selectIdValue(entity, selectId);\n        if (!(key in state.entities)) {\n            state.ids.push(key);\n        }\n        state.entities[key] = entity;\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for(var _i = 0, newEntities_3 = newEntities; _i < newEntities_3.length; _i++){\n            var entity = newEntities_3[_i];\n            setOneMutably(entity, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.ids = [];\n        state.entities = {};\n        addManyMutably(newEntities, state);\n    }\n    function removeOneMutably(key, state) {\n        return removeManyMutably([\n            key\n        ], state);\n    }\n    function removeManyMutably(keys, state) {\n        var didMutate = false;\n        keys.forEach(function(key) {\n            if (key in state.entities) {\n                delete state.entities[key];\n                didMutate = true;\n            }\n        });\n        if (didMutate) {\n            state.ids = state.ids.filter(function(id) {\n                return id in state.entities;\n            });\n        }\n    }\n    function removeAllMutably(state) {\n        Object.assign(state, {\n            ids: [],\n            entities: {}\n        });\n    }\n    function takeNewKey(keys, update, state) {\n        var original2 = state.entities[update.id];\n        var updated = Object.assign({}, original2, update.changes);\n        var newKey = selectIdValue(updated, selectId);\n        var hasNewKey = newKey !== update.id;\n        if (hasNewKey) {\n            keys[update.id] = newKey;\n            delete state.entities[update.id];\n        }\n        state.entities[newKey] = updated;\n        return hasNewKey;\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        var newKeys = {};\n        var updatesPerEntity = {};\n        updates.forEach(function(update) {\n            if (update.id in state.entities) {\n                updatesPerEntity[update.id] = {\n                    id: update.id,\n                    changes: __spreadValues(__spreadValues({}, updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null), update.changes)\n                };\n            }\n        });\n        updates = Object.values(updatesPerEntity);\n        var didMutateEntities = updates.length > 0;\n        if (didMutateEntities) {\n            var didMutateIds = updates.filter(function(update) {\n                return takeNewKey(newKeys, update, state);\n            }).length > 0;\n            if (didMutateIds) {\n                state.ids = state.ids.map(function(id) {\n                    return newKeys[id] || id;\n                });\n            }\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    return {\n        removeAll: createSingleArgumentStateOperator(removeAllMutably),\n        addOne: createStateOperator(addOneMutably),\n        addMany: createStateOperator(addManyMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        upsertMany: createStateOperator(upsertManyMutably),\n        removeOne: createStateOperator(removeOneMutably),\n        removeMany: createStateOperator(removeManyMutably)\n    };\n}\n// src/entities/sorted_state_adapter.ts\nfunction createSortedStateAdapter(selectId, sort) {\n    var _c = createUnsortedStateAdapter(selectId), removeOne = _c.removeOne, removeMany = _c.removeMany, removeAll = _c.removeAll;\n    function addOneMutably(entity, state) {\n        return addManyMutably([\n            entity\n        ], state);\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        var models = newEntities.filter(function(model) {\n            return !(selectIdValue(model, selectId) in state.entities);\n        });\n        if (models.length !== 0) {\n            merge(models, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        return setManyMutably([\n            entity\n        ], state);\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        if (newEntities.length !== 0) {\n            merge(newEntities, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.entities = {};\n        state.ids = [];\n        addManyMutably(newEntities, state);\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function takeUpdatedModel(models, update, state) {\n        if (!(update.id in state.entities)) {\n            return false;\n        }\n        var original2 = state.entities[update.id];\n        var updated = Object.assign({}, original2, update.changes);\n        var newKey = selectIdValue(updated, selectId);\n        delete state.entities[update.id];\n        models.push(updated);\n        return newKey !== update.id;\n    }\n    function updateManyMutably(updates, state) {\n        var models = [];\n        updates.forEach(function(update) {\n            return takeUpdatedModel(models, update, state);\n        });\n        if (models.length !== 0) {\n            merge(models, state);\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    function areArraysEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(var i = 0; i < a.length && i < b.length; i++){\n            if (a[i] === b[i]) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    function merge(models, state) {\n        models.forEach(function(model) {\n            state.entities[selectId(model)] = model;\n        });\n        var allEntities = Object.values(state.entities);\n        allEntities.sort(sort);\n        var newSortedIds = allEntities.map(selectId);\n        var ids = state.ids;\n        if (!areArraysEqual(ids, newSortedIds)) {\n            state.ids = newSortedIds;\n        }\n    }\n    return {\n        removeOne: removeOne,\n        removeMany: removeMany,\n        removeAll: removeAll,\n        addOne: createStateOperator(addOneMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        addMany: createStateOperator(addManyMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertMany: createStateOperator(upsertManyMutably)\n    };\n}\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _c = __spreadValues({\n        sortComparer: false,\n        selectId: function(instance) {\n            return instance.id;\n        }\n    }, options), selectId = _c.selectId, sortComparer = _c.sortComparer;\n    var stateFactory = createInitialStateFactory();\n    var selectorsFactory = createSelectorsFactory();\n    var stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n    return __spreadValues(__spreadValues(__spreadValues({\n        selectId: selectId,\n        sortComparer: sortComparer\n    }, stateFactory), selectorsFactory), stateAdapter);\n}\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = function(size) {\n    if (size === void 0) {\n        size = 21;\n    }\n    var id = \"\";\n    var i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n// src/createAsyncThunk.ts\nvar commonProperties = [\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\"\n];\nvar RejectWithValue = /** @class */ function() {\n    function RejectWithValue(payload, meta) {\n        this.payload = payload;\n        this.meta = meta;\n    }\n    return RejectWithValue;\n}();\nvar FulfillWithMeta = /** @class */ function() {\n    function FulfillWithMeta(payload, meta) {\n        this.payload = payload;\n        this.meta = meta;\n    }\n    return FulfillWithMeta;\n}();\nvar miniSerializeError = function(value) {\n    if (typeof value === \"object\" && value !== null) {\n        var simpleError = {};\n        for(var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++){\n            var property = commonProperties_1[_i];\n            if (typeof value[property] === \"string\") {\n                simpleError[property] = value[property];\n            }\n        }\n        return simpleError;\n    }\n    return {\n        message: String(value)\n    };\n};\nfunction createAsyncThunk(typePrefix, payloadCreator, options) {\n    var fulfilled = createAction(typePrefix + \"/fulfilled\", function(payload, requestId, arg, meta) {\n        return {\n            payload: payload,\n            meta: __spreadProps(__spreadValues({}, meta || {}), {\n                arg: arg,\n                requestId: requestId,\n                requestStatus: \"fulfilled\"\n            })\n        };\n    });\n    var pending = createAction(typePrefix + \"/pending\", function(requestId, arg, meta) {\n        return {\n            payload: void 0,\n            meta: __spreadProps(__spreadValues({}, meta || {}), {\n                arg: arg,\n                requestId: requestId,\n                requestStatus: \"pending\"\n            })\n        };\n    });\n    var rejected = createAction(typePrefix + \"/rejected\", function(error, requestId, arg, payload, meta) {\n        return {\n            payload: payload,\n            error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n            meta: __spreadProps(__spreadValues({}, meta || {}), {\n                arg: arg,\n                requestId: requestId,\n                rejectedWithValue: !!payload,\n                requestStatus: \"rejected\",\n                aborted: (error == null ? void 0 : error.name) === \"AbortError\",\n                condition: (error == null ? void 0 : error.name) === \"ConditionError\"\n            })\n        };\n    });\n    var displayedWarning = false;\n    var AC = typeof AbortController !== \"undefined\" ? AbortController : /** @class */ function() {\n        function class_1() {\n            this.signal = {\n                aborted: false,\n                addEventListener: function() {},\n                dispatchEvent: function() {\n                    return false;\n                },\n                onabort: function() {},\n                removeEventListener: function() {}\n            };\n        }\n        class_1.prototype.abort = function() {\n            if (true) {\n                if (!displayedWarning) {\n                    displayedWarning = true;\n                    console.info(\"This platform does not implement AbortController. \\nIf you want to use the AbortController to react to `abort` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.\");\n                }\n            }\n        };\n        return class_1;\n    }();\n    function actionCreator(arg) {\n        return function(dispatch, getState, extra) {\n            var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();\n            var abortController = new AC();\n            var abortReason;\n            var abortedPromise = new Promise(function(_, reject) {\n                return abortController.signal.addEventListener(\"abort\", function() {\n                    return reject({\n                        name: \"AbortError\",\n                        message: abortReason || \"Aborted\"\n                    });\n                });\n            });\n            var started = false;\n            function abort(reason) {\n                if (started) {\n                    abortReason = reason;\n                    abortController.abort();\n                }\n            }\n            var promise = function() {\n                return __async(this, null, function() {\n                    var _a, _b, finalAction, conditionResult, err_1, skipDispatch;\n                    return __generator(this, function(_c) {\n                        switch(_c.label){\n                            case 0:\n                                _c.trys.push([\n                                    0,\n                                    4,\n                                    ,\n                                    5\n                                ]);\n                                conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, {\n                                    getState: getState,\n                                    extra: extra\n                                });\n                                if (!isThenable(conditionResult)) return [\n                                    3 /*break*/ ,\n                                    2\n                                ];\n                                return [\n                                    4 /*yield*/ ,\n                                    conditionResult\n                                ];\n                            case 1:\n                                conditionResult = _c.sent();\n                                _c.label = 2;\n                            case 2:\n                                if (conditionResult === false) {\n                                    throw {\n                                        name: \"ConditionError\",\n                                        message: \"Aborted due to condition callback returning false.\"\n                                    };\n                                }\n                                started = true;\n                                dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, {\n                                    requestId: requestId,\n                                    arg: arg\n                                }, {\n                                    getState: getState,\n                                    extra: extra\n                                })));\n                                return [\n                                    4 /*yield*/ ,\n                                    Promise.race([\n                                        abortedPromise,\n                                        Promise.resolve(payloadCreator(arg, {\n                                            dispatch: dispatch,\n                                            getState: getState,\n                                            extra: extra,\n                                            requestId: requestId,\n                                            signal: abortController.signal,\n                                            rejectWithValue: function(value, meta) {\n                                                return new RejectWithValue(value, meta);\n                                            },\n                                            fulfillWithValue: function(value, meta) {\n                                                return new FulfillWithMeta(value, meta);\n                                            }\n                                        })).then(function(result) {\n                                            if (result instanceof RejectWithValue) {\n                                                throw result;\n                                            }\n                                            if (result instanceof FulfillWithMeta) {\n                                                return fulfilled(result.payload, requestId, arg, result.meta);\n                                            }\n                                            return fulfilled(result, requestId, arg);\n                                        })\n                                    ])\n                                ];\n                            case 3:\n                                finalAction = _c.sent();\n                                return [\n                                    3 /*break*/ ,\n                                    5\n                                ];\n                            case 4:\n                                err_1 = _c.sent();\n                                finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);\n                                return [\n                                    3 /*break*/ ,\n                                    5\n                                ];\n                            case 5:\n                                skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n                                if (!skipDispatch) {\n                                    dispatch(finalAction);\n                                }\n                                return [\n                                    2 /*return*/ ,\n                                    finalAction\n                                ];\n                        }\n                    });\n                });\n            }();\n            return Object.assign(promise, {\n                abort: abort,\n                requestId: requestId,\n                arg: arg,\n                unwrap: function() {\n                    return promise.then(unwrapResult);\n                }\n            });\n        };\n    }\n    return Object.assign(actionCreator, {\n        pending: pending,\n        rejected: rejected,\n        fulfilled: fulfilled,\n        typePrefix: typePrefix\n    });\n}\nfunction unwrapResult(action) {\n    if (action.meta && action.meta.rejectedWithValue) {\n        throw action.payload;\n    }\n    if (action.error) {\n        throw action.error;\n    }\n    return action.payload;\n}\nfunction isThenable(value) {\n    return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n// src/tsHelpers.ts\nvar hasMatchFunction = function(v) {\n    return v && typeof v.match === \"function\";\n};\n// src/matchers.ts\nvar matches = function(matcher, action) {\n    if (hasMatchFunction(matcher)) {\n        return matcher.match(action);\n    } else {\n        return matcher(action);\n    }\n};\nfunction isAnyOf() {\n    var matchers = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        matchers[_i] = arguments[_i];\n    }\n    return function(action) {\n        return matchers.some(function(matcher) {\n            return matches(matcher, action);\n        });\n    };\n}\nfunction isAllOf() {\n    var matchers = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        matchers[_i] = arguments[_i];\n    }\n    return function(action) {\n        return matchers.every(function(matcher) {\n            return matches(matcher, action);\n        });\n    };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n    if (!action || !action.meta) return false;\n    var hasValidRequestId = typeof action.meta.requestId === \"string\";\n    var hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n    return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n    return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"pending\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isPending()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.pending;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejected() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"rejected\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejected()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.rejected;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejectedWithValue() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    var hasFlag = function(action) {\n        return action && action.meta && action.meta.rejectedWithValue;\n    };\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);\n            return combinedMatcher(action);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejectedWithValue()(asyncThunks[0]);\n    }\n    return function(action) {\n        var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);\n        return combinedMatcher(action);\n    };\n}\nfunction isFulfilled() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"fulfilled\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isFulfilled()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.fulfilled;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isAsyncThunkAction() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"pending\",\n                \"fulfilled\",\n                \"rejected\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isAsyncThunkAction()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = [];\n        for(var _i = 0, asyncThunks_1 = asyncThunks; _i < asyncThunks_1.length; _i++){\n            var asyncThunk = asyncThunks_1[_i];\n            matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);\n        }\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\n// src/listenerMiddleware/utils.ts\nvar assertFunction = function(func, expected) {\n    if (typeof func !== \"function\") {\n        throw new TypeError(expected + \" is not a function\");\n    }\n};\nvar noop = function() {};\nvar catchRejection = function(promise, onError) {\n    if (onError === void 0) {\n        onError = noop;\n    }\n    promise.catch(onError);\n    return promise;\n};\nvar addAbortSignalListener = function(abortSignal, callback) {\n    abortSignal.addEventListener(\"abort\", callback, {\n        once: true\n    });\n};\nvar abortControllerWithReason = function(abortController, reason) {\n    var signal = abortController.signal;\n    if (signal.aborted) {\n        return;\n    }\n    if (!(\"reason\" in signal)) {\n        Object.defineProperty(signal, \"reason\", {\n            enumerable: true,\n            value: reason,\n            configurable: true,\n            writable: true\n        });\n    }\n    ;\n    abortController.abort(reason);\n};\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = \"task-\" + cancelled;\nvar taskCompleted = \"task-\" + completed;\nvar listenerCancelled = listener + \"-\" + cancelled;\nvar listenerCompleted = listener + \"-\" + completed;\nvar TaskAbortError = /** @class */ function() {\n    function TaskAbortError(code) {\n        this.code = code;\n        this.name = \"TaskAbortError\";\n        this.message = task + \" \" + cancelled + \" (reason: \" + code + \")\";\n    }\n    return TaskAbortError;\n}();\n// src/listenerMiddleware/task.ts\nvar validateActive = function(signal) {\n    if (signal.aborted) {\n        throw new TaskAbortError(signal.reason);\n    }\n};\nvar promisifyAbortSignal = function(signal) {\n    return catchRejection(new Promise(function(_, reject) {\n        var notifyRejection = function() {\n            return reject(new TaskAbortError(signal.reason));\n        };\n        if (signal.aborted) {\n            notifyRejection();\n        } else {\n            addAbortSignalListener(signal, notifyRejection);\n        }\n    }));\n};\nvar runTask = function(task2, cleanUp) {\n    return __async(void 0, null, function() {\n        var value, error_1;\n        return __generator(this, function(_c) {\n            switch(_c.label){\n                case 0:\n                    _c.trys.push([\n                        0,\n                        3,\n                        4,\n                        5\n                    ]);\n                    return [\n                        4 /*yield*/ ,\n                        Promise.resolve()\n                    ];\n                case 1:\n                    _c.sent();\n                    return [\n                        4 /*yield*/ ,\n                        task2()\n                    ];\n                case 2:\n                    value = _c.sent();\n                    return [\n                        2 /*return*/ ,\n                        {\n                            status: \"ok\",\n                            value: value\n                        }\n                    ];\n                case 3:\n                    error_1 = _c.sent();\n                    return [\n                        2 /*return*/ ,\n                        {\n                            status: error_1 instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n                            error: error_1\n                        }\n                    ];\n                case 4:\n                    cleanUp == null ? void 0 : cleanUp();\n                    return [\n                        7 /*endfinally*/ \n                    ];\n                case 5:\n                    return [\n                        2 /*return*/ \n                    ];\n            }\n        });\n    });\n};\nvar createPause = function(signal) {\n    return function(promise) {\n        return catchRejection(Promise.race([\n            promisifyAbortSignal(signal),\n            promise\n        ]).then(function(output) {\n            validateActive(signal);\n            return output;\n        }));\n    };\n};\nvar createDelay = function(signal) {\n    var pause = createPause(signal);\n    return function(timeoutMs) {\n        return pause(new Promise(function(resolve) {\n            return setTimeout(resolve, timeoutMs);\n        }));\n    };\n};\n// src/listenerMiddleware/index.ts\nvar assign = Object.assign;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = function(parentAbortSignal) {\n    var linkControllers = function(controller) {\n        return addAbortSignalListener(parentAbortSignal, function() {\n            return abortControllerWithReason(controller, parentAbortSignal.reason);\n        });\n    };\n    return function(taskExecutor) {\n        assertFunction(taskExecutor, \"taskExecutor\");\n        var childAbortController = new AbortController();\n        linkControllers(childAbortController);\n        var result = runTask(function() {\n            return __async(void 0, null, function() {\n                var result2;\n                return __generator(this, function(_c) {\n                    switch(_c.label){\n                        case 0:\n                            validateActive(parentAbortSignal);\n                            validateActive(childAbortController.signal);\n                            return [\n                                4 /*yield*/ ,\n                                taskExecutor({\n                                    pause: createPause(childAbortController.signal),\n                                    delay: createDelay(childAbortController.signal),\n                                    signal: childAbortController.signal\n                                })\n                            ];\n                        case 1:\n                            result2 = _c.sent();\n                            validateActive(childAbortController.signal);\n                            return [\n                                2 /*return*/ ,\n                                result2\n                            ];\n                    }\n                });\n            });\n        }, function() {\n            return abortControllerWithReason(childAbortController, taskCompleted);\n        });\n        return {\n            result: createPause(parentAbortSignal)(result),\n            cancel: function() {\n                abortControllerWithReason(childAbortController, taskCancelled);\n            }\n        };\n    };\n};\nvar createTakePattern = function(startListening, signal) {\n    var take = function(predicate, timeout) {\n        return __async(void 0, null, function() {\n            var unsubscribe, tuplePromise, promises, output;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        validateActive(signal);\n                        unsubscribe = function() {};\n                        tuplePromise = new Promise(function(resolve) {\n                            unsubscribe = startListening({\n                                predicate: predicate,\n                                effect: function(action, listenerApi) {\n                                    listenerApi.unsubscribe();\n                                    resolve([\n                                        action,\n                                        listenerApi.getState(),\n                                        listenerApi.getOriginalState()\n                                    ]);\n                                }\n                            });\n                        });\n                        promises = [\n                            promisifyAbortSignal(signal),\n                            tuplePromise\n                        ];\n                        if (timeout != null) {\n                            promises.push(new Promise(function(resolve) {\n                                return setTimeout(resolve, timeout, null);\n                            }));\n                        }\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([\n                            1,\n                            ,\n                            3,\n                            4\n                        ]);\n                        return [\n                            4 /*yield*/ ,\n                            Promise.race(promises)\n                        ];\n                    case 2:\n                        output = _c.sent();\n                        validateActive(signal);\n                        return [\n                            2 /*return*/ ,\n                            output\n                        ];\n                    case 3:\n                        unsubscribe();\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 4:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return function(predicate, timeout) {\n        return catchRejection(take(predicate, timeout));\n    };\n};\nvar getListenerEntryPropsFrom = function(options) {\n    var type = options.type, actionCreator = options.actionCreator, matcher = options.matcher, predicate = options.predicate, effect = options.effect;\n    if (type) {\n        predicate = createAction(type).match;\n    } else if (actionCreator) {\n        type = actionCreator.type;\n        predicate = actionCreator.match;\n    } else if (matcher) {\n        predicate = matcher;\n    } else if (predicate) {} else {\n        throw new Error(\"Creating or removing a listener requires one of the known fields for matching an action\");\n    }\n    assertFunction(effect, \"options.listener\");\n    return {\n        predicate: predicate,\n        type: type,\n        effect: effect\n    };\n};\nvar createListenerEntry = function(options) {\n    var _c = getListenerEntryPropsFrom(options), type = _c.type, predicate = _c.predicate, effect = _c.effect;\n    var id = nanoid();\n    var entry = {\n        id: id,\n        effect: effect,\n        type: type,\n        predicate: predicate,\n        pending: new Set(),\n        unsubscribe: function() {\n            throw new Error(\"Unsubscribe not initialized\");\n        }\n    };\n    return entry;\n};\nvar createClearListenerMiddleware = function(listenerMap) {\n    return function() {\n        listenerMap.forEach(cancelActiveListeners);\n        listenerMap.clear();\n    };\n};\nvar safelyNotifyError = function(errorHandler, errorToNotify, errorInfo) {\n    try {\n        errorHandler(errorToNotify, errorInfo);\n    } catch (errorHandlerError) {\n        setTimeout(function() {\n            throw errorHandlerError;\n        }, 0);\n    }\n};\nvar addListener = createAction(alm + \"/add\");\nvar clearAllListeners = createAction(alm + \"/removeAll\");\nvar removeListener = createAction(alm + \"/remove\");\nvar defaultErrorHandler = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    console.error.apply(console, __spreadArray([\n        alm + \"/error\"\n    ], args));\n};\nvar cancelActiveListeners = function(entry) {\n    entry.pending.forEach(function(controller) {\n        abortControllerWithReason(controller, listenerCancelled);\n    });\n};\nfunction createListenerMiddleware(middlewareOptions) {\n    var _this = this;\n    if (middlewareOptions === void 0) {\n        middlewareOptions = {};\n    }\n    var listenerMap = new Map();\n    var extra = middlewareOptions.extra, _c = middlewareOptions.onError, onError = _c === void 0 ? defaultErrorHandler : _c;\n    assertFunction(onError, \"onError\");\n    var insertEntry = function(entry) {\n        entry.unsubscribe = function() {\n            return listenerMap.delete(entry.id);\n        };\n        listenerMap.set(entry.id, entry);\n        return function(cancelOptions) {\n            entry.unsubscribe();\n            if (cancelOptions == null ? void 0 : cancelOptions.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        };\n    };\n    var findListenerEntry = function(comparator) {\n        for(var _i = 0, _c = Array.from(listenerMap.values()); _i < _c.length; _i++){\n            var entry = _c[_i];\n            if (comparator(entry)) {\n                return entry;\n            }\n        }\n        return void 0;\n    };\n    var startListening = function(options) {\n        var entry = findListenerEntry(function(existingEntry) {\n            return existingEntry.effect === options.effect;\n        });\n        if (!entry) {\n            entry = createListenerEntry(options);\n        }\n        return insertEntry(entry);\n    };\n    var stopListening = function(options) {\n        var _c = getListenerEntryPropsFrom(options), type = _c.type, effect = _c.effect, predicate = _c.predicate;\n        var entry = findListenerEntry(function(entry2) {\n            var matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\n            return matchPredicateOrType && entry2.effect === effect;\n        });\n        if (entry) {\n            entry.unsubscribe();\n            if (options.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        }\n        return !!entry;\n    };\n    var notifyListener = function(entry, action, api, getOriginalState) {\n        return __async(_this, null, function() {\n            var internalTaskController, take, listenerError_1;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        internalTaskController = new AbortController();\n                        take = createTakePattern(startListening, internalTaskController.signal);\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([\n                            1,\n                            3,\n                            4,\n                            5\n                        ]);\n                        entry.pending.add(internalTaskController);\n                        return [\n                            4 /*yield*/ ,\n                            Promise.resolve(entry.effect(action, assign({}, api, {\n                                getOriginalState: getOriginalState,\n                                condition: function(predicate, timeout) {\n                                    return take(predicate, timeout).then(Boolean);\n                                },\n                                take: take,\n                                delay: createDelay(internalTaskController.signal),\n                                pause: createPause(internalTaskController.signal),\n                                extra: extra,\n                                signal: internalTaskController.signal,\n                                fork: createFork(internalTaskController.signal),\n                                unsubscribe: entry.unsubscribe,\n                                subscribe: function() {\n                                    listenerMap.set(entry.id, entry);\n                                },\n                                cancelActiveListeners: function() {\n                                    entry.pending.forEach(function(controller, _, set) {\n                                        if (controller !== internalTaskController) {\n                                            abortControllerWithReason(controller, listenerCancelled);\n                                            set.delete(controller);\n                                        }\n                                    });\n                                }\n                            })))\n                        ];\n                    case 2:\n                        _c.sent();\n                        return [\n                            3 /*break*/ ,\n                            5\n                        ];\n                    case 3:\n                        listenerError_1 = _c.sent();\n                        if (!(listenerError_1 instanceof TaskAbortError)) {\n                            safelyNotifyError(onError, listenerError_1, {\n                                raisedBy: \"effect\"\n                            });\n                        }\n                        return [\n                            3 /*break*/ ,\n                            5\n                        ];\n                    case 4:\n                        abortControllerWithReason(internalTaskController, listenerCompleted);\n                        entry.pending.delete(internalTaskController);\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 5:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    var clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n    var middleware = function(api) {\n        return function(next) {\n            return function(action) {\n                if (addListener.match(action)) {\n                    return startListening(action.payload);\n                }\n                if (clearAllListeners.match(action)) {\n                    clearListenerMiddleware();\n                    return;\n                }\n                if (removeListener.match(action)) {\n                    return stopListening(action.payload);\n                }\n                var originalState = api.getState();\n                var getOriginalState = function() {\n                    if (originalState === INTERNAL_NIL_TOKEN) {\n                        throw new Error(alm + \": getOriginalState can only be called synchronously\");\n                    }\n                    return originalState;\n                };\n                var result;\n                try {\n                    result = next(action);\n                    if (listenerMap.size > 0) {\n                        var currentState = api.getState();\n                        var listenerEntries = Array.from(listenerMap.values());\n                        for(var _i = 0, listenerEntries_1 = listenerEntries; _i < listenerEntries_1.length; _i++){\n                            var entry = listenerEntries_1[_i];\n                            var runListener = false;\n                            try {\n                                runListener = entry.predicate(action, currentState, originalState);\n                            } catch (predicateError) {\n                                runListener = false;\n                                safelyNotifyError(onError, predicateError, {\n                                    raisedBy: \"predicate\"\n                                });\n                            }\n                            if (!runListener) {\n                                continue;\n                            }\n                            notifyListener(entry, action, api, getOriginalState);\n                        }\n                    }\n                } finally{\n                    originalState = INTERNAL_NIL_TOKEN;\n                }\n                return result;\n            };\n        };\n    };\n    return {\n        middleware: middleware,\n        startListening: startListening,\n        stopListening: stopListening,\n        clearListeners: clearListenerMiddleware\n    };\n}\n// src/index.ts\n(0,immer__WEBPACK_IMPORTED_MODULE_2__.enableES5)();\n //# sourceMappingURL=redux-toolkit.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVksU0FBSyxJQUFJLFNBQUksQ0FBQ0EsU0FBUyxJQUFLO0lBQ3hDLElBQUlDLGdCQUFnQixTQUFVQyxDQUFDLEVBQUVDLENBQUM7UUFDOUJGLGdCQUFnQkcsT0FBT0MsY0FBYyxJQUNoQztZQUFFQyxXQUFXLEVBQUU7UUFBQyxjQUFhQyxTQUFTLFNBQVVMLENBQUMsRUFBRUMsQ0FBQztZQUFJRCxFQUFFSSxTQUFTLEdBQUdIO1FBQUcsS0FDMUUsU0FBVUQsQ0FBQyxFQUFFQyxDQUFDO1lBQUksSUFBSyxJQUFJSyxLQUFLTCxFQUFHLElBQUlDLE9BQU9LLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEdBQUdLLElBQUlOLENBQUMsQ0FBQ00sRUFBRSxHQUFHTCxDQUFDLENBQUNLLEVBQUU7UUFBRTtRQUNwRyxPQUFPUCxjQUFjQyxHQUFHQztJQUM1QjtJQUNBLE9BQU8sU0FBVUQsQ0FBQyxFQUFFQyxDQUFDO1FBQ2pCLElBQUksT0FBT0EsTUFBTSxjQUFjQSxNQUFNLE1BQ2pDLE1BQU0sSUFBSVMsVUFBVSx5QkFBeUJDLE9BQU9WLEtBQUs7UUFDN0RGLGNBQWNDLEdBQUdDO1FBQ2pCLFNBQVNXO1lBQU8sSUFBSSxDQUFDQyxXQUFXLEdBQUdiO1FBQUc7UUFDdENBLEVBQUVPLFNBQVMsR0FBR04sTUFBTSxPQUFPQyxPQUFPWSxNQUFNLENBQUNiLEtBQU1XLENBQUFBLEdBQUdMLFNBQVMsR0FBR04sRUFBRU0sU0FBUyxFQUFFLElBQUlLLElBQUc7SUFDdEY7QUFDSjtBQUNBLElBQUlHLGNBQWMsU0FBSyxJQUFJLFNBQUksQ0FBQ0EsV0FBVyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsSUFBSTtJQUNuRSxJ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SUFBRztJQUNOLE9BQU87UUFDSHlELFlBQVlBO1FBQ1pnUyxnQkFBZ0JBO1FBQ2hCc0MsZUFBZUE7UUFDZm1CLGdCQUFnQlA7SUFDcEI7QUFDSjtBQUNBLGVBQWU7QUFDZjVlLGdEQUFTQTtBQUNxcUIsQ0FDOXFCLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL211bHRpdmVyc3gtZGFwcC8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvcmVkdXgtdG9vbGtpdC5lc20uanM/OGNjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59O1xyXG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcclxuICAgICAgICB0b1tqXSA9IGZyb21baV07XHJcbiAgICByZXR1cm4gdG87XHJcbn07XHJcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XHJcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XHJcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xyXG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XHJcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcclxudmFyIF9fZGVmTm9ybWFsUHJvcCA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTsgfTtcclxudmFyIF9fc3ByZWFkVmFsdWVzID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcclxuICAgICAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXHJcbiAgICAgICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcclxuICAgIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2MgPSBfX2dldE93blByb3BTeW1ib2xzKGIpOyBfaSA8IF9jLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcHJvcCA9IF9jW19pXTtcclxuICAgICAgICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxyXG4gICAgICAgICAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiBhO1xyXG59O1xyXG52YXIgX19zcHJlYWRQcm9wcyA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTsgfTtcclxudmFyIF9fYXN5bmMgPSBmdW5jdGlvbiAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHZhciBmdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9O1xyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG4vLyBzcmMvaW5kZXgudHNcclxuaW1wb3J0IHsgZW5hYmxlRVM1IH0gZnJvbSBcImltbWVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCJyZWR1eFwiO1xyXG5pbXBvcnQgeyBkZWZhdWx0IGFzIGRlZmF1bHQyLCBjdXJyZW50IGFzIGN1cnJlbnQyLCBmcmVlemUsIG9yaWdpbmFsLCBpc0RyYWZ0IGFzIGlzRHJhZnQ0IH0gZnJvbSBcImltbWVyXCI7XHJcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIGFzIGNyZWF0ZVNlbGVjdG9yMiB9IGZyb20gXCJyZXNlbGVjdFwiO1xyXG4vLyBzcmMvY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IudHNcclxuaW1wb3J0IHsgY3VycmVudCwgaXNEcmFmdCB9IGZyb20gXCJpbW1lclwiO1xyXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvciB9IGZyb20gXCJyZXNlbGVjdFwiO1xyXG52YXIgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICB2YXIgc2VsZWN0b3IgPSBjcmVhdGVTZWxlY3Rvci5hcHBseSh2b2lkIDAsIGFyZ3MpO1xyXG4gICAgdmFyIHdyYXBwZWRTZWxlY3RvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciByZXN0ID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgcmVzdFtfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbaXNEcmFmdCh2YWx1ZSkgPyBjdXJyZW50KHZhbHVlKSA6IHZhbHVlXSwgcmVzdCkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB3cmFwcGVkU2VsZWN0b3I7XHJcbn07XHJcbi8vIHNyYy9jb25maWd1cmVTdG9yZS50c1xyXG5pbXBvcnQgeyBjcmVhdGVTdG9yZSwgY29tcG9zZSBhcyBjb21wb3NlMiwgYXBwbHlNaWRkbGV3YXJlLCBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcclxuLy8gc3JjL2RldnRvb2xzRXh0ZW5zaW9uLnRzXHJcbmltcG9ydCB7IGNvbXBvc2UgfSBmcm9tIFwicmVkdXhcIjtcclxudmFyIGNvbXBvc2VXaXRoRGV2VG9vbHMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIDogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcIm9iamVjdFwiKVxyXG4gICAgICAgIHJldHVybiBjb21wb3NlO1xyXG4gICAgcmV0dXJuIGNvbXBvc2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxufTtcclxudmFyIGRldlRvb2xzRW5oYW5jZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vb3AyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vb3AyO1xyXG4gICAgfTtcclxufTtcclxuLy8gc3JjL2lzUGxhaW5PYmplY3QudHNcclxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xyXG4gICAgaWYgKHByb3RvID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgdmFyIGJhc2VQcm90byA9IHByb3RvO1xyXG4gICAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlUHJvdG8pICE9PSBudWxsKSB7XHJcbiAgICAgICAgYmFzZVByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90byk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvdG8gPT09IGJhc2VQcm90bztcclxufVxyXG4vLyBzcmMvZ2V0RGVmYXVsdE1pZGRsZXdhcmUudHNcclxuaW1wb3J0IHRodW5rTWlkZGxld2FyZSBmcm9tIFwicmVkdXgtdGh1bmtcIjtcclxuLy8gc3JjL3V0aWxzLnRzXHJcbmZ1bmN0aW9uIGdldFRpbWVNZWFzdXJlVXRpbHMobWF4RGVsYXksIGZuTmFtZSkge1xyXG4gICAgdmFyIGVsYXBzZWQgPSAwO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtZWFzdXJlVGltZTogZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydGVkID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVkID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIGVsYXBzZWQgKz0gZmluaXNoZWQgLSBzdGFydGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB3YXJuSWZFeGNlZWRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoZWxhcHNlZCA+IG1heERlbGF5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZm5OYW1lICsgXCIgdG9vayBcIiArIGVsYXBzZWQgKyBcIm1zLCB3aGljaCBpcyBtb3JlIHRoYW4gdGhlIHdhcm5pbmcgdGhyZXNob2xkIG9mIFwiICsgbWF4RGVsYXkgKyBcIm1zLiBcXG5JZiB5b3VyIHN0YXRlIG9yIGFjdGlvbnMgYXJlIHZlcnkgbGFyZ2UsIHlvdSBtYXkgd2FudCB0byBkaXNhYmxlIHRoZSBtaWRkbGV3YXJlIGFzIGl0IG1pZ2h0IGNhdXNlIHRvbyBtdWNoIG9mIGEgc2xvd2Rvd24gaW4gZGV2ZWxvcG1lbnQgbW9kZS4gU2VlIGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2dldERlZmF1bHRNaWRkbGV3YXJlIGZvciBpbnN0cnVjdGlvbnMuXFxuSXQgaXMgZGlzYWJsZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMsIHNvIHlvdSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoYXQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG52YXIgTWlkZGxld2FyZUFycmF5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1pZGRsZXdhcmVBcnJheSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1pZGRsZXdhcmVBcnJheSgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3MpIHx8IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBNaWRkbGV3YXJlQXJyYXkucHJvdG90eXBlKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWlkZGxld2FyZUFycmF5LCBTeW1ib2wuc3BlY2llcywge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWlkZGxld2FyZUFycmF5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1pZGRsZXdhcmVBcnJheS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcnIgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcnJbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY29uY2F0LmFwcGx5KHRoaXMsIGFycik7XHJcbiAgICB9O1xyXG4gICAgTWlkZGxld2FyZUFycmF5LnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcnIgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcnJbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFyci5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcnJbMF0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgKE1pZGRsZXdhcmVBcnJheS5iaW5kLmFwcGx5KE1pZGRsZXdhcmVBcnJheSwgX19zcHJlYWRBcnJheShbdm9pZCAwXSwgYXJyWzBdLmNvbmNhdCh0aGlzKSkpKSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IChNaWRkbGV3YXJlQXJyYXkuYmluZC5hcHBseShNaWRkbGV3YXJlQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyci5jb25jYXQodGhpcykpKSkoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTWlkZGxld2FyZUFycmF5O1xyXG59KEFycmF5KSk7XHJcbi8vIHNyYy9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcclxudmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcclxudmFyIHByZWZpeCA9IFwiSW52YXJpYW50IGZhaWxlZFwiO1xyXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoY29uZGl0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXgpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArIFwiOiBcIiArIChtZXNzYWdlIHx8IFwiXCIpKTtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqLCBzZXJpYWxpemVyLCBpbmRlbnQsIGRlY3ljbGVyKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBnZXRTZXJpYWxpemUoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNlcmlhbGl6ZShzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xyXG4gICAgdmFyIHN0YWNrID0gW10sIGtleXMgPSBbXTtcclxuICAgIGlmICghZGVjeWNsZXIpXHJcbiAgICAgICAgZGVjeWNsZXIgPSBmdW5jdGlvbiAoXywgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIltDaXJjdWxhciB+XVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfi5cIiArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oXCIuXCIpICsgXCJdXCI7XHJcbiAgICAgICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcclxuICAgICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcclxuICAgICAgICAgICAgfnRoaXNQb3MgPyBrZXlzLnNwbGljZSh0aGlzUG9zLCBJbmZpbml0eSwga2V5KSA6IGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWN5Y2xlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyID09IG51bGwgPyB2YWx1ZSA6IHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBPYmplY3QuaXNGcm96ZW4odmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHRyYWNrRm9yTXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKSB7XHJcbiAgICB2YXIgdHJhY2tlZFByb3BlcnRpZXMgPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkZXRlY3RNdXRhdGlvbnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIHRyYWNrZWRQcm9wZXJ0aWVzLCBvYmopO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqLCBwYXRoKSB7XHJcbiAgICBpZiAoaWdub3JlUGF0aHMgPT09IHZvaWQgMCkgeyBpZ25vcmVQYXRocyA9IFtdOyB9XHJcbiAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBcIlwiOyB9XHJcbiAgICB2YXIgdHJhY2tlZCA9IHsgdmFsdWU6IG9iaiB9O1xyXG4gICAgaWYgKCFpc0ltbXV0YWJsZShvYmopKSB7XHJcbiAgICAgICAgdHJhY2tlZC5jaGlsZHJlbiA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XHJcbiAgICAgICAgICAgIGlmIChpZ25vcmVQYXRocy5sZW5ndGggJiYgaWdub3JlUGF0aHMuaW5kZXhPZihjaGlsZFBhdGgpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJhY2tlZC5jaGlsZHJlbltrZXldID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqW2tleV0sIGNoaWxkUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRyYWNrZWQ7XHJcbn1cclxuZnVuY3Rpb24gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgdHJhY2tlZFByb3BlcnR5LCBvYmosIHNhbWVQYXJlbnRSZWYsIHBhdGgpIHtcclxuICAgIGlmIChpZ25vcmVQYXRocyA9PT0gdm9pZCAwKSB7IGlnbm9yZVBhdGhzID0gW107IH1cclxuICAgIGlmIChzYW1lUGFyZW50UmVmID09PSB2b2lkIDApIHsgc2FtZVBhcmVudFJlZiA9IGZhbHNlOyB9XHJcbiAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBcIlwiOyB9XHJcbiAgICB2YXIgcHJldk9iaiA9IHRyYWNrZWRQcm9wZXJ0eSA/IHRyYWNrZWRQcm9wZXJ0eS52YWx1ZSA6IHZvaWQgMDtcclxuICAgIHZhciBzYW1lUmVmID0gcHJldk9iaiA9PT0gb2JqO1xyXG4gICAgaWYgKHNhbWVQYXJlbnRSZWYgJiYgIXNhbWVSZWYgJiYgIU51bWJlci5pc05hTihvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2FzTXV0YXRlZDogdHJ1ZSwgcGF0aDogcGF0aCB9O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzSW1tdXRhYmxlKHByZXZPYmopIHx8IGlzSW1tdXRhYmxlKG9iaikpIHtcclxuICAgICAgICByZXR1cm4geyB3YXNNdXRhdGVkOiBmYWxzZSB9O1xyXG4gICAgfVxyXG4gICAgdmFyIGtleXNUb0RldGVjdCA9IHt9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbikge1xyXG4gICAgICAgIGtleXNUb0RldGVjdFtrZXldID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgICAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4ga2V5c1RvRGV0ZWN0KSB7XHJcbiAgICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XHJcbiAgICAgICAgaWYgKGlnbm9yZVBhdGhzLmxlbmd0aCAmJiBpZ25vcmVQYXRocy5pbmRleE9mKGNoaWxkUGF0aCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgdHJhY2tlZFByb3BlcnR5LmNoaWxkcmVuW2tleV0sIG9ialtrZXldLCBzYW1lUmVmLCBjaGlsZFBhdGgpO1xyXG4gICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7IHdhc011dGF0ZWQ6IGZhbHNlIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBuZXh0KGFjdGlvbik7IH07IH07IH07XHJcbiAgICB9XHJcbiAgICB2YXIgX2MgPSBvcHRpb25zLmlzSW1tdXRhYmxlLCBpc0ltbXV0YWJsZSA9IF9jID09PSB2b2lkIDAgPyBpc0ltbXV0YWJsZURlZmF1bHQgOiBfYywgaWdub3JlZFBhdGhzID0gb3B0aW9ucy5pZ25vcmVkUGF0aHMsIF9kID0gb3B0aW9ucy53YXJuQWZ0ZXIsIHdhcm5BZnRlciA9IF9kID09PSB2b2lkIDAgPyAzMiA6IF9kLCBpZ25vcmUgPSBvcHRpb25zLmlnbm9yZTtcclxuICAgIGlnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocyB8fCBpZ25vcmU7XHJcbiAgICB2YXIgdHJhY2sgPSB0cmFja0Zvck11dGF0aW9ucy5iaW5kKG51bGwsIGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMpO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgIHZhciBnZXRTdGF0ZSA9IF9jLmdldFN0YXRlO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICAgICAgdmFyIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIG1lYXN1cmVVdGlscyA9IGdldFRpbWVNZWFzdXJlVXRpbHMod2FybkFmdGVyLCBcIkltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZVwiKTtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlID0gZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyYWNrZXIuZGV0ZWN0TXV0YXRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgaW52YXJpYW50KCFyZXN1bHQud2FzTXV0YXRlZCwgXCJBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBiZXR3ZWVuIGRpc3BhdGNoZXMsIGluIHRoZSBwYXRoICdcIiArIChyZXN1bHQucGF0aCB8fCBcIlwiKSArIFwiJy4gIFRoaXMgbWF5IGNhdXNlIGluY29ycmVjdCBiZWhhdmlvci4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpXCIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGRpc3BhdGNoZWRBY3Rpb24gPSBuZXh0KGFjdGlvbik7XHJcbiAgICAgICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC53YXNNdXRhdGVkICYmIGludmFyaWFudCghcmVzdWx0Lndhc011dGF0ZWQsIFwiQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgaW5zaWRlIGEgZGlzcGF0Y2gsIGluIHRoZSBwYXRoOiBcIiArIChyZXN1bHQucGF0aCB8fCBcIlwiKSArIFwiLiBUYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGUgYWN0aW9uIFwiICsgc3RyaW5naWZ5KGFjdGlvbikgKyBcIi4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpXCIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaGVkQWN0aW9uO1xyXG4gICAgICAgIH07IH07XHJcbiAgICB9O1xyXG59XHJcbi8vIHNyYy9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcclxuZnVuY3Rpb24gaXNQbGFpbih2YWwpIHtcclxuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcclxuICAgIHJldHVybiB0eXBlID09PSBcInVuZGVmaW5lZFwiIHx8IHZhbCA9PT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWwpIHx8IGlzUGxhaW5PYmplY3QodmFsKTtcclxufVxyXG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGgsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMpIHtcclxuICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IFwiXCI7IH1cclxuICAgIGlmIChpc1NlcmlhbGl6YWJsZSA9PT0gdm9pZCAwKSB7IGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbjsgfVxyXG4gICAgaWYgKGlnbm9yZWRQYXRocyA9PT0gdm9pZCAwKSB7IGlnbm9yZWRQYXRocyA9IFtdOyB9XHJcbiAgICB2YXIgZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XHJcbiAgICBpZiAoIWlzU2VyaWFsaXphYmxlKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGtleVBhdGg6IHBhdGggfHwgXCI8cm9vdD5cIixcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpO1xyXG4gICAgdmFyIGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBlbnRyaWVzXzEgPSBlbnRyaWVzOyBfaSA8IGVudHJpZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgX2MgPSBlbnRyaWVzXzFbX2ldLCBrZXkgPSBfY1swXSwgbmVzdGVkVmFsdWUgPSBfY1sxXTtcclxuICAgICAgICB2YXIgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XHJcbiAgICAgICAgaWYgKGhhc0lnbm9yZWRQYXRocyAmJiBpZ25vcmVkUGF0aHMuaW5kZXhPZihuZXN0ZWRQYXRoKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzU2VyaWFsaXphYmxlKG5lc3RlZFZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAga2V5UGF0aDogbmVzdGVkUGF0aCxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5lc3RlZFZhbHVlLCBuZXN0ZWRQYXRoLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzKTtcclxuICAgICAgICAgICAgaWYgKGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBuZXh0KGFjdGlvbik7IH07IH07IH07XHJcbiAgICB9XHJcbiAgICB2YXIgX2MgPSBvcHRpb25zLmlzU2VyaWFsaXphYmxlLCBpc1NlcmlhbGl6YWJsZSA9IF9jID09PSB2b2lkIDAgPyBpc1BsYWluIDogX2MsIGdldEVudHJpZXMgPSBvcHRpb25zLmdldEVudHJpZXMsIF9kID0gb3B0aW9ucy5pZ25vcmVkQWN0aW9ucywgaWdub3JlZEFjdGlvbnMgPSBfZCA9PT0gdm9pZCAwID8gW10gOiBfZCwgX2UgPSBvcHRpb25zLmlnbm9yZWRBY3Rpb25QYXRocywgaWdub3JlZEFjdGlvblBhdGhzID0gX2UgPT09IHZvaWQgMCA/IFtcIm1ldGEuYXJnXCIsIFwibWV0YS5iYXNlUXVlcnlNZXRhXCJdIDogX2UsIF9mID0gb3B0aW9ucy5pZ25vcmVkUGF0aHMsIGlnbm9yZWRQYXRocyA9IF9mID09PSB2b2lkIDAgPyBbXSA6IF9mLCBfZyA9IG9wdGlvbnMud2FybkFmdGVyLCB3YXJuQWZ0ZXIgPSBfZyA9PT0gdm9pZCAwID8gMzIgOiBfZywgX2ggPSBvcHRpb25zLmlnbm9yZVN0YXRlLCBpZ25vcmVTdGF0ZSA9IF9oID09PSB2b2lkIDAgPyBmYWxzZSA6IF9oLCBfaiA9IG9wdGlvbnMuaWdub3JlQWN0aW9ucywgaWdub3JlQWN0aW9ucyA9IF9qID09PSB2b2lkIDAgPyBmYWxzZSA6IF9qO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZUFQSSkgeyByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xyXG4gICAgICAgIHZhciBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XHJcbiAgICAgICAgaWYgKCFpZ25vcmVBY3Rpb25zICYmICEoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoYWN0aW9uLnR5cGUpICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0gZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZS5rZXlQYXRoLCB2YWx1ZSA9IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gYW4gYWN0aW9uLCBpbiB0aGUgcGF0aDogYFwiICsga2V5UGF0aCArIFwiYC4gVmFsdWU6XCIsIHZhbHVlLCBcIlxcblRha2UgYSBsb29rIGF0IHRoZSBsb2dpYyB0aGF0IGRpc3BhdGNoZWQgdGhpcyBhY3Rpb246IFwiLCBhY3Rpb24sIFwiXFxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvYWN0aW9ucyN3aHktc2hvdWxkLXR5cGUtYmUtYS1zdHJpbmctb3ItYXQtbGVhc3Qtc2VyaWFsaXphYmxlLXdoeS1zaG91bGQtbXktYWN0aW9uLXR5cGVzLWJlLWNvbnN0YW50cylcIiwgXCJcXG4oVG8gYWxsb3cgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZXMgc2VlOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL3VzYWdlL3VzYWdlLWd1aWRlI3dvcmtpbmctd2l0aC1ub24tc2VyaWFsaXphYmxlLWRhdGEpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpZ25vcmVTdGF0ZSkge1xyXG4gICAgICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gc3RvcmVBUEkuZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoc3RhdGUsIFwiXCIsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0gZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlLmtleVBhdGgsIHZhbHVlID0gZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgd2FzIGRldGVjdGVkIGluIHRoZSBzdGF0ZSwgaW4gdGhlIHBhdGg6IGBcIiArIGtleVBhdGggKyBcImAuIFZhbHVlOlwiLCB2YWx1ZSwgXCJcXG5UYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGlzIGFjdGlvbiB0eXBlOiBcIiArIGFjdGlvbi50eXBlICsgXCIuXFxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvb3JnYW5pemluZy1zdGF0ZSNjYW4taS1wdXQtZnVuY3Rpb25zLXByb21pc2VzLW9yLW90aGVyLW5vbi1zZXJpYWxpemFibGUtaXRlbXMtaW4tbXktc3RvcmUtc3RhdGUpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9OyB9OyB9O1xyXG59XHJcbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xyXG5mdW5jdGlvbiBpc0Jvb2xlYW4oeCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImJvb2xlYW5cIjtcclxufVxyXG5mdW5jdGlvbiBjdXJyeUdldERlZmF1bHRNaWRkbGV3YXJlKCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXREZWZhdWx0TWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgdmFyIF9jID0gb3B0aW9ucy50aHVuaywgdGh1bmsgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBfZCA9IG9wdGlvbnMuaW1tdXRhYmxlQ2hlY2ssIGltbXV0YWJsZUNoZWNrID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZCwgX2UgPSBvcHRpb25zLnNlcmlhbGl6YWJsZUNoZWNrLCBzZXJpYWxpemFibGVDaGVjayA9IF9lID09PSB2b2lkIDAgPyB0cnVlIDogX2U7XHJcbiAgICB2YXIgbWlkZGxld2FyZUFycmF5ID0gbmV3IE1pZGRsZXdhcmVBcnJheSgpO1xyXG4gICAgaWYgKHRodW5rKSB7XHJcbiAgICAgICAgaWYgKGlzQm9vbGVhbih0aHVuaykpIHtcclxuICAgICAgICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2godGh1bmtNaWRkbGV3YXJlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKHRodW5rTWlkZGxld2FyZS53aXRoRXh0cmFBcmd1bWVudCh0aHVuay5leHRyYUFyZ3VtZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIGlmIChpbW11dGFibGVDaGVjaykge1xyXG4gICAgICAgICAgICB2YXIgaW1tdXRhYmxlT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoIWlzQm9vbGVhbihpbW11dGFibGVDaGVjaykpIHtcclxuICAgICAgICAgICAgICAgIGltbXV0YWJsZU9wdGlvbnMgPSBpbW11dGFibGVDaGVjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoaW1tdXRhYmxlT3B0aW9ucykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2VyaWFsaXphYmxlQ2hlY2spIHtcclxuICAgICAgICAgICAgdmFyIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgaWYgKCFpc0Jvb2xlYW4oc2VyaWFsaXphYmxlQ2hlY2spKSB7XHJcbiAgICAgICAgICAgICAgICBzZXJpYWxpemFibGVPcHRpb25zID0gc2VyaWFsaXphYmxlQ2hlY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2goY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKHNlcmlhbGl6YWJsZU9wdGlvbnMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWlkZGxld2FyZUFycmF5O1xyXG59XHJcbi8vIHNyYy9jb25maWd1cmVTdG9yZS50c1xyXG52YXIgSVNfUFJPRFVDVElPTiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcclxuZnVuY3Rpb24gY29uZmlndXJlU3RvcmUob3B0aW9ucykge1xyXG4gICAgdmFyIGN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZSA9IGN1cnJ5R2V0RGVmYXVsdE1pZGRsZXdhcmUoKTtcclxuICAgIHZhciBfYyA9IG9wdGlvbnMgfHwge30sIF9kID0gX2MucmVkdWNlciwgcmVkdWNlciA9IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZCwgX2UgPSBfYy5taWRkbGV3YXJlLCBtaWRkbGV3YXJlID0gX2UgPT09IHZvaWQgMCA/IGN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZSgpIDogX2UsIF9mID0gX2MuZGV2VG9vbHMsIGRldlRvb2xzID0gX2YgPT09IHZvaWQgMCA/IHRydWUgOiBfZiwgX2cgPSBfYy5wcmVsb2FkZWRTdGF0ZSwgcHJlbG9hZGVkU3RhdGUgPSBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2csIF9oID0gX2MuZW5oYW5jZXJzLCBlbmhhbmNlcnMgPSBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2g7XHJcbiAgICB2YXIgcm9vdFJlZHVjZXI7XHJcbiAgICBpZiAodHlwZW9mIHJlZHVjZXIgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHJvb3RSZWR1Y2VyID0gcmVkdWNlcjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocmVkdWNlcikpIHtcclxuICAgICAgICByb290UmVkdWNlciA9IGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2VyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJyZWR1Y2VyXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudCwgYW5kIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgb2YgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBjb21iaW5lUmVkdWNlcnMnKTtcclxuICAgIH1cclxuICAgIHZhciBmaW5hbE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlO1xyXG4gICAgaWYgKHR5cGVvZiBmaW5hbE1pZGRsZXdhcmUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIGZpbmFsTWlkZGxld2FyZSA9IGZpbmFsTWlkZGxld2FyZShjdXJyaWVkR2V0RGVmYXVsdE1pZGRsZXdhcmUpO1xyXG4gICAgICAgIGlmICghSVNfUFJPRFVDVElPTiAmJiAhQXJyYXkuaXNBcnJheShmaW5hbE1pZGRsZXdhcmUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIndoZW4gdXNpbmcgYSBtaWRkbGV3YXJlIGJ1aWxkZXIgZnVuY3Rpb24sIGFuIGFycmF5IG9mIG1pZGRsZXdhcmUgbXVzdCBiZSByZXR1cm5lZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgZmluYWxNaWRkbGV3YXJlLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIHR5cGVvZiBpdGVtICE9PSBcImZ1bmN0aW9uXCI7IH0pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZWFjaCBtaWRkbGV3YXJlIHByb3ZpZGVkIHRvIGNvbmZpZ3VyZVN0b3JlIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcclxuICAgIH1cclxuICAgIHZhciBtaWRkbGV3YXJlRW5oYW5jZXIgPSBhcHBseU1pZGRsZXdhcmUuYXBwbHkodm9pZCAwLCBmaW5hbE1pZGRsZXdhcmUpO1xyXG4gICAgdmFyIGZpbmFsQ29tcG9zZSA9IGNvbXBvc2UyO1xyXG4gICAgaWYgKGRldlRvb2xzKSB7XHJcbiAgICAgICAgZmluYWxDb21wb3NlID0gY29tcG9zZVdpdGhEZXZUb29scyhfX3NwcmVhZFZhbHVlcyh7XHJcbiAgICAgICAgICAgIHRyYWNlOiAhSVNfUFJPRFVDVElPTlxyXG4gICAgICAgIH0sIHR5cGVvZiBkZXZUb29scyA9PT0gXCJvYmplY3RcIiAmJiBkZXZUb29scykpO1xyXG4gICAgfVxyXG4gICAgdmFyIHN0b3JlRW5oYW5jZXJzID0gW21pZGRsZXdhcmVFbmhhbmNlcl07XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbmhhbmNlcnMpKSB7XHJcbiAgICAgICAgc3RvcmVFbmhhbmNlcnMgPSBfX3NwcmVhZEFycmF5KFttaWRkbGV3YXJlRW5oYW5jZXJdLCBlbmhhbmNlcnMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGVuaGFuY2VycyA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgc3RvcmVFbmhhbmNlcnMgPSBlbmhhbmNlcnMoc3RvcmVFbmhhbmNlcnMpO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbXBvc2VkRW5oYW5jZXIgPSBmaW5hbENvbXBvc2UuYXBwbHkodm9pZCAwLCBzdG9yZUVuaGFuY2Vycyk7XHJcbiAgICByZXR1cm4gY3JlYXRlU3RvcmUocm9vdFJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBjb21wb3NlZEVuaGFuY2VyKTtcclxufVxyXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbih0eXBlLCBwcmVwYXJlQWN0aW9uKSB7XHJcbiAgICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJlcGFyZUFjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgcHJlcGFyZWQgPSBwcmVwYXJlQWN0aW9uLmFwcGx5KHZvaWQgMCwgYXJncyk7XHJcbiAgICAgICAgICAgIGlmICghcHJlcGFyZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInByZXBhcmVBY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcHJlcGFyZWQucGF5bG9hZFxyXG4gICAgICAgICAgICB9LCBcIm1ldGFcIiBpbiBwcmVwYXJlZCAmJiB7IG1ldGE6IHByZXBhcmVkLm1ldGEgfSksIFwiZXJyb3JcIiBpbiBwcmVwYXJlZCAmJiB7IGVycm9yOiBwcmVwYXJlZC5lcnJvciB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgcGF5bG9hZDogYXJnc1swXSB9O1xyXG4gICAgfVxyXG4gICAgYWN0aW9uQ3JlYXRvci50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiXCIgKyB0eXBlOyB9O1xyXG4gICAgYWN0aW9uQ3JlYXRvci50eXBlID0gdHlwZTtcclxuICAgIGFjdGlvbkNyZWF0b3IubWF0Y2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBhY3Rpb24udHlwZSA9PT0gdHlwZTsgfTtcclxuICAgIHJldHVybiBhY3Rpb25DcmVhdG9yO1xyXG59XHJcbmZ1bmN0aW9uIGlzRlNBKGFjdGlvbikge1xyXG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QoYWN0aW9uKSAmJiB0eXBlb2YgYWN0aW9uLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcclxufVxyXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xyXG4gICAgcmV0dXJuIFtcInR5cGVcIiwgXCJwYXlsb2FkXCIsIFwiZXJyb3JcIiwgXCJtZXRhXCJdLmluZGV4T2Yoa2V5KSA+IC0xO1xyXG59XHJcbmZ1bmN0aW9uIGdldFR5cGUoYWN0aW9uQ3JlYXRvcikge1xyXG4gICAgcmV0dXJuIFwiXCIgKyBhY3Rpb25DcmVhdG9yO1xyXG59XHJcbi8vIHNyYy9jcmVhdGVSZWR1Y2VyLnRzXHJcbmltcG9ydCBjcmVhdGVOZXh0U3RhdGUsIHsgaXNEcmFmdCBhcyBpc0RyYWZ0MiwgaXNEcmFmdGFibGUgfSBmcm9tIFwiaW1tZXJcIjtcclxuLy8gc3JjL21hcEJ1aWxkZXJzLnRzXHJcbmZ1bmN0aW9uIGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKGJ1aWxkZXJDYWxsYmFjaykge1xyXG4gICAgdmFyIGFjdGlvbnNNYXAgPSB7fTtcclxuICAgIHZhciBhY3Rpb25NYXRjaGVycyA9IFtdO1xyXG4gICAgdmFyIGRlZmF1bHRDYXNlUmVkdWNlcjtcclxuICAgIHZhciBidWlsZGVyID0ge1xyXG4gICAgICAgIGFkZENhc2U6IGZ1bmN0aW9uICh0eXBlT3JBY3Rpb25DcmVhdG9yLCByZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25NYXRjaGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZE1hdGNoZXJgXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XHJcbiAgICAgICAgICAgIGlmICh0eXBlIGluIGFjdGlvbnNNYXApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZENhc2UgY2Fubm90IGJlIGNhbGxlZCB3aXRoIHR3byByZWR1Y2VycyBmb3IgdGhlIHNhbWUgYWN0aW9uIHR5cGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWN0aW9uc01hcFt0eXBlXSA9IHJlZHVjZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkTWF0Y2hlcjogZnVuY3Rpb24gKG1hdGNoZXIsIHJlZHVjZXIpIHtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBidWlsZGVyLmFkZE1hdGNoZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWN0aW9uTWF0Y2hlcnMucHVzaCh7IG1hdGNoZXI6IG1hdGNoZXIsIHJlZHVjZXI6IHJlZHVjZXIgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkRGVmYXVsdENhc2U6IGZ1bmN0aW9uIChyZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2VcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdENhc2VSZWR1Y2VyID0gcmVkdWNlcjtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGJ1aWxkZXJDYWxsYmFjayhidWlsZGVyKTtcclxuICAgIHJldHVybiBbYWN0aW9uc01hcCwgYWN0aW9uTWF0Y2hlcnMsIGRlZmF1bHRDYXNlUmVkdWNlcl07XHJcbn1cclxuLy8gc3JjL2NyZWF0ZVJlZHVjZXIudHNcclxuZnVuY3Rpb24gaXNTdGF0ZUZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlZHVjZXIoaW5pdGlhbFN0YXRlLCBtYXBPckJ1aWxkZXJDYWxsYmFjaywgYWN0aW9uTWF0Y2hlcnMsIGRlZmF1bHRDYXNlUmVkdWNlcikge1xyXG4gICAgaWYgKGFjdGlvbk1hdGNoZXJzID09PSB2b2lkIDApIHsgYWN0aW9uTWF0Y2hlcnMgPSBbXTsgfVxyXG4gICAgdmFyIF9jID0gdHlwZW9mIG1hcE9yQnVpbGRlckNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhtYXBPckJ1aWxkZXJDYWxsYmFjaykgOiBbbWFwT3JCdWlsZGVyQ2FsbGJhY2ssIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdLCBhY3Rpb25zTWFwID0gX2NbMF0sIGZpbmFsQWN0aW9uTWF0Y2hlcnMgPSBfY1sxXSwgZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXIgPSBfY1syXTtcclxuICAgIHZhciBnZXRJbml0aWFsU3RhdGU7XHJcbiAgICBpZiAoaXNTdGF0ZUZ1bmN0aW9uKGluaXRpYWxTdGF0ZSkpIHtcclxuICAgICAgICBnZXRJbml0aWFsU3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVOZXh0U3RhdGUoaW5pdGlhbFN0YXRlKCksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB9KTsgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBmcm96ZW5Jbml0aWFsU3RhdGVfMSA9IGNyZWF0ZU5leHRTdGF0ZShpbml0aWFsU3RhdGUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB9KTtcclxuICAgICAgICBnZXRJbml0aWFsU3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmcm96ZW5Jbml0aWFsU3RhdGVfMTsgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xyXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7IHN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCk7IH1cclxuICAgICAgICB2YXIgY2FzZVJlZHVjZXJzID0gX19zcHJlYWRBcnJheShbXHJcbiAgICAgICAgICAgIGFjdGlvbnNNYXBbYWN0aW9uLnR5cGVdXHJcbiAgICAgICAgXSwgZmluYWxBY3Rpb25NYXRjaGVycy5maWx0ZXIoZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaGVyID0gX2MubWF0Y2hlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIoYWN0aW9uKTtcclxuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgIHZhciByZWR1Y2VyMiA9IF9jLnJlZHVjZXI7XHJcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VyMjtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgaWYgKGNhc2VSZWR1Y2Vycy5maWx0ZXIoZnVuY3Rpb24gKGNyKSB7IHJldHVybiAhIWNyOyB9KS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY2FzZVJlZHVjZXJzID0gW2ZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNhc2VSZWR1Y2Vycy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzU3RhdGUsIGNhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChjYXNlUmVkdWNlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRHJhZnQyKHByZXZpb3VzU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWZ0ID0gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNEcmFmdGFibGUocHJldmlvdXNTdGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2FzZVJlZHVjZXIocHJldmlvdXNTdGF0ZSwgYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJBIGNhc2UgcmVkdWNlciBvbiBhIG5vbi1kcmFmdGFibGUgdmFsdWUgbXVzdCBub3QgcmV0dXJuIHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVOZXh0U3RhdGUocHJldmlvdXNTdGF0ZSwgZnVuY3Rpb24gKGRyYWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICB9LCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICByZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZTtcclxuICAgIHJldHVybiByZWR1Y2VyO1xyXG59XHJcbi8vIHNyYy9jcmVhdGVTbGljZS50c1xyXG5mdW5jdGlvbiBnZXRUeXBlMihzbGljZSwgYWN0aW9uS2V5KSB7XHJcbiAgICByZXR1cm4gc2xpY2UgKyBcIi9cIiArIGFjdGlvbktleTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTbGljZShvcHRpb25zKSB7XHJcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZTtcclxuICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBuYW1lYCBpcyBhIHJlcXVpcmVkIG9wdGlvbiBmb3IgY3JlYXRlU2xpY2VcIik7XHJcbiAgICB9XHJcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gdHlwZW9mIG9wdGlvbnMuaW5pdGlhbFN0YXRlID09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuaW5pdGlhbFN0YXRlIDogZGVmYXVsdDIob3B0aW9ucy5pbml0aWFsU3RhdGUsIGZ1bmN0aW9uICgpIHtcclxuICAgIH0pO1xyXG4gICAgdmFyIHJlZHVjZXJzID0gb3B0aW9ucy5yZWR1Y2VycyB8fCB7fTtcclxuICAgIHZhciByZWR1Y2VyTmFtZXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XHJcbiAgICB2YXIgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUgPSB7fTtcclxuICAgIHZhciBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSA9IHt9O1xyXG4gICAgdmFyIGFjdGlvbkNyZWF0b3JzID0ge307XHJcbiAgICByZWR1Y2VyTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocmVkdWNlck5hbWUpIHtcclxuICAgICAgICB2YXIgbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUgPSByZWR1Y2Vyc1tyZWR1Y2VyTmFtZV07XHJcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlMihuYW1lLCByZWR1Y2VyTmFtZSk7XHJcbiAgICAgICAgdmFyIGNhc2VSZWR1Y2VyO1xyXG4gICAgICAgIHZhciBwcmVwYXJlQ2FsbGJhY2s7XHJcbiAgICAgICAgaWYgKFwicmVkdWNlclwiIGluIG1heWJlUmVkdWNlcldpdGhQcmVwYXJlKSB7XHJcbiAgICAgICAgICAgIGNhc2VSZWR1Y2VyID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucmVkdWNlcjtcclxuICAgICAgICAgICAgcHJlcGFyZUNhbGxiYWNrID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucHJlcGFyZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNhc2VSZWR1Y2VyID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lW3JlZHVjZXJOYW1lXSA9IGNhc2VSZWR1Y2VyO1xyXG4gICAgICAgIHNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlW3R5cGVdID0gY2FzZVJlZHVjZXI7XHJcbiAgICAgICAgYWN0aW9uQ3JlYXRvcnNbcmVkdWNlck5hbWVdID0gcHJlcGFyZUNhbGxiYWNrID8gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVDYWxsYmFjaykgOiBjcmVhdGVBY3Rpb24odHlwZSk7XHJcbiAgICB9KTtcclxuICAgIGZ1bmN0aW9uIGJ1aWxkUmVkdWNlcigpIHtcclxuICAgICAgICB2YXIgX2MgPSB0eXBlb2Ygb3B0aW9ucy5leHRyYVJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhvcHRpb25zLmV4dHJhUmVkdWNlcnMpIDogW29wdGlvbnMuZXh0cmFSZWR1Y2Vyc10sIF9kID0gX2NbMF0sIGV4dHJhUmVkdWNlcnMgPSBfZCA9PT0gdm9pZCAwID8ge30gOiBfZCwgX2UgPSBfY1sxXSwgYWN0aW9uTWF0Y2hlcnMgPSBfZSA9PT0gdm9pZCAwID8gW10gOiBfZSwgX2YgPSBfY1syXSwgZGVmYXVsdENhc2VSZWR1Y2VyID0gX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mO1xyXG4gICAgICAgIHZhciBmaW5hbENhc2VSZWR1Y2VycyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBleHRyYVJlZHVjZXJzKSwgc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUpO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgZmluYWxDYXNlUmVkdWNlcnMsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXIpO1xyXG4gICAgfVxyXG4gICAgdmFyIF9yZWR1Y2VyO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgIHJlZHVjZXI6IGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICghX3JlZHVjZXIpXHJcbiAgICAgICAgICAgICAgICBfcmVkdWNlciA9IGJ1aWxkUmVkdWNlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3JlZHVjZXIoc3RhdGUsIGFjdGlvbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhY3Rpb25zOiBhY3Rpb25DcmVhdG9ycyxcclxuICAgICAgICBjYXNlUmVkdWNlcnM6IHNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lLFxyXG4gICAgICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIV9yZWR1Y2VyKVxyXG4gICAgICAgICAgICAgICAgX3JlZHVjZXIgPSBidWlsZFJlZHVjZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuLy8gc3JjL2VudGl0aWVzL2VudGl0eV9zdGF0ZS50c1xyXG5mdW5jdGlvbiBnZXRJbml0aWFsRW50aXR5U3RhdGUoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkczogW10sXHJcbiAgICAgICAgZW50aXRpZXM6IHt9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3RvcnkoKSB7XHJcbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoYWRkaXRpb25hbFN0YXRlKSB7XHJcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxTdGF0ZSA9PT0gdm9pZCAwKSB7IGFkZGl0aW9uYWxTdGF0ZSA9IHt9OyB9XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCksIGFkZGl0aW9uYWxTdGF0ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBnZXRJbml0aWFsU3RhdGU6IGdldEluaXRpYWxTdGF0ZSB9O1xyXG59XHJcbi8vIHNyYy9lbnRpdGllcy9zdGF0ZV9zZWxlY3RvcnMudHNcclxuZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSgpIHtcclxuICAgIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhzZWxlY3RTdGF0ZSkge1xyXG4gICAgICAgIHZhciBzZWxlY3RJZHMgPSBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLmlkczsgfTtcclxuICAgICAgICB2YXIgc2VsZWN0RW50aXRpZXMgPSBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLmVudGl0aWVzOyB9O1xyXG4gICAgICAgIHZhciBzZWxlY3RBbGwgPSBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RJZHMsIHNlbGVjdEVudGl0aWVzLCBmdW5jdGlvbiAoaWRzLCBlbnRpdGllcykgeyByZXR1cm4gaWRzLm1hcChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGVudGl0aWVzW2lkXTsgfSk7IH0pO1xyXG4gICAgICAgIHZhciBzZWxlY3RJZCA9IGZ1bmN0aW9uIChfLCBpZCkgeyByZXR1cm4gaWQ7IH07XHJcbiAgICAgICAgdmFyIHNlbGVjdEJ5SWQgPSBmdW5jdGlvbiAoZW50aXRpZXMsIGlkKSB7IHJldHVybiBlbnRpdGllc1tpZF07IH07XHJcbiAgICAgICAgdmFyIHNlbGVjdFRvdGFsID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0SWRzLCBmdW5jdGlvbiAoaWRzKSB7IHJldHVybiBpZHMubGVuZ3RoOyB9KTtcclxuICAgICAgICBpZiAoIXNlbGVjdFN0YXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RJZHM6IHNlbGVjdElkcyxcclxuICAgICAgICAgICAgICAgIHNlbGVjdEVudGl0aWVzOiBzZWxlY3RFbnRpdGllcyxcclxuICAgICAgICAgICAgICAgIHNlbGVjdEFsbDogc2VsZWN0QWxsLFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0VG90YWw6IHNlbGVjdFRvdGFsLFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0QnlJZDogY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0RW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2VsZWN0R2xvYmFsaXplZEVudGl0aWVzID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0U3RhdGUsIHNlbGVjdEVudGl0aWVzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzZWxlY3RJZHM6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RJZHMpLFxyXG4gICAgICAgICAgICBzZWxlY3RFbnRpdGllczogc2VsZWN0R2xvYmFsaXplZEVudGl0aWVzLFxyXG4gICAgICAgICAgICBzZWxlY3RBbGw6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RBbGwpLFxyXG4gICAgICAgICAgICBzZWxlY3RUb3RhbDogY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0U3RhdGUsIHNlbGVjdFRvdGFsKSxcclxuICAgICAgICAgICAgc2VsZWN0QnlJZDogY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0R2xvYmFsaXplZEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgZ2V0U2VsZWN0b3JzOiBnZXRTZWxlY3RvcnMgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvc3RhdGVfYWRhcHRlci50c1xyXG5pbXBvcnQgY3JlYXRlTmV4dFN0YXRlMiwgeyBpc0RyYWZ0IGFzIGlzRHJhZnQzIH0gZnJvbSBcImltbWVyXCI7XHJcbmZ1bmN0aW9uIGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihtdXRhdG9yKSB7XHJcbiAgICB2YXIgb3BlcmF0b3IgPSBjcmVhdGVTdGF0ZU9wZXJhdG9yKGZ1bmN0aW9uIChfLCBzdGF0ZSkgeyByZXR1cm4gbXV0YXRvcihzdGF0ZSk7IH0pO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbihzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBvcGVyYXRvcihzdGF0ZSwgdm9pZCAwKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU3RhdGVPcGVyYXRvcihtdXRhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gb3BlcmF0aW9uKHN0YXRlLCBhcmcpIHtcclxuICAgICAgICBmdW5jdGlvbiBpc1BheWxvYWRBY3Rpb25Bcmd1bWVudChhcmcyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0ZTQShhcmcyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJ1bk11dGF0b3IgPSBmdW5jdGlvbiAoZHJhZnQpIHtcclxuICAgICAgICAgICAgaWYgKGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZykpIHtcclxuICAgICAgICAgICAgICAgIG11dGF0b3IoYXJnLnBheWxvYWQsIGRyYWZ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG11dGF0b3IoYXJnLCBkcmFmdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChpc0RyYWZ0MyhzdGF0ZSkpIHtcclxuICAgICAgICAgICAgcnVuTXV0YXRvcihzdGF0ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVOZXh0U3RhdGUyKHN0YXRlLCBydW5NdXRhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8vIHNyYy9lbnRpdGllcy91dGlscy50c1xyXG5mdW5jdGlvbiBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpIHtcclxuICAgIHZhciBrZXkgPSBzZWxlY3RJZChlbnRpdHkpO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBrZXkgPT09IHZvaWQgMCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBlbnRpdHkgcGFzc2VkIHRvIHRoZSBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uIHJldHVybmVkIHVuZGVmaW5lZC5cIiwgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHByb3ZpZGUgeW91ciBvd24gYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbi5cIiwgXCJUaGUgZW50aXR5IHRoYXQgd2FzIHBhc3NlZDpcIiwgZW50aXR5LCBcIlRoZSBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uOlwiLCBzZWxlY3RJZC50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBrZXk7XHJcbn1cclxuZnVuY3Rpb24gZW5zdXJlRW50aXRpZXNBcnJheShlbnRpdGllcykge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGVudGl0aWVzKSkge1xyXG4gICAgICAgIGVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhlbnRpdGllcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW50aXRpZXM7XHJcbn1cclxuZnVuY3Rpb24gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKSB7XHJcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xyXG4gICAgdmFyIGFkZGVkID0gW107XHJcbiAgICB2YXIgdXBkYXRlZCA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBuZXdFbnRpdGllc18xID0gbmV3RW50aXRpZXM7IF9pIDwgbmV3RW50aXRpZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgZW50aXR5ID0gbmV3RW50aXRpZXNfMVtfaV07XHJcbiAgICAgICAgdmFyIGlkID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcclxuICAgICAgICBpZiAoaWQgaW4gc3RhdGUuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgdXBkYXRlZC5wdXNoKHsgaWQ6IGlkLCBjaGFuZ2VzOiBlbnRpdHkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhZGRlZC5wdXNoKGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFthZGRlZCwgdXBkYXRlZF07XHJcbn1cclxuLy8gc3JjL2VudGl0aWVzL3Vuc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcclxuZnVuY3Rpb24gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpIHtcclxuICAgIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBrZXkgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xyXG4gICAgICAgIGlmIChrZXkgaW4gc3RhdGUuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xyXG4gICAgICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgICAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgbmV3RW50aXRpZXNfMiA9IG5ld0VudGl0aWVzOyBfaSA8IG5ld0VudGl0aWVzXzIubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRpdHkgPSBuZXdFbnRpdGllc18yW19pXTtcclxuICAgICAgICAgICAgYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICB2YXIga2V5ID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcclxuICAgICAgICBpZiAoIShrZXkgaW4gc3RhdGUuZW50aXRpZXMpKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmlkcy5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgICAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgbmV3RW50aXRpZXNfMyA9IG5ld0VudGl0aWVzOyBfaSA8IG5ld0VudGl0aWVzXzMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRpdHkgPSBuZXdFbnRpdGllc18zW19pXTtcclxuICAgICAgICAgICAgc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICAgICAgc3RhdGUuaWRzID0gW107XHJcbiAgICAgICAgc3RhdGUuZW50aXRpZXMgPSB7fTtcclxuICAgICAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlT25lTXV0YWJseShrZXksIHN0YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlbW92ZU1hbnlNdXRhYmx5KFtrZXldLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVNYW55TXV0YWJseShrZXlzLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBkaWRNdXRhdGUgPSBmYWxzZTtcclxuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNba2V5XTtcclxuICAgICAgICAgICAgICAgIGRpZE11dGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoZGlkTXV0YXRlKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmlkcyA9IHN0YXRlLmlkcy5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBpZCBpbiBzdGF0ZS5lbnRpdGllczsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTXV0YWJseShzdGF0ZSkge1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3RhdGUsIHtcclxuICAgICAgICAgICAgaWRzOiBbXSxcclxuICAgICAgICAgICAgZW50aXRpZXM6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0YWtlTmV3S2V5KGtleXMsIHVwZGF0ZSwgc3RhdGUpIHtcclxuICAgICAgICB2YXIgb3JpZ2luYWwyID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcclxuICAgICAgICB2YXIgdXBkYXRlZCA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsMiwgdXBkYXRlLmNoYW5nZXMpO1xyXG4gICAgICAgIHZhciBuZXdLZXkgPSBzZWxlY3RJZFZhbHVlKHVwZGF0ZWQsIHNlbGVjdElkKTtcclxuICAgICAgICB2YXIgaGFzTmV3S2V5ID0gbmV3S2V5ICE9PSB1cGRhdGUuaWQ7XHJcbiAgICAgICAgaWYgKGhhc05ld0tleSkge1xyXG4gICAgICAgICAgICBrZXlzW3VwZGF0ZS5pZF0gPSBuZXdLZXk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZS5lbnRpdGllc1tuZXdLZXldID0gdXBkYXRlZDtcclxuICAgICAgICByZXR1cm4gaGFzTmV3S2V5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGUsIHN0YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBuZXdLZXlzID0ge307XHJcbiAgICAgICAgdmFyIHVwZGF0ZXNQZXJFbnRpdHkgPSB7fTtcclxuICAgICAgICB1cGRhdGVzLmZvckVhY2goZnVuY3Rpb24gKHVwZGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAodXBkYXRlLmlkIGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHVwZGF0ZS5pZCxcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID8gdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdLmNoYW5nZXMgOiBudWxsKSwgdXBkYXRlLmNoYW5nZXMpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdXBkYXRlcyA9IE9iamVjdC52YWx1ZXModXBkYXRlc1BlckVudGl0eSk7XHJcbiAgICAgICAgdmFyIGRpZE11dGF0ZUVudGl0aWVzID0gdXBkYXRlcy5sZW5ndGggPiAwO1xyXG4gICAgICAgIGlmIChkaWRNdXRhdGVFbnRpdGllcykge1xyXG4gICAgICAgICAgICB2YXIgZGlkTXV0YXRlSWRzID0gdXBkYXRlcy5maWx0ZXIoZnVuY3Rpb24gKHVwZGF0ZSkgeyByZXR1cm4gdGFrZU5ld0tleShuZXdLZXlzLCB1cGRhdGUsIHN0YXRlKTsgfSkubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgaWYgKGRpZE11dGF0ZUlkcykge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuaWRzID0gc3RhdGUuaWRzLm1hcChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIG5ld0tleXNbaWRdIHx8IGlkOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIF9jID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKSwgYWRkZWQgPSBfY1swXSwgdXBkYXRlZCA9IF9jWzFdO1xyXG4gICAgICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcclxuICAgICAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZW1vdmVBbGw6IGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihyZW1vdmVBbGxNdXRhYmx5KSxcclxuICAgICAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXHJcbiAgICAgICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXHJcbiAgICAgICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxyXG4gICAgICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcclxuICAgICAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXHJcbiAgICAgICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXHJcbiAgICAgICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxyXG4gICAgICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHJlbW92ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVPbmVNdXRhYmx5KSxcclxuICAgICAgICByZW1vdmVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU1hbnlNdXRhYmx5KVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcclxuZnVuY3Rpb24gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0KSB7XHJcbiAgICB2YXIgX2MgPSBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCksIHJlbW92ZU9uZSA9IF9jLnJlbW92ZU9uZSwgcmVtb3ZlTWFueSA9IF9jLnJlbW92ZU1hbnksIHJlbW92ZUFsbCA9IF9jLnJlbW92ZUFsbDtcclxuICAgIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBhZGRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICB2YXIgbW9kZWxzID0gbmV3RW50aXRpZXMuZmlsdGVyKGZ1bmN0aW9uIChtb2RlbCkgeyByZXR1cm4gIShzZWxlY3RJZFZhbHVlKG1vZGVsLCBzZWxlY3RJZCkgaW4gc3RhdGUuZW50aXRpZXMpOyB9KTtcclxuICAgICAgICBpZiAobW9kZWxzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICBtZXJnZShtb2RlbHMsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gc2V0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICAgICAgaWYgKG5ld0VudGl0aWVzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICBtZXJnZShuZXdFbnRpdGllcywgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBzdGF0ZS5lbnRpdGllcyA9IHt9O1xyXG4gICAgICAgIHN0YXRlLmlkcyA9IFtdO1xyXG4gICAgICAgIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRha2VVcGRhdGVkTW9kZWwobW9kZWxzLCB1cGRhdGUsIHN0YXRlKSB7XHJcbiAgICAgICAgaWYgKCEodXBkYXRlLmlkIGluIHN0YXRlLmVudGl0aWVzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcmlnaW5hbDIgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xyXG4gICAgICAgIHZhciB1cGRhdGVkID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWwyLCB1cGRhdGUuY2hhbmdlcyk7XHJcbiAgICAgICAgdmFyIG5ld0tleSA9IHNlbGVjdElkVmFsdWUodXBkYXRlZCwgc2VsZWN0SWQpO1xyXG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xyXG4gICAgICAgIG1vZGVscy5wdXNoKHVwZGF0ZWQpO1xyXG4gICAgICAgIHJldHVybiBuZXdLZXkgIT09IHVwZGF0ZS5pZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIG1vZGVscyA9IFtdO1xyXG4gICAgICAgIHVwZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAodXBkYXRlKSB7IHJldHVybiB0YWtlVXBkYXRlZE1vZGVsKG1vZGVscywgdXBkYXRlLCBzdGF0ZSk7IH0pO1xyXG4gICAgICAgIGlmIChtb2RlbHMubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIG1lcmdlKG1vZGVscywgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIF9jID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKSwgYWRkZWQgPSBfY1swXSwgdXBkYXRlZCA9IF9jWzFdO1xyXG4gICAgICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcclxuICAgICAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYSwgYikge1xyXG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoICYmIGkgPCBiLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhW2ldID09PSBiW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbWVyZ2UobW9kZWxzLCBzdGF0ZSkge1xyXG4gICAgICAgIG1vZGVscy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICAgICAgICBzdGF0ZS5lbnRpdGllc1tzZWxlY3RJZChtb2RlbCldID0gbW9kZWw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGFsbEVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcyk7XHJcbiAgICAgICAgYWxsRW50aXRpZXMuc29ydChzb3J0KTtcclxuICAgICAgICB2YXIgbmV3U29ydGVkSWRzID0gYWxsRW50aXRpZXMubWFwKHNlbGVjdElkKTtcclxuICAgICAgICB2YXIgaWRzID0gc3RhdGUuaWRzO1xyXG4gICAgICAgIGlmICghYXJlQXJyYXlzRXF1YWwoaWRzLCBuZXdTb3J0ZWRJZHMpKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmlkcyA9IG5ld1NvcnRlZElkcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbW92ZU9uZTogcmVtb3ZlT25lLFxyXG4gICAgICAgIHJlbW92ZU1hbnk6IHJlbW92ZU1hbnksXHJcbiAgICAgICAgcmVtb3ZlQWxsOiByZW1vdmVBbGwsXHJcbiAgICAgICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxyXG4gICAgICAgIHVwZGF0ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVPbmVNdXRhYmx5KSxcclxuICAgICAgICB1cHNlcnRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0T25lTXV0YWJseSksXHJcbiAgICAgICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxyXG4gICAgICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcclxuICAgICAgICBhZGRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE1hbnlNdXRhYmx5KSxcclxuICAgICAgICB1cGRhdGVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU1hbnlNdXRhYmx5KSxcclxuICAgICAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvY3JlYXRlX2FkYXB0ZXIudHNcclxuZnVuY3Rpb24gY3JlYXRlRW50aXR5QWRhcHRlcihvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgdmFyIF9jID0gX19zcHJlYWRWYWx1ZXMoe1xyXG4gICAgICAgIHNvcnRDb21wYXJlcjogZmFsc2UsXHJcbiAgICAgICAgc2VsZWN0SWQ6IGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gaW5zdGFuY2UuaWQ7IH1cclxuICAgIH0sIG9wdGlvbnMpLCBzZWxlY3RJZCA9IF9jLnNlbGVjdElkLCBzb3J0Q29tcGFyZXIgPSBfYy5zb3J0Q29tcGFyZXI7XHJcbiAgICB2YXIgc3RhdGVGYWN0b3J5ID0gY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeSgpO1xyXG4gICAgdmFyIHNlbGVjdG9yc0ZhY3RvcnkgPSBjcmVhdGVTZWxlY3RvcnNGYWN0b3J5KCk7XHJcbiAgICB2YXIgc3RhdGVBZGFwdGVyID0gc29ydENvbXBhcmVyID8gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0Q29tcGFyZXIpIDogY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xyXG4gICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICBzZWxlY3RJZDogc2VsZWN0SWQsXHJcbiAgICAgICAgc29ydENvbXBhcmVyOiBzb3J0Q29tcGFyZXJcclxuICAgIH0sIHN0YXRlRmFjdG9yeSksIHNlbGVjdG9yc0ZhY3RvcnkpLCBzdGF0ZUFkYXB0ZXIpO1xyXG59XHJcbi8vIHNyYy9uYW5vaWQudHNcclxudmFyIHVybEFscGhhYmV0ID0gXCJNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXXCI7XHJcbnZhciBuYW5vaWQgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgaWYgKHNpemUgPT09IHZvaWQgMCkgeyBzaXplID0gMjE7IH1cclxuICAgIHZhciBpZCA9IFwiXCI7XHJcbiAgICB2YXIgaSA9IHNpemU7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgaWQgKz0gdXJsQWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaWQ7XHJcbn07XHJcbi8vIHNyYy9jcmVhdGVBc3luY1RodW5rLnRzXHJcbnZhciBjb21tb25Qcm9wZXJ0aWVzID0gW1xyXG4gICAgXCJuYW1lXCIsXHJcbiAgICBcIm1lc3NhZ2VcIixcclxuICAgIFwic3RhY2tcIixcclxuICAgIFwiY29kZVwiXHJcbl07XHJcbnZhciBSZWplY3RXaXRoVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZWplY3RXaXRoVmFsdWUocGF5bG9hZCwgbWV0YSkge1xyXG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZWplY3RXaXRoVmFsdWU7XHJcbn0oKSk7XHJcbnZhciBGdWxmaWxsV2l0aE1ldGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGdWxmaWxsV2l0aE1ldGEocGF5bG9hZCwgbWV0YSkge1xyXG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBGdWxmaWxsV2l0aE1ldGE7XHJcbn0oKSk7XHJcbnZhciBtaW5pU2VyaWFsaXplRXJyb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgc2ltcGxlRXJyb3IgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNvbW1vblByb3BlcnRpZXNfMSA9IGNvbW1vblByb3BlcnRpZXM7IF9pIDwgY29tbW9uUHJvcGVydGllc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBjb21tb25Qcm9wZXJ0aWVzXzFbX2ldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlW3Byb3BlcnR5XSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgc2ltcGxlRXJyb3JbcHJvcGVydHldID0gdmFsdWVbcHJvcGVydHldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaW1wbGVFcnJvcjtcclxuICAgIH1cclxuICAgIHJldHVybiB7IG1lc3NhZ2U6IFN0cmluZyh2YWx1ZSkgfTtcclxufTtcclxuZnVuY3Rpb24gY3JlYXRlQXN5bmNUaHVuayh0eXBlUHJlZml4LCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucykge1xyXG4gICAgdmFyIGZ1bGZpbGxlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvZnVsZmlsbGVkXCIsIGZ1bmN0aW9uIChwYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgbWV0YSkgeyByZXR1cm4gKHtcclxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgIG1ldGE6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1ldGEgfHwge30pLCB7XHJcbiAgICAgICAgICAgIGFyZzogYXJnLFxyXG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgcmVxdWVzdFN0YXR1czogXCJmdWxmaWxsZWRcIlxyXG4gICAgICAgIH0pXHJcbiAgICB9KTsgfSk7XHJcbiAgICB2YXIgcGVuZGluZyA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcGVuZGluZ1wiLCBmdW5jdGlvbiAocmVxdWVzdElkLCBhcmcsIG1ldGEpIHsgcmV0dXJuICh7XHJcbiAgICAgICAgcGF5bG9hZDogdm9pZCAwLFxyXG4gICAgICAgIG1ldGE6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1ldGEgfHwge30pLCB7XHJcbiAgICAgICAgICAgIGFyZzogYXJnLFxyXG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgcmVxdWVzdFN0YXR1czogXCJwZW5kaW5nXCJcclxuICAgICAgICB9KVxyXG4gICAgfSk7IH0pO1xyXG4gICAgdmFyIHJlamVjdGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9yZWplY3RlZFwiLCBmdW5jdGlvbiAoZXJyb3IsIHJlcXVlc3RJZCwgYXJnLCBwYXlsb2FkLCBtZXRhKSB7IHJldHVybiAoe1xyXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXHJcbiAgICAgICAgZXJyb3I6IChvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplRXJyb3IgfHwgbWluaVNlcmlhbGl6ZUVycm9yKShlcnJvciB8fCBcIlJlamVjdGVkXCIpLFxyXG4gICAgICAgIG1ldGE6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1ldGEgfHwge30pLCB7XHJcbiAgICAgICAgICAgIGFyZzogYXJnLFxyXG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgcmVqZWN0ZWRXaXRoVmFsdWU6ICEhcGF5bG9hZCxcclxuICAgICAgICAgICAgcmVxdWVzdFN0YXR1czogXCJyZWplY3RlZFwiLFxyXG4gICAgICAgICAgICBhYm9ydGVkOiAoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm5hbWUpID09PSBcIkFib3J0RXJyb3JcIixcclxuICAgICAgICAgICAgY29uZGl0aW9uOiAoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm5hbWUpID09PSBcIkNvbmRpdGlvbkVycm9yXCJcclxuICAgICAgICB9KVxyXG4gICAgfSk7IH0pO1xyXG4gICAgdmFyIGRpc3BsYXllZFdhcm5pbmcgPSBmYWxzZTtcclxuICAgIHZhciBBQyA9IHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgIT09IFwidW5kZWZpbmVkXCIgPyBBYm9ydENvbnRyb2xsZXIgOiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcclxuICAgICAgICAgICAgdGhpcy5zaWduYWwgPSB7XHJcbiAgICAgICAgICAgICAgICBhYm9ydGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uYWJvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRpc3BsYXllZFdhcm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5ZWRXYXJuaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJUaGlzIHBsYXRmb3JtIGRvZXMgbm90IGltcGxlbWVudCBBYm9ydENvbnRyb2xsZXIuIFxcbklmIHlvdSB3YW50IHRvIHVzZSB0aGUgQWJvcnRDb250cm9sbGVyIHRvIHJlYWN0IHRvIGBhYm9ydGAgZXZlbnRzLCBwbGVhc2UgY29uc2lkZXIgaW1wb3J0aW5nIGEgcG9seWZpbGwgbGlrZSAnYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsL2Rpc3QvYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsLW9ubHknLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XHJcbiAgICB9KCkpO1xyXG4gICAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvcihhcmcpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmEpIHtcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3RJZCA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmlkR2VuZXJhdG9yKSA/IG9wdGlvbnMuaWRHZW5lcmF0b3IoYXJnKSA6IG5hbm9pZCgpO1xyXG4gICAgICAgICAgICB2YXIgYWJvcnRDb250cm9sbGVyID0gbmV3IEFDKCk7XHJcbiAgICAgICAgICAgIHZhciBhYm9ydFJlYXNvbjtcclxuICAgICAgICAgICAgdmFyIGFib3J0ZWRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKF8sIHJlamVjdCkgeyByZXR1cm4gYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVqZWN0KHsgbmFtZTogXCJBYm9ydEVycm9yXCIsIG1lc3NhZ2U6IGFib3J0UmVhc29uIHx8IFwiQWJvcnRlZFwiIH0pOyB9KTsgfSk7XHJcbiAgICAgICAgICAgIHZhciBzdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFib3J0KHJlYXNvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhYm9ydFJlYXNvbiA9IHJlYXNvbjtcclxuICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBmaW5hbEFjdGlvbiwgY29uZGl0aW9uUmVzdWx0LCBlcnJfMSwgc2tpcERpc3BhdGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMCwgNCwgLCA1XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jb25kaXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIGFyZywgeyBnZXRTdGF0ZTogZ2V0U3RhdGUsIGV4dHJhOiBleHRyYSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVGhlbmFibGUoY29uZGl0aW9uUmVzdWx0KSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY29uZGl0aW9uUmVzdWx0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25SZXN1bHQgPSBfYy5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb25SZXN1bHQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQ29uZGl0aW9uRXJyb3JcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQWJvcnRlZCBkdWUgdG8gY29uZGl0aW9uIGNhbGxiYWNrIHJldHVybmluZyBmYWxzZS5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChwZW5kaW5nKHJlcXVlc3RJZCwgYXJnLCAoX2IgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdldFBlbmRpbmdNZXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChvcHRpb25zLCB7IHJlcXVlc3RJZDogcmVxdWVzdElkLCBhcmc6IGFyZyB9LCB7IGdldFN0YXRlOiBnZXRTdGF0ZSwgZXh0cmE6IGV4dHJhIH0pKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yYWNlKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0ZWRQcm9taXNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHBheWxvYWRDcmVhdG9yKGFyZywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IGV4dHJhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RXaXRoVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgbWV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlamVjdFdpdGhWYWx1ZSh2YWx1ZSwgbWV0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsV2l0aFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIG1ldGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdWxmaWxsV2l0aE1ldGEodmFsdWUsIG1ldGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVqZWN0V2l0aFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZ1bGZpbGxXaXRoTWV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdC5wYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgcmVzdWx0Lm1ldGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdCwgcmVxdWVzdElkLCBhcmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsQWN0aW9uID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycl8xID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsQWN0aW9uID0gZXJyXzEgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUgPyByZWplY3RlZChudWxsLCByZXF1ZXN0SWQsIGFyZywgZXJyXzEucGF5bG9hZCwgZXJyXzEubWV0YSkgOiByZWplY3RlZChlcnJfMSwgcmVxdWVzdElkLCBhcmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBEaXNwYXRjaCA9IG9wdGlvbnMgJiYgIW9wdGlvbnMuZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24gJiYgcmVqZWN0ZWQubWF0Y2goZmluYWxBY3Rpb24pICYmIGZpbmFsQWN0aW9uLm1ldGEuY29uZGl0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2tpcERpc3BhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKGZpbmFsQWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZpbmFsQWN0aW9uXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0oKTtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvbWlzZSwge1xyXG4gICAgICAgICAgICAgICAgYWJvcnQ6IGFib3J0LFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgICAgICBhcmc6IGFyZyxcclxuICAgICAgICAgICAgICAgIHVud3JhcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4odW53cmFwUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjdGlvbkNyZWF0b3IsIHtcclxuICAgICAgICBwZW5kaW5nOiBwZW5kaW5nLFxyXG4gICAgICAgIHJlamVjdGVkOiByZWplY3RlZCxcclxuICAgICAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcclxuICAgICAgICB0eXBlUHJlZml4OiB0eXBlUHJlZml4XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiB1bndyYXBSZXN1bHQoYWN0aW9uKSB7XHJcbiAgICBpZiAoYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWUpIHtcclxuICAgICAgICB0aHJvdyBhY3Rpb24ucGF5bG9hZDtcclxuICAgIH1cclxuICAgIGlmIChhY3Rpb24uZXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBhY3Rpb24uZXJyb3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XHJcbn1cclxuZnVuY3Rpb24gaXNUaGVuYWJsZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xyXG59XHJcbi8vIHNyYy90c0hlbHBlcnMudHNcclxudmFyIGhhc01hdGNoRnVuY3Rpb24gPSBmdW5jdGlvbiAodikge1xyXG4gICAgcmV0dXJuIHYgJiYgdHlwZW9mIHYubWF0Y2ggPT09IFwiZnVuY3Rpb25cIjtcclxufTtcclxuLy8gc3JjL21hdGNoZXJzLnRzXHJcbnZhciBtYXRjaGVzID0gZnVuY3Rpb24gKG1hdGNoZXIsIGFjdGlvbikge1xyXG4gICAgaWYgKGhhc01hdGNoRnVuY3Rpb24obWF0Y2hlcikpIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlci5tYXRjaChhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIoYWN0aW9uKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gaXNBbnlPZigpIHtcclxuICAgIHZhciBtYXRjaGVycyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBtYXRjaGVyc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlcnMuc29tZShmdW5jdGlvbiAobWF0Y2hlcikgeyByZXR1cm4gbWF0Y2hlcyhtYXRjaGVyLCBhY3Rpb24pOyB9KTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNBbGxPZigpIHtcclxuICAgIHZhciBtYXRjaGVycyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBtYXRjaGVyc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlcnMuZXZlcnkoZnVuY3Rpb24gKG1hdGNoZXIpIHsgcmV0dXJuIG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKTsgfSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgdmFsaWRTdGF0dXMpIHtcclxuICAgIGlmICghYWN0aW9uIHx8ICFhY3Rpb24ubWV0YSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB2YXIgaGFzVmFsaWRSZXF1ZXN0SWQgPSB0eXBlb2YgYWN0aW9uLm1ldGEucmVxdWVzdElkID09PSBcInN0cmluZ1wiO1xyXG4gICAgdmFyIGhhc1ZhbGlkUmVxdWVzdFN0YXR1cyA9IHZhbGlkU3RhdHVzLmluZGV4T2YoYWN0aW9uLm1ldGEucmVxdWVzdFN0YXR1cykgPiAtMTtcclxuICAgIHJldHVybiBoYXNWYWxpZFJlcXVlc3RJZCAmJiBoYXNWYWxpZFJlcXVlc3RTdGF0dXM7XHJcbn1cclxuZnVuY3Rpb24gaXNBc3luY1RodW5rQXJyYXkoYSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBhWzBdID09PSBcImZ1bmN0aW9uXCIgJiYgXCJwZW5kaW5nXCIgaW4gYVswXSAmJiBcImZ1bGZpbGxlZFwiIGluIGFbMF0gJiYgXCJyZWplY3RlZFwiIGluIGFbMF07XHJcbn1cclxuZnVuY3Rpb24gaXNQZW5kaW5nKCkge1xyXG4gICAgdmFyIGFzeW5jVGh1bmtzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFzeW5jVGh1bmtzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiXSk7IH07XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xyXG4gICAgICAgIHJldHVybiBpc1BlbmRpbmcoKShhc3luY1RodW5rc1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcChmdW5jdGlvbiAoYXN5bmNUaHVuaykgeyByZXR1cm4gYXN5bmNUaHVuay5wZW5kaW5nOyB9KTtcclxuICAgICAgICB2YXIgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZi5hcHBseSh2b2lkIDAsIG1hdGNoZXJzKTtcclxuICAgICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVqZWN0ZWQoKSB7XHJcbiAgICB2YXIgYXN5bmNUaHVua3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXN5bmNUaHVua3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJyZWplY3RlZFwiXSk7IH07XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xyXG4gICAgICAgIHJldHVybiBpc1JlamVjdGVkKCkoYXN5bmNUaHVua3NbMF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoZnVuY3Rpb24gKGFzeW5jVGh1bmspIHsgcmV0dXJuIGFzeW5jVGh1bmsucmVqZWN0ZWQ7IH0pO1xyXG4gICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FueU9mLmFwcGx5KHZvaWQgMCwgbWF0Y2hlcnMpO1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNSZWplY3RlZFdpdGhWYWx1ZSgpIHtcclxuICAgIHZhciBhc3luY1RodW5rcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhc3luY1RodW5rc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIGhhc0ZsYWcgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGFjdGlvbiAmJiBhY3Rpb24ubWV0YSAmJiBhY3Rpb24ubWV0YS5yZWplY3RlZFdpdGhWYWx1ZTtcclxuICAgIH07XHJcbiAgICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQWxsT2YoaXNSZWplY3RlZC5hcHBseSh2b2lkIDAsIGFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNSZWplY3RlZFdpdGhWYWx1ZSgpKGFzeW5jVGh1bmtzWzBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQWxsT2YoaXNSZWplY3RlZC5hcHBseSh2b2lkIDAsIGFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc0Z1bGZpbGxlZCgpIHtcclxuICAgIHZhciBhc3luY1RodW5rcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhc3luY1RodW5rc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcImZ1bGZpbGxlZFwiXSk7IH07XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xyXG4gICAgICAgIHJldHVybiBpc0Z1bGZpbGxlZCgpKGFzeW5jVGh1bmtzWzBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXJzID0gYXN5bmNUaHVua3MubWFwKGZ1bmN0aW9uIChhc3luY1RodW5rKSB7IHJldHVybiBhc3luY1RodW5rLmZ1bGZpbGxlZDsgfSk7XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YuYXBwbHkodm9pZCAwLCBtYXRjaGVycyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc0FzeW5jVGh1bmtBY3Rpb24oKSB7XHJcbiAgICB2YXIgYXN5bmNUaHVua3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXN5bmNUaHVua3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJwZW5kaW5nXCIsIFwiZnVsZmlsbGVkXCIsIFwicmVqZWN0ZWRcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNBc3luY1RodW5rQWN0aW9uKCkoYXN5bmNUaHVua3NbMF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgbWF0Y2hlcnMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGFzeW5jVGh1bmtzXzEgPSBhc3luY1RodW5rczsgX2kgPCBhc3luY1RodW5rc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgYXN5bmNUaHVuayA9IGFzeW5jVGh1bmtzXzFbX2ldO1xyXG4gICAgICAgICAgICBtYXRjaGVycy5wdXNoKGFzeW5jVGh1bmsucGVuZGluZywgYXN5bmNUaHVuay5yZWplY3RlZCwgYXN5bmNUaHVuay5mdWxmaWxsZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZi5hcHBseSh2b2lkIDAsIG1hdGNoZXJzKTtcclxuICAgICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XHJcbiAgICB9O1xyXG59XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdXRpbHMudHNcclxudmFyIGFzc2VydEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMsIGV4cGVjdGVkKSB7XHJcbiAgICBpZiAodHlwZW9mIGZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZXhwZWN0ZWQgKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcclxuICAgIH1cclxufTtcclxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcbnZhciBjYXRjaFJlamVjdGlvbiA9IGZ1bmN0aW9uIChwcm9taXNlLCBvbkVycm9yKSB7XHJcbiAgICBpZiAob25FcnJvciA9PT0gdm9pZCAwKSB7IG9uRXJyb3IgPSBub29wOyB9XHJcbiAgICBwcm9taXNlLmNhdGNoKG9uRXJyb3IpO1xyXG4gICAgcmV0dXJuIHByb21pc2U7XHJcbn07XHJcbnZhciBhZGRBYm9ydFNpZ25hbExpc3RlbmVyID0gZnVuY3Rpb24gKGFib3J0U2lnbmFsLCBjYWxsYmFjaykge1xyXG4gICAgYWJvcnRTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGNhbGxiYWNrLCB7IG9uY2U6IHRydWUgfSk7XHJcbn07XHJcbnZhciBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uID0gZnVuY3Rpb24gKGFib3J0Q29udHJvbGxlciwgcmVhc29uKSB7XHJcbiAgICB2YXIgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcclxuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghKFwicmVhc29uXCIgaW4gc2lnbmFsKSkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWduYWwsIFwicmVhc29uXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHJlYXNvbixcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgYWJvcnRDb250cm9sbGVyLmFib3J0KHJlYXNvbik7XHJcbn07XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvZXhjZXB0aW9ucy50c1xyXG52YXIgdGFzayA9IFwidGFza1wiO1xyXG52YXIgbGlzdGVuZXIgPSBcImxpc3RlbmVyXCI7XHJcbnZhciBjb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xyXG52YXIgY2FuY2VsbGVkID0gXCJjYW5jZWxsZWRcIjtcclxudmFyIHRhc2tDYW5jZWxsZWQgPSBcInRhc2stXCIgKyBjYW5jZWxsZWQ7XHJcbnZhciB0YXNrQ29tcGxldGVkID0gXCJ0YXNrLVwiICsgY29tcGxldGVkO1xyXG52YXIgbGlzdGVuZXJDYW5jZWxsZWQgPSBsaXN0ZW5lciArIFwiLVwiICsgY2FuY2VsbGVkO1xyXG52YXIgbGlzdGVuZXJDb21wbGV0ZWQgPSBsaXN0ZW5lciArIFwiLVwiICsgY29tcGxldGVkO1xyXG52YXIgVGFza0Fib3J0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUYXNrQWJvcnRFcnJvcihjb2RlKSB7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlRhc2tBYm9ydEVycm9yXCI7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGFzayArIFwiIFwiICsgY2FuY2VsbGVkICsgXCIgKHJlYXNvbjogXCIgKyBjb2RlICsgXCIpXCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVGFza0Fib3J0RXJyb3I7XHJcbn0oKSk7XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdGFzay50c1xyXG52YXIgdmFsaWRhdGVBY3RpdmUgPSBmdW5jdGlvbiAoc2lnbmFsKSB7XHJcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbik7XHJcbiAgICB9XHJcbn07XHJcbnZhciBwcm9taXNpZnlBYm9ydFNpZ25hbCA9IGZ1bmN0aW9uIChzaWduYWwpIHtcclxuICAgIHJldHVybiBjYXRjaFJlamVjdGlvbihuZXcgUHJvbWlzZShmdW5jdGlvbiAoXywgcmVqZWN0KSB7XHJcbiAgICAgICAgdmFyIG5vdGlmeVJlamVjdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdChuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbikpOyB9O1xyXG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgICAgICBub3RpZnlSZWplY3Rpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFkZEFib3J0U2lnbmFsTGlzdGVuZXIoc2lnbmFsLCBub3RpZnlSZWplY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH0pKTtcclxufTtcclxudmFyIHJ1blRhc2sgPSBmdW5jdGlvbiAodGFzazIsIGNsZWFuVXApIHsgcmV0dXJuIF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdmFsdWUsIGVycm9yXzE7XHJcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzAsIDMsIDQsIDVdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmVzb2x2ZSgpXTtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGFzazIoKV07XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcIm9rXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBlcnJvcl8xIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IgPyBcImNhbmNlbGxlZFwiIDogXCJyZWplY3RlZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JfMVxyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBjbGVhblVwID09IG51bGwgPyB2b2lkIDAgOiBjbGVhblVwKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xyXG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSk7IH07XHJcbnZhciBjcmVhdGVQYXVzZSA9IGZ1bmN0aW9uIChzaWduYWwpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvbWlzZSkge1xyXG4gICAgICAgIHJldHVybiBjYXRjaFJlamVjdGlvbihQcm9taXNlLnJhY2UoW3Byb21pc2lmeUFib3J0U2lnbmFsKHNpZ25hbCksIHByb21pc2VdKS50aGVuKGZ1bmN0aW9uIChvdXRwdXQpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgICAgICB9KSk7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgY3JlYXRlRGVsYXkgPSBmdW5jdGlvbiAoc2lnbmFsKSB7XHJcbiAgICB2YXIgcGF1c2UgPSBjcmVhdGVQYXVzZShzaWduYWwpO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0aW1lb3V0TXMpIHtcclxuICAgICAgICByZXR1cm4gcGF1c2UobmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dE1zKTsgfSkpO1xyXG4gICAgfTtcclxufTtcclxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9pbmRleC50c1xyXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcclxudmFyIElOVEVSTkFMX05JTF9UT0tFTiA9IHt9O1xyXG52YXIgYWxtID0gXCJsaXN0ZW5lck1pZGRsZXdhcmVcIjtcclxudmFyIGNyZWF0ZUZvcmsgPSBmdW5jdGlvbiAocGFyZW50QWJvcnRTaWduYWwpIHtcclxuICAgIHZhciBsaW5rQ29udHJvbGxlcnMgPSBmdW5jdGlvbiAoY29udHJvbGxlcikgeyByZXR1cm4gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihwYXJlbnRBYm9ydFNpZ25hbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBwYXJlbnRBYm9ydFNpZ25hbC5yZWFzb24pOyB9KTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFza0V4ZWN1dG9yKSB7XHJcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24odGFza0V4ZWN1dG9yLCBcInRhc2tFeGVjdXRvclwiKTtcclxuICAgICAgICB2YXIgY2hpbGRBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgICAgICAgbGlua0NvbnRyb2xsZXJzKGNoaWxkQWJvcnRDb250cm9sbGVyKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gcnVuVGFzayhmdW5jdGlvbiAoKSB7IHJldHVybiBfX2FzeW5jKHZvaWQgMCwgbnVsbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0MjtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUocGFyZW50QWJvcnRTaWduYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0YXNrRXhlY3V0b3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdXNlOiBjcmVhdGVQYXVzZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5OiBjcmVhdGVEZWxheShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0Ml07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ29tcGxldGVkKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmVzdWx0OiBjcmVhdGVQYXVzZShwYXJlbnRBYm9ydFNpZ25hbCkocmVzdWx0KSxcclxuICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59O1xyXG52YXIgY3JlYXRlVGFrZVBhdHRlcm4gPSBmdW5jdGlvbiAoc3RhcnRMaXN0ZW5pbmcsIHNpZ25hbCkge1xyXG4gICAgdmFyIHRha2UgPSBmdW5jdGlvbiAocHJlZGljYXRlLCB0aW1lb3V0KSB7IHJldHVybiBfX2FzeW5jKHZvaWQgMCwgbnVsbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB1bnN1YnNjcmliZSwgdHVwbGVQcm9taXNlLCBwcm9taXNlcywgb3V0cHV0O1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB0dXBsZVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSA9IHN0YXJ0TGlzdGVuaW5nKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWRpY2F0ZTogcHJlZGljYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0OiBmdW5jdGlvbiAoYWN0aW9uLCBsaXN0ZW5lckFwaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyQXBpLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJBcGkuZ2V0U3RhdGUoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJBcGkuZ2V0T3JpZ2luYWxTdGF0ZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNpZnlBYm9ydFNpZ25hbChzaWduYWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0dXBsZVByb21pc2VcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0LCBudWxsKTsgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsxLCAsIDMsIDRdKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLnJhY2UocHJvbWlzZXMpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBfYy5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgb3V0cHV0XTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGltZW91dCkgeyByZXR1cm4gY2F0Y2hSZWplY3Rpb24odGFrZShwcmVkaWNhdGUsIHRpbWVvdXQpKTsgfTtcclxufTtcclxudmFyIGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGUsIGFjdGlvbkNyZWF0b3IgPSBvcHRpb25zLmFjdGlvbkNyZWF0b3IsIG1hdGNoZXIgPSBvcHRpb25zLm1hdGNoZXIsIHByZWRpY2F0ZSA9IG9wdGlvbnMucHJlZGljYXRlLCBlZmZlY3QgPSBvcHRpb25zLmVmZmVjdDtcclxuICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgcHJlZGljYXRlID0gY3JlYXRlQWN0aW9uKHR5cGUpLm1hdGNoO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYWN0aW9uQ3JlYXRvcikge1xyXG4gICAgICAgIHR5cGUgPSBhY3Rpb25DcmVhdG9yLnR5cGU7XHJcbiAgICAgICAgcHJlZGljYXRlID0gYWN0aW9uQ3JlYXRvci5tYXRjaDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG1hdGNoZXIpIHtcclxuICAgICAgICBwcmVkaWNhdGUgPSBtYXRjaGVyO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJlZGljYXRlKSB7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDcmVhdGluZyBvciByZW1vdmluZyBhIGxpc3RlbmVyIHJlcXVpcmVzIG9uZSBvZiB0aGUga25vd24gZmllbGRzIGZvciBtYXRjaGluZyBhbiBhY3Rpb25cIik7XHJcbiAgICB9XHJcbiAgICBhc3NlcnRGdW5jdGlvbihlZmZlY3QsIFwib3B0aW9ucy5saXN0ZW5lclwiKTtcclxuICAgIHJldHVybiB7IHByZWRpY2F0ZTogcHJlZGljYXRlLCB0eXBlOiB0eXBlLCBlZmZlY3Q6IGVmZmVjdCB9O1xyXG59O1xyXG52YXIgY3JlYXRlTGlzdGVuZXJFbnRyeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgX2MgPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpLCB0eXBlID0gX2MudHlwZSwgcHJlZGljYXRlID0gX2MucHJlZGljYXRlLCBlZmZlY3QgPSBfYy5lZmZlY3Q7XHJcbiAgICB2YXIgaWQgPSBuYW5vaWQoKTtcclxuICAgIHZhciBlbnRyeSA9IHtcclxuICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgZWZmZWN0OiBlZmZlY3QsXHJcbiAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICBwcmVkaWNhdGU6IHByZWRpY2F0ZSxcclxuICAgICAgICBwZW5kaW5nOiBuZXcgU2V0KCksXHJcbiAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdWJzY3JpYmUgbm90IGluaXRpYWxpemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gZW50cnk7XHJcbn07XHJcbnZhciBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSA9IGZ1bmN0aW9uIChsaXN0ZW5lck1hcCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsaXN0ZW5lck1hcC5mb3JFYWNoKGNhbmNlbEFjdGl2ZUxpc3RlbmVycyk7XHJcbiAgICAgICAgbGlzdGVuZXJNYXAuY2xlYXIoKTtcclxuICAgIH07XHJcbn07XHJcbnZhciBzYWZlbHlOb3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvckhhbmRsZXIsIGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3JUb05vdGlmeSwgZXJyb3JJbmZvKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvckhhbmRsZXJFcnJvcikge1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvckhhbmRsZXJFcnJvcjtcclxuICAgICAgICB9LCAwKTtcclxuICAgIH1cclxufTtcclxudmFyIGFkZExpc3RlbmVyID0gY3JlYXRlQWN0aW9uKGFsbSArIFwiL2FkZFwiKTtcclxudmFyIGNsZWFyQWxsTGlzdGVuZXJzID0gY3JlYXRlQWN0aW9uKGFsbSArIFwiL3JlbW92ZUFsbFwiKTtcclxudmFyIHJlbW92ZUxpc3RlbmVyID0gY3JlYXRlQWN0aW9uKGFsbSArIFwiL3JlbW92ZVwiKTtcclxudmFyIGRlZmF1bHRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIF9fc3ByZWFkQXJyYXkoW2FsbSArIFwiL2Vycm9yXCJdLCBhcmdzKSk7XHJcbn07XHJcbnZhciBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgIGVudHJ5LnBlbmRpbmcuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbGxlcikge1xyXG4gICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xyXG4gICAgfSk7XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZShtaWRkbGV3YXJlT3B0aW9ucykge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgIGlmIChtaWRkbGV3YXJlT3B0aW9ucyA9PT0gdm9pZCAwKSB7IG1pZGRsZXdhcmVPcHRpb25zID0ge307IH1cclxuICAgIHZhciBsaXN0ZW5lck1hcCA9IG5ldyBNYXAoKTtcclxuICAgIHZhciBleHRyYSA9IG1pZGRsZXdhcmVPcHRpb25zLmV4dHJhLCBfYyA9IG1pZGRsZXdhcmVPcHRpb25zLm9uRXJyb3IsIG9uRXJyb3IgPSBfYyA9PT0gdm9pZCAwID8gZGVmYXVsdEVycm9ySGFuZGxlciA6IF9jO1xyXG4gICAgYXNzZXJ0RnVuY3Rpb24ob25FcnJvciwgXCJvbkVycm9yXCIpO1xyXG4gICAgdmFyIGluc2VydEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgZW50cnkudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsaXN0ZW5lck1hcC5kZWxldGUoZW50cnkuaWQpOyB9O1xyXG4gICAgICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2FuY2VsT3B0aW9ucykge1xyXG4gICAgICAgICAgICBlbnRyeS51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICBpZiAoY2FuY2VsT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY2FuY2VsT3B0aW9ucy5jYW5jZWxBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHZhciBmaW5kTGlzdGVuZXJFbnRyeSA9IGZ1bmN0aW9uIChjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYyA9IEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpOyBfaSA8IF9jLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSBfY1tfaV07XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKGVudHJ5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICB9O1xyXG4gICAgdmFyIHN0YXJ0TGlzdGVuaW5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSBmaW5kTGlzdGVuZXJFbnRyeShmdW5jdGlvbiAoZXhpc3RpbmdFbnRyeSkgeyByZXR1cm4gZXhpc3RpbmdFbnRyeS5lZmZlY3QgPT09IG9wdGlvbnMuZWZmZWN0OyB9KTtcclxuICAgICAgICBpZiAoIWVudHJ5KSB7XHJcbiAgICAgICAgICAgIGVudHJ5ID0gY3JlYXRlTGlzdGVuZXJFbnRyeShvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc2VydEVudHJ5KGVudHJ5KTtcclxuICAgIH07XHJcbiAgICB2YXIgc3RvcExpc3RlbmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9jID0gZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbShvcHRpb25zKSwgdHlwZSA9IF9jLnR5cGUsIGVmZmVjdCA9IF9jLmVmZmVjdCwgcHJlZGljYXRlID0gX2MucHJlZGljYXRlO1xyXG4gICAgICAgIHZhciBlbnRyeSA9IGZpbmRMaXN0ZW5lckVudHJ5KGZ1bmN0aW9uIChlbnRyeTIpIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoUHJlZGljYXRlT3JUeXBlID0gdHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIgPyBlbnRyeTIudHlwZSA9PT0gdHlwZSA6IGVudHJ5Mi5wcmVkaWNhdGUgPT09IHByZWRpY2F0ZTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoUHJlZGljYXRlT3JUeXBlICYmIGVudHJ5Mi5lZmZlY3QgPT09IGVmZmVjdDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoZW50cnkpIHtcclxuICAgICAgICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FuY2VsQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMoZW50cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAhIWVudHJ5O1xyXG4gICAgfTtcclxuICAgIHZhciBub3RpZnlMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbnRyeSwgYWN0aW9uLCBhcGksIGdldE9yaWdpbmFsU3RhdGUpIHsgcmV0dXJuIF9fYXN5bmMoX3RoaXMsIG51bGwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgdGFrZSwgbGlzdGVuZXJFcnJvcl8xO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsVGFza0NvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFrZSA9IGNyZWF0ZVRha2VQYXR0ZXJuKHN0YXJ0TGlzdGVuaW5nLCBpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMSwgMywgNCwgNV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuYWRkKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmVzb2x2ZShlbnRyeS5lZmZlY3QoYWN0aW9uLCBhc3NpZ24oe30sIGFwaSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3JpZ2luYWxTdGF0ZTogZ2V0T3JpZ2luYWxTdGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGltZW91dCkgeyByZXR1cm4gdGFrZShwcmVkaWNhdGUsIHRpbWVvdXQpLnRoZW4oQm9vbGVhbik7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWtlOiB0YWtlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXk6IGNyZWF0ZURlbGF5KGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdXNlOiBjcmVhdGVQYXVzZShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yazogY3JlYXRlRm9yayhpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZTogZW50cnkudW5zdWJzY3JpYmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5wZW5kaW5nLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIsIF8sIHNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlciAhPT0gaW50ZXJuYWxUYXNrQ29udHJvbGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQuZGVsZXRlKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lckVycm9yXzEgPSBfYy5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobGlzdGVuZXJFcnJvcl8xIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVseU5vdGlmeUVycm9yKG9uRXJyb3IsIGxpc3RlbmVyRXJyb3JfMSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2VkQnk6IFwiZWZmZWN0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDb21wbGV0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7IH07XHJcbiAgICB2YXIgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZShsaXN0ZW5lck1hcCk7XHJcbiAgICB2YXIgbWlkZGxld2FyZSA9IGZ1bmN0aW9uIChhcGkpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGFkZExpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0TGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNsZWFyQWxsTGlzdGVuZXJzLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVtb3ZlTGlzdGVuZXIubWF0Y2goYWN0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RvcExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcmlnaW5hbFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XHJcbiAgICAgICAgdmFyIGdldE9yaWdpbmFsU3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbFN0YXRlID09PSBJTlRFUk5BTF9OSUxfVE9LRU4pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhbG0gKyBcIjogZ2V0T3JpZ2luYWxTdGF0ZSBjYW4gb25seSBiZSBjYWxsZWQgc3luY2hyb25vdXNseVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxTdGF0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXJNYXAuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBhcGkuZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lckVudHJpZXMgPSBBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbGlzdGVuZXJFbnRyaWVzXzEgPSBsaXN0ZW5lckVudHJpZXM7IF9pIDwgbGlzdGVuZXJFbnRyaWVzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gbGlzdGVuZXJFbnRyaWVzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBydW5MaXN0ZW5lciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bkxpc3RlbmVyID0gZW50cnkucHJlZGljYXRlKGFjdGlvbiwgY3VycmVudFN0YXRlLCBvcmlnaW5hbFN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKHByZWRpY2F0ZUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bkxpc3RlbmVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVseU5vdGlmeUVycm9yKG9uRXJyb3IsIHByZWRpY2F0ZUVycm9yLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWlzZWRCeTogXCJwcmVkaWNhdGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFydW5MaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbm90aWZ5TGlzdGVuZXIoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgb3JpZ2luYWxTdGF0ZSA9IElOVEVSTkFMX05JTF9UT0tFTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07IH07IH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1pZGRsZXdhcmU6IG1pZGRsZXdhcmUsXHJcbiAgICAgICAgc3RhcnRMaXN0ZW5pbmc6IHN0YXJ0TGlzdGVuaW5nLFxyXG4gICAgICAgIHN0b3BMaXN0ZW5pbmc6IHN0b3BMaXN0ZW5pbmcsXHJcbiAgICAgICAgY2xlYXJMaXN0ZW5lcnM6IGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlXHJcbiAgICB9O1xyXG59XHJcbi8vIHNyYy9pbmRleC50c1xyXG5lbmFibGVFUzUoKTtcclxuZXhwb3J0IHsgTWlkZGxld2FyZUFycmF5LCBUYXNrQWJvcnRFcnJvciwgYWRkTGlzdGVuZXIsIGNsZWFyQWxsTGlzdGVuZXJzLCBjb25maWd1cmVTdG9yZSwgY3JlYXRlQWN0aW9uLCBjcmVhdGVBc3luY1RodW5rLCBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciwgY3JlYXRlRW50aXR5QWRhcHRlciwgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLCBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUsIGRlZmF1bHQyIGFzIGNyZWF0ZU5leHRTdGF0ZSwgY3JlYXRlUmVkdWNlciwgY3JlYXRlU2VsZWN0b3IyIGFzIGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsIGNyZWF0ZVNsaWNlLCBjdXJyZW50MiBhcyBjdXJyZW50LCBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUsIGZyZWV6ZSwgZ2V0RGVmYXVsdE1pZGRsZXdhcmUsIGdldFR5cGUsIGlzQWxsT2YsIGlzQW55T2YsIGlzQXN5bmNUaHVua0FjdGlvbiwgaXNEcmFmdDQgYXMgaXNEcmFmdCwgaXNGdWxmaWxsZWQsIGlzSW1tdXRhYmxlRGVmYXVsdCwgaXNQZW5kaW5nLCBpc1BsYWluLCBpc1BsYWluT2JqZWN0LCBpc1JlamVjdGVkLCBpc1JlamVjdGVkV2l0aFZhbHVlLCBtaW5pU2VyaWFsaXplRXJyb3IsIG5hbm9pZCwgb3JpZ2luYWwsIHJlbW92ZUxpc3RlbmVyLCB1bndyYXBSZXN1bHQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdXgtdG9vbGtpdC5lc20uanMubWFwIl0sIm5hbWVzIjpbIl9fZXh0ZW5kcyIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIl9fZ2VuZXJhdG9yIiwidGhpc0FyZyIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidCIsInRyeXMiLCJvcHMiLCJmIiwieSIsImciLCJuZXh0IiwidmVyYiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibiIsInYiLCJzdGVwIiwib3AiLCJkb25lIiwidmFsdWUiLCJwb3AiLCJsZW5ndGgiLCJwdXNoIiwiZSIsIl9fc3ByZWFkQXJyYXkiLCJ0byIsImZyb20iLCJpIiwiaWwiLCJqIiwiX19kZWZQcm9wIiwiZGVmaW5lUHJvcGVydHkiLCJfX2RlZlByb3BzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9fZ2V0T3duUHJvcERlc2NzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsIl9fZ2V0T3duUHJvcFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJfX2hhc093blByb3AiLCJfX3Byb3BJc0VudW0iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fc3ByZWFkVmFsdWVzIiwiYSIsInByb3AiLCJfaSIsIl9jIiwiX19zcHJlYWRQcm9wcyIsIl9fYXN5bmMiLCJfX3RoaXMiLCJfX2FyZ3VtZW50cyIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJ0aHJvdyIsIngiLCJ0aGVuIiwiYXBwbHkiLCJlbmFibGVFUzUiLCJkZWZhdWx0IiwiZGVmYXVsdDIiLCJjdXJyZW50IiwiY3VycmVudDIiLCJmcmVlemUiLCJvcmlnaW5hbCIsImlzRHJhZnQiLCJpc0RyYWZ0NCIsImNyZWF0ZVNlbGVjdG9yIiwiY3JlYXRlU2VsZWN0b3IyIiwiY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IiLCJhcmdzIiwiYXJndW1lbnRzIiwic2VsZWN0b3IiLCJ3cmFwcGVkU2VsZWN0b3IiLCJyZXN0IiwiY3JlYXRlU3RvcmUiLCJjb21wb3NlIiwiY29tcG9zZTIiLCJhcHBseU1pZGRsZXdhcmUiLCJjb21iaW5lUmVkdWNlcnMiLCJjb21wb3NlV2l0aERldlRvb2xzIiwid2luZG93IiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIiwiZGV2VG9vbHNFbmhhbmNlciIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18iLCJub29wMiIsImlzUGxhaW5PYmplY3QiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiYmFzZVByb3RvIiwidGh1bmtNaWRkbGV3YXJlIiwiZ2V0VGltZU1lYXN1cmVVdGlscyIsIm1heERlbGF5IiwiZm5OYW1lIiwiZWxhcHNlZCIsIm1lYXN1cmVUaW1lIiwiZm4iLCJzdGFydGVkIiwiRGF0ZSIsIm5vdyIsImZpbmlzaGVkIiwid2FybklmRXhjZWVkZWQiLCJjb25zb2xlIiwid2FybiIsIk1pZGRsZXdhcmVBcnJheSIsIl9zdXBlciIsIl90aGlzIiwic3BlY2llcyIsImdldCIsImNvbmNhdCIsImFyciIsInByZXBlbmQiLCJpc0FycmF5IiwiYmluZCIsImlzUHJvZHVjdGlvbiIsInByb2Nlc3MiLCJwcmVmaXgiLCJpbnZhcmlhbnQiLCJjb25kaXRpb24iLCJtZXNzYWdlIiwiRXJyb3IiLCJzdHJpbmdpZnkiLCJzZXJpYWxpemVyIiwiaW5kZW50IiwiZGVjeWNsZXIiLCJKU09OIiwiZ2V0U2VyaWFsaXplIiwic3RhY2siLCJrZXlzIiwic2xpY2UiLCJpbmRleE9mIiwiam9pbiIsInRoaXNQb3MiLCJzcGxpY2UiLCJJbmZpbml0eSIsImlzSW1tdXRhYmxlRGVmYXVsdCIsImlzRnJvemVuIiwidHJhY2tGb3JNdXRhdGlvbnMiLCJpc0ltbXV0YWJsZSIsImlnbm9yZVBhdGhzIiwidHJhY2tlZFByb3BlcnRpZXMiLCJ0cmFja1Byb3BlcnRpZXMiLCJkZXRlY3RNdXRhdGlvbnMiLCJwYXRoIiwidHJhY2tlZCIsImNoaWxkcmVuIiwiY2hpbGRQYXRoIiwidHJhY2tlZFByb3BlcnR5Iiwic2FtZVBhcmVudFJlZiIsInByZXZPYmoiLCJzYW1lUmVmIiwiTnVtYmVyIiwiaXNOYU4iLCJ3YXNNdXRhdGVkIiwia2V5c1RvRGV0ZWN0IiwicmVzdWx0IiwiY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlIiwib3B0aW9ucyIsImFjdGlvbiIsImlnbm9yZWRQYXRocyIsIl9kIiwid2FybkFmdGVyIiwiaWdub3JlIiwidHJhY2siLCJnZXRTdGF0ZSIsInN0YXRlIiwidHJhY2tlciIsIm1lYXN1cmVVdGlscyIsImRpc3BhdGNoZWRBY3Rpb24iLCJpc1BsYWluIiwidmFsIiwidHlwZSIsImZpbmROb25TZXJpYWxpemFibGVWYWx1ZSIsImlzU2VyaWFsaXphYmxlIiwiZ2V0RW50cmllcyIsImZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIiwia2V5UGF0aCIsImVudHJpZXMiLCJoYXNJZ25vcmVkUGF0aHMiLCJlbnRyaWVzXzEiLCJuZXN0ZWRWYWx1ZSIsIm5lc3RlZFBhdGgiLCJjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUiLCJpZ25vcmVkQWN0aW9ucyIsIl9lIiwiaWdub3JlZEFjdGlvblBhdGhzIiwiX2YiLCJfZyIsIl9oIiwiaWdub3JlU3RhdGUiLCJfaiIsImlnbm9yZUFjdGlvbnMiLCJzdG9yZUFQSSIsImZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJlcnJvciIsImZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSIsImlzQm9vbGVhbiIsImN1cnJ5R2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJjdXJyaWVkR2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJnZXREZWZhdWx0TWlkZGxld2FyZSIsInRodW5rIiwiaW1tdXRhYmxlQ2hlY2siLCJzZXJpYWxpemFibGVDaGVjayIsIm1pZGRsZXdhcmVBcnJheSIsIndpdGhFeHRyYUFyZ3VtZW50IiwiZXh0cmFBcmd1bWVudCIsImltbXV0YWJsZU9wdGlvbnMiLCJ1bnNoaWZ0Iiwic2VyaWFsaXphYmxlT3B0aW9ucyIsIklTX1BST0RVQ1RJT04iLCJjb25maWd1cmVTdG9yZSIsInJlZHVjZXIiLCJtaWRkbGV3YXJlIiwiZGV2VG9vbHMiLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VycyIsInJvb3RSZWR1Y2VyIiwiZmluYWxNaWRkbGV3YXJlIiwic29tZSIsIml0ZW0iLCJtaWRkbGV3YXJlRW5oYW5jZXIiLCJmaW5hbENvbXBvc2UiLCJ0cmFjZSIsInN0b3JlRW5oYW5jZXJzIiwiY29tcG9zZWRFbmhhbmNlciIsImNyZWF0ZUFjdGlvbiIsInByZXBhcmVBY3Rpb24iLCJhY3Rpb25DcmVhdG9yIiwicHJlcGFyZWQiLCJwYXlsb2FkIiwibWV0YSIsInRvU3RyaW5nIiwibWF0Y2giLCJpc0ZTQSIsImV2ZXJ5IiwiaXNWYWxpZEtleSIsImdldFR5cGUiLCJjcmVhdGVOZXh0U3RhdGUiLCJpc0RyYWZ0MiIsImlzRHJhZnRhYmxlIiwiZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2siLCJidWlsZGVyQ2FsbGJhY2siLCJhY3Rpb25zTWFwIiwiYWN0aW9uTWF0Y2hlcnMiLCJkZWZhdWx0Q2FzZVJlZHVjZXIiLCJidWlsZGVyIiwiYWRkQ2FzZSIsInR5cGVPckFjdGlvbkNyZWF0b3IiLCJhZGRNYXRjaGVyIiwibWF0Y2hlciIsImFkZERlZmF1bHRDYXNlIiwiaXNTdGF0ZUZ1bmN0aW9uIiwiY3JlYXRlUmVkdWNlciIsImluaXRpYWxTdGF0ZSIsIm1hcE9yQnVpbGRlckNhbGxiYWNrIiwiZmluYWxBY3Rpb25NYXRjaGVycyIsImZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyIiwiZ2V0SW5pdGlhbFN0YXRlIiwiZnJvemVuSW5pdGlhbFN0YXRlXzEiLCJjYXNlUmVkdWNlcnMiLCJmaWx0ZXIiLCJtYXAiLCJyZWR1Y2VyMiIsImNyIiwicmVkdWNlIiwicHJldmlvdXNTdGF0ZSIsImNhc2VSZWR1Y2VyIiwiZHJhZnQiLCJnZXRUeXBlMiIsImFjdGlvbktleSIsImNyZWF0ZVNsaWNlIiwibmFtZSIsInJlZHVjZXJzIiwicmVkdWNlck5hbWVzIiwic2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUiLCJzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSIsImFjdGlvbkNyZWF0b3JzIiwiZm9yRWFjaCIsInJlZHVjZXJOYW1lIiwibWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUiLCJwcmVwYXJlQ2FsbGJhY2siLCJwcmVwYXJlIiwiYnVpbGRSZWR1Y2VyIiwiZXh0cmFSZWR1Y2VycyIsImZpbmFsQ2FzZVJlZHVjZXJzIiwiX3JlZHVjZXIiLCJhY3Rpb25zIiwiZ2V0SW5pdGlhbEVudGl0eVN0YXRlIiwiaWRzIiwiZW50aXRpZXMiLCJjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5IiwiYWRkaXRpb25hbFN0YXRlIiwiYXNzaWduIiwiY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSIsImdldFNlbGVjdG9ycyIsInNlbGVjdFN0YXRlIiwic2VsZWN0SWRzIiwic2VsZWN0RW50aXRpZXMiLCJzZWxlY3RBbGwiLCJpZCIsInNlbGVjdElkIiwic2VsZWN0QnlJZCIsInNlbGVjdFRvdGFsIiwic2VsZWN0R2xvYmFsaXplZEVudGl0aWVzIiwiY3JlYXRlTmV4dFN0YXRlMiIsImlzRHJhZnQzIiwiY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yIiwibXV0YXRvciIsIm9wZXJhdG9yIiwiY3JlYXRlU3RhdGVPcGVyYXRvciIsIm9wZXJhdGlvbiIsImFyZyIsImlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50IiwiYXJnMiIsInJ1bk11dGF0b3IiLCJzZWxlY3RJZFZhbHVlIiwiZW50aXR5IiwiZW5zdXJlRW50aXRpZXNBcnJheSIsInZhbHVlcyIsInNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMiLCJuZXdFbnRpdGllcyIsImFkZGVkIiwidXBkYXRlZCIsIm5ld0VudGl0aWVzXzEiLCJjaGFuZ2VzIiwiY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJhZGRPbmVNdXRhYmx5IiwiYWRkTWFueU11dGFibHkiLCJuZXdFbnRpdGllc18yIiwic2V0T25lTXV0YWJseSIsInNldE1hbnlNdXRhYmx5IiwibmV3RW50aXRpZXNfMyIsInNldEFsbE11dGFibHkiLCJyZW1vdmVPbmVNdXRhYmx5IiwicmVtb3ZlTWFueU11dGFibHkiLCJkaWRNdXRhdGUiLCJyZW1vdmVBbGxNdXRhYmx5IiwidGFrZU5ld0tleSIsInVwZGF0ZSIsIm9yaWdpbmFsMiIsIm5ld0tleSIsImhhc05ld0tleSIsInVwZGF0ZU9uZU11dGFibHkiLCJ1cGRhdGVNYW55TXV0YWJseSIsInVwZGF0ZXMiLCJuZXdLZXlzIiwidXBkYXRlc1BlckVudGl0eSIsImRpZE11dGF0ZUVudGl0aWVzIiwiZGlkTXV0YXRlSWRzIiwidXBzZXJ0T25lTXV0YWJseSIsInVwc2VydE1hbnlNdXRhYmx5IiwicmVtb3ZlQWxsIiwiYWRkT25lIiwiYWRkTWFueSIsInNldE9uZSIsInNldE1hbnkiLCJzZXRBbGwiLCJ1cGRhdGVPbmUiLCJ1cGRhdGVNYW55IiwidXBzZXJ0T25lIiwidXBzZXJ0TWFueSIsInJlbW92ZU9uZSIsInJlbW92ZU1hbnkiLCJjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJzb3J0IiwibW9kZWxzIiwibW9kZWwiLCJtZXJnZSIsInRha2VVcGRhdGVkTW9kZWwiLCJhcmVBcnJheXNFcXVhbCIsImFsbEVudGl0aWVzIiwibmV3U29ydGVkSWRzIiwiY3JlYXRlRW50aXR5QWRhcHRlciIsInNvcnRDb21wYXJlciIsImluc3RhbmNlIiwic3RhdGVGYWN0b3J5Iiwic2VsZWN0b3JzRmFjdG9yeSIsInN0YXRlQWRhcHRlciIsInVybEFscGhhYmV0IiwibmFub2lkIiwic2l6ZSIsIk1hdGgiLCJyYW5kb20iLCJjb21tb25Qcm9wZXJ0aWVzIiwiUmVqZWN0V2l0aFZhbHVlIiwiRnVsZmlsbFdpdGhNZXRhIiwibWluaVNlcmlhbGl6ZUVycm9yIiwic2ltcGxlRXJyb3IiLCJjb21tb25Qcm9wZXJ0aWVzXzEiLCJwcm9wZXJ0eSIsImNyZWF0ZUFzeW5jVGh1bmsiLCJ0eXBlUHJlZml4IiwicGF5bG9hZENyZWF0b3IiLCJyZXF1ZXN0SWQiLCJyZXF1ZXN0U3RhdHVzIiwicGVuZGluZyIsInNlcmlhbGl6ZUVycm9yIiwicmVqZWN0ZWRXaXRoVmFsdWUiLCJhYm9ydGVkIiwiZGlzcGxheWVkV2FybmluZyIsIkFDIiwiQWJvcnRDb250cm9sbGVyIiwiY2xhc3NfMSIsInNpZ25hbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJkaXNwYXRjaEV2ZW50Iiwib25hYm9ydCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhYm9ydCIsImluZm8iLCJkaXNwYXRjaCIsImV4dHJhIiwiaWRHZW5lcmF0b3IiLCJhYm9ydENvbnRyb2xsZXIiLCJhYm9ydFJlYXNvbiIsImFib3J0ZWRQcm9taXNlIiwicmVhc29uIiwicHJvbWlzZSIsIl9hIiwiX2IiLCJmaW5hbEFjdGlvbiIsImNvbmRpdGlvblJlc3VsdCIsImVycl8xIiwic2tpcERpc3BhdGNoIiwiaXNUaGVuYWJsZSIsImdldFBlbmRpbmdNZXRhIiwicmFjZSIsInJlamVjdFdpdGhWYWx1ZSIsImZ1bGZpbGxXaXRoVmFsdWUiLCJkaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiIsInVud3JhcCIsInVud3JhcFJlc3VsdCIsImhhc01hdGNoRnVuY3Rpb24iLCJtYXRjaGVzIiwiaXNBbnlPZiIsIm1hdGNoZXJzIiwiaXNBbGxPZiIsImhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhIiwidmFsaWRTdGF0dXMiLCJoYXNWYWxpZFJlcXVlc3RJZCIsImhhc1ZhbGlkUmVxdWVzdFN0YXR1cyIsImlzQXN5bmNUaHVua0FycmF5IiwiaXNQZW5kaW5nIiwiYXN5bmNUaHVua3MiLCJhc3luY1RodW5rIiwiY29tYmluZWRNYXRjaGVyIiwiaXNSZWplY3RlZCIsImlzUmVqZWN0ZWRXaXRoVmFsdWUiLCJoYXNGbGFnIiwiaXNGdWxmaWxsZWQiLCJpc0FzeW5jVGh1bmtBY3Rpb24iLCJhc3luY1RodW5rc18xIiwiYXNzZXJ0RnVuY3Rpb24iLCJmdW5jIiwiZXhwZWN0ZWQiLCJub29wIiwiY2F0Y2hSZWplY3Rpb24iLCJvbkVycm9yIiwiY2F0Y2giLCJhZGRBYm9ydFNpZ25hbExpc3RlbmVyIiwiYWJvcnRTaWduYWwiLCJjYWxsYmFjayIsIm9uY2UiLCJhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uIiwidGFzayIsImxpc3RlbmVyIiwiY29tcGxldGVkIiwiY2FuY2VsbGVkIiwidGFza0NhbmNlbGxlZCIsInRhc2tDb21wbGV0ZWQiLCJsaXN0ZW5lckNhbmNlbGxlZCIsImxpc3RlbmVyQ29tcGxldGVkIiwiVGFza0Fib3J0RXJyb3IiLCJjb2RlIiwidmFsaWRhdGVBY3RpdmUiLCJwcm9taXNpZnlBYm9ydFNpZ25hbCIsIm5vdGlmeVJlamVjdGlvbiIsInJ1blRhc2siLCJ0YXNrMiIsImNsZWFuVXAiLCJlcnJvcl8xIiwic3RhdHVzIiwiY3JlYXRlUGF1c2UiLCJvdXRwdXQiLCJjcmVhdGVEZWxheSIsInBhdXNlIiwidGltZW91dE1zIiwic2V0VGltZW91dCIsIklOVEVSTkFMX05JTF9UT0tFTiIsImFsbSIsImNyZWF0ZUZvcmsiLCJwYXJlbnRBYm9ydFNpZ25hbCIsImxpbmtDb250cm9sbGVycyIsImNvbnRyb2xsZXIiLCJ0YXNrRXhlY3V0b3IiLCJjaGlsZEFib3J0Q29udHJvbGxlciIsInJlc3VsdDIiLCJkZWxheSIsImNhbmNlbCIsImNyZWF0ZVRha2VQYXR0ZXJuIiwic3RhcnRMaXN0ZW5pbmciLCJ0YWtlIiwicHJlZGljYXRlIiwidGltZW91dCIsInVuc3Vic2NyaWJlIiwidHVwbGVQcm9taXNlIiwicHJvbWlzZXMiLCJlZmZlY3QiLCJsaXN0ZW5lckFwaSIsImdldE9yaWdpbmFsU3RhdGUiLCJnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tIiwiY3JlYXRlTGlzdGVuZXJFbnRyeSIsImVudHJ5IiwiU2V0IiwiY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUiLCJsaXN0ZW5lck1hcCIsImNhbmNlbEFjdGl2ZUxpc3RlbmVycyIsImNsZWFyIiwic2FmZWx5Tm90aWZ5RXJyb3IiLCJlcnJvckhhbmRsZXIiLCJlcnJvclRvTm90aWZ5IiwiZXJyb3JJbmZvIiwiZXJyb3JIYW5kbGVyRXJyb3IiLCJhZGRMaXN0ZW5lciIsImNsZWFyQWxsTGlzdGVuZXJzIiwicmVtb3ZlTGlzdGVuZXIiLCJkZWZhdWx0RXJyb3JIYW5kbGVyIiwiY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlIiwibWlkZGxld2FyZU9wdGlvbnMiLCJNYXAiLCJpbnNlcnRFbnRyeSIsImRlbGV0ZSIsInNldCIsImNhbmNlbE9wdGlvbnMiLCJjYW5jZWxBY3RpdmUiLCJmaW5kTGlzdGVuZXJFbnRyeSIsImNvbXBhcmF0b3IiLCJleGlzdGluZ0VudHJ5Iiwic3RvcExpc3RlbmluZyIsImVudHJ5MiIsIm1hdGNoUHJlZGljYXRlT3JUeXBlIiwibm90aWZ5TGlzdGVuZXIiLCJhcGkiLCJpbnRlcm5hbFRhc2tDb250cm9sbGVyIiwibGlzdGVuZXJFcnJvcl8xIiwiYWRkIiwiQm9vbGVhbiIsImZvcmsiLCJzdWJzY3JpYmUiLCJyYWlzZWRCeSIsImNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlIiwib3JpZ2luYWxTdGF0ZSIsImN1cnJlbnRTdGF0ZSIsImxpc3RlbmVyRW50cmllcyIsImxpc3RlbmVyRW50cmllc18xIiwicnVuTGlzdGVuZXIiLCJwcmVkaWNhdGVFcnJvciIsImNsZWFyTGlzdGVuZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/node_modules/reselect/es/defaultMemoize.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/node_modules/reselect/es/defaultMemoize.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCacheKeyComparator: () => (/* binding */ createCacheKeyComparator),\n/* harmony export */   defaultEqualityCheck: () => (/* binding */ defaultEqualityCheck),\n/* harmony export */   defaultMemoize: () => (/* binding */ defaultMemoize)\n/* harmony export */ });\n// Cache implementation based on Erik Rasmussen's `lru-memoize`:\n// https://github.com/erikras/lru-memoize\nvar NOT_FOUND = \"NOT_FOUND\";\nfunction createSingletonCache(equals) {\n    var entry;\n    return {\n        get: function get(key) {\n            if (entry && equals(entry.key, key)) {\n                return entry.value;\n            }\n            return NOT_FOUND;\n        },\n        put: function put(key, value) {\n            entry = {\n                key: key,\n                value: value\n            };\n        },\n        getEntries: function getEntries() {\n            return entry ? [\n                entry\n            ] : [];\n        },\n        clear: function clear() {\n            entry = undefined;\n        }\n    };\n}\nfunction createLruCache(maxSize, equals) {\n    var entries = [];\n    function get(key) {\n        var cacheIndex = entries.findIndex(function(entry) {\n            return equals(key, entry.key);\n        }); // We found a cached entry\n        if (cacheIndex > -1) {\n            var entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top\n            if (cacheIndex > 0) {\n                entries.splice(cacheIndex, 1);\n                entries.unshift(entry);\n            }\n            return entry.value;\n        } // No entry found in cache, return sentinel\n        return NOT_FOUND;\n    }\n    function put(key, value) {\n        if (get(key) === NOT_FOUND) {\n            // TODO Is unshift slow?\n            entries.unshift({\n                key: key,\n                value: value\n            });\n            if (entries.length > maxSize) {\n                entries.pop();\n            }\n        }\n    }\n    function getEntries() {\n        return entries;\n    }\n    function clear() {\n        entries = [];\n    }\n    return {\n        get: get,\n        put: put,\n        getEntries: getEntries,\n        clear: clear\n    };\n}\nvar defaultEqualityCheck = function defaultEqualityCheck(a, b) {\n    return a === b;\n};\nfunction createCacheKeyComparator(equalityCheck) {\n    return function areArgumentsShallowlyEqual(prev, next) {\n        if (prev === null || next === null || prev.length !== next.length) {\n            return false;\n        } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n        var length = prev.length;\n        for(var i = 0; i < length; i++){\n            if (!equalityCheck(prev[i], next[i])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n// defaultMemoize now supports a configurable cache size with LRU behavior,\n// and optional comparison of the result value with existing values\nfunction defaultMemoize(func, equalityCheckOrOptions) {\n    var providedOptions = typeof equalityCheckOrOptions === \"object\" ? equalityCheckOrOptions : {\n        equalityCheck: equalityCheckOrOptions\n    };\n    var _providedOptions$equa = providedOptions.equalityCheck, equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa, _providedOptions$maxS = providedOptions.maxSize, maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS, resultEqualityCheck = providedOptions.resultEqualityCheck;\n    var comparator = createCacheKeyComparator(equalityCheck);\n    var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons\n    function memoized() {\n        var value = cache.get(arguments);\n        if (value === NOT_FOUND) {\n            // @ts-ignore\n            value = func.apply(null, arguments);\n            if (resultEqualityCheck) {\n                var entries = cache.getEntries();\n                var matchingEntry = entries.find(function(entry) {\n                    return resultEqualityCheck(entry.value, value);\n                });\n                if (matchingEntry) {\n                    value = matchingEntry.value;\n                }\n            }\n            cache.put(arguments, value);\n        }\n        return value;\n    }\n    memoized.clearCache = function() {\n        return cache.clear();\n    };\n    return memoized;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9ub2RlX21vZHVsZXMvcmVzZWxlY3QvZXMvZGVmYXVsdE1lbW9pemUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0VBQWdFO0FBQ2hFLHlDQUF5QztBQUN6QyxJQUFJQSxZQUFZO0FBRWhCLFNBQVNDLHFCQUFxQkMsTUFBTTtJQUNsQyxJQUFJQztJQUNKLE9BQU87UUFDTEMsS0FBSyxTQUFTQSxJQUFJQyxHQUFHO1lBQ25CLElBQUlGLFNBQVNELE9BQU9DLE1BQU1FLEdBQUcsRUFBRUEsTUFBTTtnQkFDbkMsT0FBT0YsTUFBTUcsS0FBSztZQUNwQjtZQUVBLE9BQU9OO1FBQ1Q7UUFDQU8sS0FBSyxTQUFTQSxJQUFJRixHQUFHLEVBQUVDLEtBQUs7WUFDMUJILFFBQVE7Z0JBQ05FLEtBQUtBO2dCQUNMQyxPQUFPQTtZQUNUO1FBQ0Y7UUFDQUUsWUFBWSxTQUFTQTtZQUNuQixPQUFPTCxRQUFRO2dCQUFDQTthQUFNLEdBQUcsRUFBRTtRQUM3QjtRQUNBTSxPQUFPLFNBQVNBO1lBQ2ROLFFBQVFPO1FBQ1Y7SUFDRjtBQUNGO0FBRUEsU0FBU0MsZUFBZUMsT0FBTyxFQUFFVixNQUFNO0lBQ3JDLElBQUlXLFVBQVUsRUFBRTtJQUVoQixTQUFTVCxJQUFJQyxHQUFHO1FBQ2QsSUFBSVMsYUFBYUQsUUFBUUUsU0FBUyxDQUFDLFNBQVVaLEtBQUs7WUFDaEQsT0FBT0QsT0FBT0csS0FBS0YsTUFBTUUsR0FBRztRQUM5QixJQUFJLDBCQUEwQjtRQUU5QixJQUFJUyxhQUFhLENBQUMsR0FBRztZQUNuQixJQUFJWCxRQUFRVSxPQUFPLENBQUNDLFdBQVcsRUFBRSx1REFBdUQ7WUFFeEYsSUFBSUEsYUFBYSxHQUFHO2dCQUNsQkQsUUFBUUcsTUFBTSxDQUFDRixZQUFZO2dCQUMzQkQsUUFBUUksT0FBTyxDQUFDZDtZQUNsQjtZQUVBLE9BQU9BLE1BQU1HLEtBQUs7UUFDcEIsRUFBRSwyQ0FBMkM7UUFHN0MsT0FBT047SUFDVDtJQUVBLFNBQVNPLElBQUlGLEdBQUcsRUFBRUMsS0FBSztRQUNyQixJQUFJRixJQUFJQyxTQUFTTCxXQUFXO1lBQzFCLHdCQUF3QjtZQUN4QmEsUUFBUUksT0FBTyxDQUFDO2dCQUNkWixLQUFLQTtnQkFDTEMsT0FBT0E7WUFDVDtZQUVBLElBQUlPLFFBQVFLLE1BQU0sR0FBR04sU0FBUztnQkFDNUJDLFFBQVFNLEdBQUc7WUFDYjtRQUNGO0lBQ0Y7SUFFQSxTQUFTWDtRQUNQLE9BQU9LO0lBQ1Q7SUFFQSxTQUFTSjtRQUNQSSxVQUFVLEVBQUU7SUFDZDtJQUVBLE9BQU87UUFDTFQsS0FBS0E7UUFDTEcsS0FBS0E7UUFDTEMsWUFBWUE7UUFDWkMsT0FBT0E7SUFDVDtBQUNGO0FBRU8sSUFBSVcsdUJBQXVCLFNBQVNBLHFCQUFxQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQ2xFLE9BQU9ELE1BQU1DO0FBQ2YsRUFBRTtBQUNLLFNBQVNDLHlCQUF5QkMsYUFBYTtJQUNwRCxPQUFPLFNBQVNDLDJCQUEyQkMsSUFBSSxFQUFFQyxJQUFJO1FBQ25ELElBQUlELFNBQVMsUUFBUUMsU0FBUyxRQUFRRCxLQUFLUixNQUFNLEtBQUtTLEtBQUtULE1BQU0sRUFBRTtZQUNqRSxPQUFPO1FBQ1QsRUFBRSw4R0FBOEc7UUFHaEgsSUFBSUEsU0FBU1EsS0FBS1IsTUFBTTtRQUV4QixJQUFLLElBQUlVLElBQUksR0FBR0EsSUFBSVYsUUFBUVUsSUFBSztZQUMvQixJQUFJLENBQUNKLGNBQWNFLElBQUksQ0FBQ0UsRUFBRSxFQUFFRCxJQUFJLENBQUNDLEVBQUUsR0FBRztnQkFDcEMsT0FBTztZQUNUO1FBQ0Y7UUFFQSxPQUFPO0lBQ1Q7QUFDRjtBQUNBLDJFQUEyRTtBQUMzRSxtRUFBbUU7QUFDNUQsU0FBU0MsZUFBZUMsSUFBSSxFQUFFQyxzQkFBc0I7SUFDekQsSUFBSUMsa0JBQWtCLE9BQU9ELDJCQUEyQixXQUFXQSx5QkFBeUI7UUFDMUZQLGVBQWVPO0lBQ2pCO0lBQ0EsSUFBSUUsd0JBQXdCRCxnQkFBZ0JSLGFBQWEsRUFDckRBLGdCQUFnQlMsMEJBQTBCLEtBQUssSUFBSWIsdUJBQXVCYSx1QkFDMUVDLHdCQUF3QkYsZ0JBQWdCcEIsT0FBTyxFQUMvQ0EsVUFBVXNCLDBCQUEwQixLQUFLLElBQUksSUFBSUEsdUJBQ2pEQyxzQkFBc0JILGdCQUFnQkcsbUJBQW1CO0lBQzdELElBQUlDLGFBQWFiLHlCQUF5QkM7SUFDMUMsSUFBSWEsUUFBUXpCLFlBQVksSUFBSVgscUJBQXFCbUMsY0FBY3pCLGVBQWVDLFNBQVN3QixhQUFhLDJFQUEyRTtJQUUvSyxTQUFTRTtRQUNQLElBQUloQyxRQUFRK0IsTUFBTWpDLEdBQUcsQ0FBQ21DO1FBRXRCLElBQUlqQyxVQUFVTixXQUFXO1lBQ3ZCLGFBQWE7WUFDYk0sUUFBUXdCLEtBQUtVLEtBQUssQ0FBQyxNQUFNRDtZQUV6QixJQUFJSixxQkFBcUI7Z0JBQ3ZCLElBQUl0QixVQUFVd0IsTUFBTTdCLFVBQVU7Z0JBQzlCLElBQUlpQyxnQkFBZ0I1QixRQUFRNkIsSUFBSSxDQUFDLFNBQVV2QyxLQUFLO29CQUM5QyxPQUFPZ0Msb0JBQW9CaEMsTUFBTUcsS0FBSyxFQUFFQTtnQkFDMUM7Z0JBRUEsSUFBSW1DLGVBQWU7b0JBQ2pCbkMsUUFBUW1DLGNBQWNuQyxLQUFLO2dCQUM3QjtZQUNGO1lBRUErQixNQUFNOUIsR0FBRyxDQUFDZ0MsV0FBV2pDO1FBQ3ZCO1FBRUEsT0FBT0E7SUFDVDtJQUVBZ0MsU0FBU0ssVUFBVSxHQUFHO1FBQ3BCLE9BQU9OLE1BQU01QixLQUFLO0lBQ3BCO0lBRUEsT0FBTzZCO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tdWx0aXZlcnN4LWRhcHAvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9ub2RlX21vZHVsZXMvcmVzZWxlY3QvZXMvZGVmYXVsdE1lbW9pemUuanM/YjIyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDYWNoZSBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBFcmlrIFJhc211c3NlbidzIGBscnUtbWVtb2l6ZWA6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZXJpa3Jhcy9scnUtbWVtb2l6ZVxudmFyIE5PVF9GT1VORCA9ICdOT1RfRk9VTkQnO1xuXG5mdW5jdGlvbiBjcmVhdGVTaW5nbGV0b25DYWNoZShlcXVhbHMpIHtcbiAgdmFyIGVudHJ5O1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgaWYgKGVudHJ5ICYmIGVxdWFscyhlbnRyeS5rZXksIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTk9UX0ZPVU5EO1xuICAgIH0sXG4gICAgcHV0OiBmdW5jdGlvbiBwdXQoa2V5LCB2YWx1ZSkge1xuICAgICAgZW50cnkgPSB7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRFbnRyaWVzOiBmdW5jdGlvbiBnZXRFbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGVudHJ5ID8gW2VudHJ5XSA6IFtdO1xuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgZW50cnkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMcnVDYWNoZShtYXhTaXplLCBlcXVhbHMpIHtcbiAgdmFyIGVudHJpZXMgPSBbXTtcblxuICBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGNhY2hlSW5kZXggPSBlbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIHJldHVybiBlcXVhbHMoa2V5LCBlbnRyeS5rZXkpO1xuICAgIH0pOyAvLyBXZSBmb3VuZCBhIGNhY2hlZCBlbnRyeVxuXG4gICAgaWYgKGNhY2hlSW5kZXggPiAtMSkge1xuICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tjYWNoZUluZGV4XTsgLy8gQ2FjaGVkIGVudHJ5IG5vdCBhdCB0b3Agb2YgY2FjaGUsIG1vdmUgaXQgdG8gdGhlIHRvcFxuXG4gICAgICBpZiAoY2FjaGVJbmRleCA+IDApIHtcbiAgICAgICAgZW50cmllcy5zcGxpY2UoY2FjaGVJbmRleCwgMSk7XG4gICAgICAgIGVudHJpZXMudW5zaGlmdChlbnRyeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICB9IC8vIE5vIGVudHJ5IGZvdW5kIGluIGNhY2hlLCByZXR1cm4gc2VudGluZWxcblxuXG4gICAgcmV0dXJuIE5PVF9GT1VORDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1dChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGdldChrZXkpID09PSBOT1RfRk9VTkQpIHtcbiAgICAgIC8vIFRPRE8gSXMgdW5zaGlmdCBzbG93P1xuICAgICAgZW50cmllcy51bnNoaWZ0KHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IG1heFNpemUpIHtcbiAgICAgICAgZW50cmllcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbnRyaWVzKCkge1xuICAgIHJldHVybiBlbnRyaWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgZW50cmllcyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGdldCxcbiAgICBwdXQ6IHB1dCxcbiAgICBnZXRFbnRyaWVzOiBnZXRFbnRyaWVzLFxuICAgIGNsZWFyOiBjbGVhclxuICB9O1xufVxuXG5leHBvcnQgdmFyIGRlZmF1bHRFcXVhbGl0eUNoZWNrID0gZnVuY3Rpb24gZGVmYXVsdEVxdWFsaXR5Q2hlY2soYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn07XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKGVxdWFsaXR5Q2hlY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKHByZXYsIG5leHQpIHtcbiAgICBpZiAocHJldiA9PT0gbnVsbCB8fCBuZXh0ID09PSBudWxsIHx8IHByZXYubGVuZ3RoICE9PSBuZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gRG8gdGhpcyBpbiBhIGZvciBsb29wIChhbmQgbm90IGEgYGZvckVhY2hgIG9yIGFuIGBldmVyeWApIHNvIHdlIGNhbiBkZXRlcm1pbmUgZXF1YWxpdHkgYXMgZmFzdCBhcyBwb3NzaWJsZS5cblxuXG4gICAgdmFyIGxlbmd0aCA9IHByZXYubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFlcXVhbGl0eUNoZWNrKHByZXZbaV0sIG5leHRbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbi8vIGRlZmF1bHRNZW1vaXplIG5vdyBzdXBwb3J0cyBhIGNvbmZpZ3VyYWJsZSBjYWNoZSBzaXplIHdpdGggTFJVIGJlaGF2aW9yLFxuLy8gYW5kIG9wdGlvbmFsIGNvbXBhcmlzb24gb2YgdGhlIHJlc3VsdCB2YWx1ZSB3aXRoIGV4aXN0aW5nIHZhbHVlc1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRNZW1vaXplKGZ1bmMsIGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMpIHtcbiAgdmFyIHByb3ZpZGVkT3B0aW9ucyA9IHR5cGVvZiBlcXVhbGl0eUNoZWNrT3JPcHRpb25zID09PSAnb2JqZWN0JyA/IGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgOiB7XG4gICAgZXF1YWxpdHlDaGVjazogZXF1YWxpdHlDaGVja09yT3B0aW9uc1xuICB9O1xuICB2YXIgX3Byb3ZpZGVkT3B0aW9ucyRlcXVhID0gcHJvdmlkZWRPcHRpb25zLmVxdWFsaXR5Q2hlY2ssXG4gICAgICBlcXVhbGl0eUNoZWNrID0gX3Byb3ZpZGVkT3B0aW9ucyRlcXVhID09PSB2b2lkIDAgPyBkZWZhdWx0RXF1YWxpdHlDaGVjayA6IF9wcm92aWRlZE9wdGlvbnMkZXF1YSxcbiAgICAgIF9wcm92aWRlZE9wdGlvbnMkbWF4UyA9IHByb3ZpZGVkT3B0aW9ucy5tYXhTaXplLFxuICAgICAgbWF4U2l6ZSA9IF9wcm92aWRlZE9wdGlvbnMkbWF4UyA9PT0gdm9pZCAwID8gMSA6IF9wcm92aWRlZE9wdGlvbnMkbWF4UyxcbiAgICAgIHJlc3VsdEVxdWFsaXR5Q2hlY2sgPSBwcm92aWRlZE9wdGlvbnMucmVzdWx0RXF1YWxpdHlDaGVjaztcbiAgdmFyIGNvbXBhcmF0b3IgPSBjcmVhdGVDYWNoZUtleUNvbXBhcmF0b3IoZXF1YWxpdHlDaGVjayk7XG4gIHZhciBjYWNoZSA9IG1heFNpemUgPT09IDEgPyBjcmVhdGVTaW5nbGV0b25DYWNoZShjb21wYXJhdG9yKSA6IGNyZWF0ZUxydUNhY2hlKG1heFNpemUsIGNvbXBhcmF0b3IpOyAvLyB3ZSByZWZlcmVuY2UgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIHRoZW0gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcblxuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICB2YXIgdmFsdWUgPSBjYWNoZS5nZXQoYXJndW1lbnRzKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB2YWx1ZSA9IGZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblxuICAgICAgaWYgKHJlc3VsdEVxdWFsaXR5Q2hlY2spIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSBjYWNoZS5nZXRFbnRyaWVzKCk7XG4gICAgICAgIHZhciBtYXRjaGluZ0VudHJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHRFcXVhbGl0eUNoZWNrKGVudHJ5LnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtYXRjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgdmFsdWUgPSBtYXRjaGluZ0VudHJ5LnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhY2hlLnB1dChhcmd1bWVudHMsIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBtZW1vaXplZC5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWNoZS5jbGVhcigpO1xuICB9O1xuXG4gIHJldHVybiBtZW1vaXplZDtcbn0iXSwibmFtZXMiOlsiTk9UX0ZPVU5EIiwiY3JlYXRlU2luZ2xldG9uQ2FjaGUiLCJlcXVhbHMiLCJlbnRyeSIsImdldCIsImtleSIsInZhbHVlIiwicHV0IiwiZ2V0RW50cmllcyIsImNsZWFyIiwidW5kZWZpbmVkIiwiY3JlYXRlTHJ1Q2FjaGUiLCJtYXhTaXplIiwiZW50cmllcyIsImNhY2hlSW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJ1bnNoaWZ0IiwibGVuZ3RoIiwicG9wIiwiZGVmYXVsdEVxdWFsaXR5Q2hlY2siLCJhIiwiYiIsImNyZWF0ZUNhY2hlS2V5Q29tcGFyYXRvciIsImVxdWFsaXR5Q2hlY2siLCJhcmVBcmd1bWVudHNTaGFsbG93bHlFcXVhbCIsInByZXYiLCJuZXh0IiwiaSIsImRlZmF1bHRNZW1vaXplIiwiZnVuYyIsImVxdWFsaXR5Q2hlY2tPck9wdGlvbnMiLCJwcm92aWRlZE9wdGlvbnMiLCJfcHJvdmlkZWRPcHRpb25zJGVxdWEiLCJfcHJvdmlkZWRPcHRpb25zJG1heFMiLCJyZXN1bHRFcXVhbGl0eUNoZWNrIiwiY29tcGFyYXRvciIsImNhY2hlIiwibWVtb2l6ZWQiLCJhcmd1bWVudHMiLCJhcHBseSIsIm1hdGNoaW5nRW50cnkiLCJmaW5kIiwiY2xlYXJDYWNoZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/node_modules/reselect/es/defaultMemoize.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/node_modules/reselect/es/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/node_modules/reselect/es/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSelector: () => (/* binding */ createSelector),\n/* harmony export */   createSelectorCreator: () => (/* binding */ createSelectorCreator),\n/* harmony export */   createStructuredSelector: () => (/* binding */ createStructuredSelector),\n/* harmony export */   defaultEqualityCheck: () => (/* reexport safe */ _defaultMemoize__WEBPACK_IMPORTED_MODULE_0__.defaultEqualityCheck),\n/* harmony export */   defaultMemoize: () => (/* reexport safe */ _defaultMemoize__WEBPACK_IMPORTED_MODULE_0__.defaultMemoize)\n/* harmony export */ });\n/* harmony import */ var _defaultMemoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultMemoize */ \"(ssr)/./node_modules/@reduxjs/toolkit/node_modules/reselect/es/defaultMemoize.js\");\n\n\nfunction getDependencies(funcs) {\n    var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\n    if (!dependencies.every(function(dep) {\n        return typeof dep === \"function\";\n    })) {\n        var dependencyTypes = dependencies.map(function(dep) {\n            return typeof dep === \"function\" ? \"function \" + (dep.name || \"unnamed\") + \"()\" : typeof dep;\n        }).join(\", \");\n        throw new Error(\"createSelector expects all input-selectors to be functions, but received the following types: [\" + dependencyTypes + \"]\");\n    }\n    return dependencies;\n}\nfunction createSelectorCreator(memoize) {\n    for(var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        memoizeOptionsFromArgs[_key - 1] = arguments[_key];\n    }\n    var createSelector = function createSelector() {\n        for(var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            funcs[_key2] = arguments[_key2];\n        }\n        var _recomputations = 0;\n        var _lastResult; // Due to the intricacies of rest params, we can't do an optional arg after `...funcs`.\n        // So, start by declaring the default value here.\n        // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\n        var directlyPassedOptions = {\n            memoizeOptions: undefined\n        }; // Normally, the result func or \"output selector\" is the last arg\n        var resultFunc = funcs.pop(); // If the result func is actually an _object_, assume it's our options object\n        if (typeof resultFunc === \"object\") {\n            directlyPassedOptions = resultFunc; // and pop the real result func off\n            resultFunc = funcs.pop();\n        }\n        if (typeof resultFunc !== \"function\") {\n            throw new Error(\"createSelector expects an output function after the inputs, but received: [\" + typeof resultFunc + \"]\");\n        } // Determine which set of options we're using. Prefer options passed directly,\n        // but fall back to options given to createSelectorCreator.\n        var _directlyPassedOption = directlyPassedOptions, _directlyPassedOption2 = _directlyPassedOption.memoizeOptions, memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2; // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\n        // is an array. In most libs I've looked at, it's an equality function or options object.\n        // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\n        // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\n        // we wrap it in an array so we can apply it.\n        var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [\n            memoizeOptions\n        ];\n        var dependencies = getDependencies(funcs);\n        var memoizedResultFunc = memoize.apply(void 0, [\n            function recomputationWrapper() {\n                _recomputations++; // apply arguments instead of spreading for performance.\n                return resultFunc.apply(null, arguments);\n            }\n        ].concat(finalMemoizeOptions)); // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\n        var selector = memoize(function dependenciesChecker() {\n            var params = [];\n            var length = dependencies.length;\n            for(var i = 0; i < length; i++){\n                // apply arguments instead of spreading and mutate a local list of params for performance.\n                // @ts-ignore\n                params.push(dependencies[i].apply(null, arguments));\n            } // apply arguments instead of spreading for performance.\n            _lastResult = memoizedResultFunc.apply(null, params);\n            return _lastResult;\n        });\n        Object.assign(selector, {\n            resultFunc: resultFunc,\n            memoizedResultFunc: memoizedResultFunc,\n            dependencies: dependencies,\n            lastResult: function lastResult() {\n                return _lastResult;\n            },\n            recomputations: function recomputations() {\n                return _recomputations;\n            },\n            resetRecomputations: function resetRecomputations() {\n                return _recomputations = 0;\n            }\n        });\n        return selector;\n    }; // @ts-ignore\n    return createSelector;\n}\nvar createSelector = /* #__PURE__ */ createSelectorCreator(_defaultMemoize__WEBPACK_IMPORTED_MODULE_0__.defaultMemoize);\n// Manual definition of state and output arguments\nvar createStructuredSelector = function createStructuredSelector(selectors, selectorCreator) {\n    if (selectorCreator === void 0) {\n        selectorCreator = createSelector;\n    }\n    if (typeof selectors !== \"object\") {\n        throw new Error(\"createStructuredSelector expects first argument to be an object \" + (\"where each property is a selector, instead received a \" + typeof selectors));\n    }\n    var objectKeys = Object.keys(selectors);\n    var resultSelector = selectorCreator(objectKeys.map(function(key) {\n        return selectors[key];\n    }), function() {\n        for(var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n            values[_key3] = arguments[_key3];\n        }\n        return values.reduce(function(composition, value, index) {\n            composition[objectKeys[index]] = value;\n            return composition;\n        }, {});\n    });\n    return resultSelector;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9ub2RlX21vZHVsZXMvcmVzZWxlY3QvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXdFO0FBQ3hCO0FBRWhELFNBQVNFLGdCQUFnQkMsS0FBSztJQUM1QixJQUFJQyxlQUFlQyxNQUFNQyxPQUFPLENBQUNILEtBQUssQ0FBQyxFQUFFLElBQUlBLEtBQUssQ0FBQyxFQUFFLEdBQUdBO0lBRXhELElBQUksQ0FBQ0MsYUFBYUcsS0FBSyxDQUFDLFNBQVVDLEdBQUc7UUFDbkMsT0FBTyxPQUFPQSxRQUFRO0lBQ3hCLElBQUk7UUFDRixJQUFJQyxrQkFBa0JMLGFBQWFNLEdBQUcsQ0FBQyxTQUFVRixHQUFHO1lBQ2xELE9BQU8sT0FBT0EsUUFBUSxhQUFhLGNBQWVBLENBQUFBLElBQUlHLElBQUksSUFBSSxTQUFRLElBQUssT0FBTyxPQUFPSDtRQUMzRixHQUFHSSxJQUFJLENBQUM7UUFDUixNQUFNLElBQUlDLE1BQU0sb0dBQW9HSixrQkFBa0I7SUFDeEk7SUFFQSxPQUFPTDtBQUNUO0FBRU8sU0FBU1Usc0JBQXNCQyxPQUFPO0lBQzNDLElBQUssSUFBSUMsT0FBT0MsVUFBVUMsTUFBTSxFQUFFQyx5QkFBeUIsSUFBSWQsTUFBTVcsT0FBTyxJQUFJQSxPQUFPLElBQUksSUFBSUksT0FBTyxHQUFHQSxPQUFPSixNQUFNSSxPQUFRO1FBQzVIRCxzQkFBc0IsQ0FBQ0MsT0FBTyxFQUFFLEdBQUdILFNBQVMsQ0FBQ0csS0FBSztJQUNwRDtJQUVBLElBQUlDLGlCQUFpQixTQUFTQTtRQUM1QixJQUFLLElBQUlDLFFBQVFMLFVBQVVDLE1BQU0sRUFBRWYsUUFBUSxJQUFJRSxNQUFNaUIsUUFBUUMsUUFBUSxHQUFHQSxRQUFRRCxPQUFPQyxRQUFTO1lBQzlGcEIsS0FBSyxDQUFDb0IsTUFBTSxHQUFHTixTQUFTLENBQUNNLE1BQU07UUFDakM7UUFFQSxJQUFJQyxrQkFBa0I7UUFFdEIsSUFB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QU9FLE1BQU0sQ0FBQyxTQUFVQyxXQUFXLEVBQUVDLEtBQUssRUFBRUMsS0FBSztZQUN0REYsV0FBVyxDQUFDUixVQUFVLENBQUNVLE1BQU0sQ0FBQyxHQUFHRDtZQUNqQyxPQUFPRDtRQUNULEdBQUcsQ0FBQztJQUNOO0lBQ0EsT0FBT047QUFDVCxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXVsdGl2ZXJzeC1kYXBwLy4vbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L2VzL2luZGV4LmpzPzg1M2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmYXVsdE1lbW9pemUsIGRlZmF1bHRFcXVhbGl0eUNoZWNrIH0gZnJvbSAnLi9kZWZhdWx0TWVtb2l6ZSc7XG5leHBvcnQgeyBkZWZhdWx0TWVtb2l6ZSwgZGVmYXVsdEVxdWFsaXR5Q2hlY2sgfTtcblxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzKGZ1bmNzKSB7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSBBcnJheS5pc0FycmF5KGZ1bmNzWzBdKSA/IGZ1bmNzWzBdIDogZnVuY3M7XG5cbiAgaWYgKCFkZXBlbmRlbmNpZXMuZXZlcnkoZnVuY3Rpb24gKGRlcCkge1xuICAgIHJldHVybiB0eXBlb2YgZGVwID09PSAnZnVuY3Rpb24nO1xuICB9KSkge1xuICAgIHZhciBkZXBlbmRlbmN5VHlwZXMgPSBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZGVwID09PSAnZnVuY3Rpb24nID8gXCJmdW5jdGlvbiBcIiArIChkZXAubmFtZSB8fCAndW5uYW1lZCcpICsgXCIoKVwiIDogdHlwZW9mIGRlcDtcbiAgICB9KS5qb2luKCcsICcpO1xuICAgIHRocm93IG5ldyBFcnJvcihcImNyZWF0ZVNlbGVjdG9yIGV4cGVjdHMgYWxsIGlucHV0LXNlbGVjdG9ycyB0byBiZSBmdW5jdGlvbnMsIGJ1dCByZWNlaXZlZCB0aGUgZm9sbG93aW5nIHR5cGVzOiBbXCIgKyBkZXBlbmRlbmN5VHlwZXMgKyBcIl1cIik7XG4gIH1cblxuICByZXR1cm4gZGVwZW5kZW5jaWVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKG1lbW9pemUpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1lbW9pemVPcHRpb25zRnJvbUFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1lbW9pemVPcHRpb25zRnJvbUFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGNyZWF0ZVNlbGVjdG9yID0gZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3IoKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgZnVuY3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICB2YXIgX3JlY29tcHV0YXRpb25zID0gMDtcblxuICAgIHZhciBfbGFzdFJlc3VsdDsgLy8gRHVlIHRvIHRoZSBpbnRyaWNhY2llcyBvZiByZXN0IHBhcmFtcywgd2UgY2FuJ3QgZG8gYW4gb3B0aW9uYWwgYXJnIGFmdGVyIGAuLi5mdW5jc2AuXG4gICAgLy8gU28sIHN0YXJ0IGJ5IGRlY2xhcmluZyB0aGUgZGVmYXVsdCB2YWx1ZSBoZXJlLlxuICAgIC8vIChBbmQgeWVzLCB0aGUgd29yZHMgJ21lbW9pemUnIGFuZCAnb3B0aW9ucycgYXBwZWFyIHRvbyBtYW55IHRpbWVzIGluIHRoaXMgbmV4dCBzZXF1ZW5jZS4pXG5cblxuICAgIHZhciBkaXJlY3RseVBhc3NlZE9wdGlvbnMgPSB7XG4gICAgICBtZW1vaXplT3B0aW9uczogdW5kZWZpbmVkXG4gICAgfTsgLy8gTm9ybWFsbHksIHRoZSByZXN1bHQgZnVuYyBvciBcIm91dHB1dCBzZWxlY3RvclwiIGlzIHRoZSBsYXN0IGFyZ1xuXG4gICAgdmFyIHJlc3VsdEZ1bmMgPSBmdW5jcy5wb3AoKTsgLy8gSWYgdGhlIHJlc3VsdCBmdW5jIGlzIGFjdHVhbGx5IGFuIF9vYmplY3RfLCBhc3N1bWUgaXQncyBvdXIgb3B0aW9ucyBvYmplY3RcblxuICAgIGlmICh0eXBlb2YgcmVzdWx0RnVuYyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGRpcmVjdGx5UGFzc2VkT3B0aW9ucyA9IHJlc3VsdEZ1bmM7IC8vIGFuZCBwb3AgdGhlIHJlYWwgcmVzdWx0IGZ1bmMgb2ZmXG5cbiAgICAgIHJlc3VsdEZ1bmMgPSBmdW5jcy5wb3AoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlc3VsdEZ1bmMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNyZWF0ZVNlbGVjdG9yIGV4cGVjdHMgYW4gb3V0cHV0IGZ1bmN0aW9uIGFmdGVyIHRoZSBpbnB1dHMsIGJ1dCByZWNlaXZlZDogW1wiICsgdHlwZW9mIHJlc3VsdEZ1bmMgKyBcIl1cIik7XG4gICAgfSAvLyBEZXRlcm1pbmUgd2hpY2ggc2V0IG9mIG9wdGlvbnMgd2UncmUgdXNpbmcuIFByZWZlciBvcHRpb25zIHBhc3NlZCBkaXJlY3RseSxcbiAgICAvLyBidXQgZmFsbCBiYWNrIHRvIG9wdGlvbnMgZ2l2ZW4gdG8gY3JlYXRlU2VsZWN0b3JDcmVhdG9yLlxuXG5cbiAgICB2YXIgX2RpcmVjdGx5UGFzc2VkT3B0aW9uID0gZGlyZWN0bHlQYXNzZWRPcHRpb25zLFxuICAgICAgICBfZGlyZWN0bHlQYXNzZWRPcHRpb24yID0gX2RpcmVjdGx5UGFzc2VkT3B0aW9uLm1lbW9pemVPcHRpb25zLFxuICAgICAgICBtZW1vaXplT3B0aW9ucyA9IF9kaXJlY3RseVBhc3NlZE9wdGlvbjIgPT09IHZvaWQgMCA/IG1lbW9pemVPcHRpb25zRnJvbUFyZ3MgOiBfZGlyZWN0bHlQYXNzZWRPcHRpb24yOyAvLyBTaW1wbGlmeWluZyBhc3N1bXB0aW9uOiBpdCdzIHVubGlrZWx5IHRoYXQgdGhlIGZpcnN0IG9wdGlvbnMgYXJnIG9mIHRoZSBwcm92aWRlZCBtZW1vaXplclxuICAgIC8vIGlzIGFuIGFycmF5LiBJbiBtb3N0IGxpYnMgSSd2ZSBsb29rZWQgYXQsIGl0J3MgYW4gZXF1YWxpdHkgZnVuY3Rpb24gb3Igb3B0aW9ucyBvYmplY3QuXG4gICAgLy8gQmFzZWQgb24gdGhhdCwgaWYgYG1lbW9pemVPcHRpb25zYCBfaXNfIGFuIGFycmF5LCB3ZSBhc3N1bWUgaXQncyBhIGZ1bGxcbiAgICAvLyB1c2VyLXByb3ZpZGVkIGFycmF5IG9mIG9wdGlvbnMuIE90aGVyd2lzZSwgaXQgbXVzdCBiZSBqdXN0IHRoZSBfZmlyc3RfIGFyZywgYW5kIHNvXG4gICAgLy8gd2Ugd3JhcCBpdCBpbiBhbiBhcnJheSBzbyB3ZSBjYW4gYXBwbHkgaXQuXG5cbiAgICB2YXIgZmluYWxNZW1vaXplT3B0aW9ucyA9IEFycmF5LmlzQXJyYXkobWVtb2l6ZU9wdGlvbnMpID8gbWVtb2l6ZU9wdGlvbnMgOiBbbWVtb2l6ZU9wdGlvbnNdO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBnZXREZXBlbmRlbmNpZXMoZnVuY3MpO1xuICAgIHZhciBtZW1vaXplZFJlc3VsdEZ1bmMgPSBtZW1vaXplLmFwcGx5KHZvaWQgMCwgW2Z1bmN0aW9uIHJlY29tcHV0YXRpb25XcmFwcGVyKCkge1xuICAgICAgX3JlY29tcHV0YXRpb25zKys7IC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXG5cbiAgICAgIHJldHVybiByZXN1bHRGdW5jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfV0uY29uY2F0KGZpbmFsTWVtb2l6ZU9wdGlvbnMpKTsgLy8gSWYgYSBzZWxlY3RvciBpcyBjYWxsZWQgd2l0aCB0aGUgZXhhY3Qgc2FtZSBhcmd1bWVudHMgd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSBvdXIgZGVwZW5kZW5jaWVzIGFnYWluLlxuXG4gICAgdmFyIHNlbGVjdG9yID0gbWVtb2l6ZShmdW5jdGlvbiBkZXBlbmRlbmNpZXNDaGVja2VyKCkge1xuICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgdmFyIGxlbmd0aCA9IGRlcGVuZGVuY2llcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gYXBwbHkgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIGFuZCBtdXRhdGUgYSBsb2NhbCBsaXN0IG9mIHBhcmFtcyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcGFyYW1zLnB1c2goZGVwZW5kZW5jaWVzW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgfSAvLyBhcHBseSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgZm9yIHBlcmZvcm1hbmNlLlxuXG5cbiAgICAgIF9sYXN0UmVzdWx0ID0gbWVtb2l6ZWRSZXN1bHRGdW5jLmFwcGx5KG51bGwsIHBhcmFtcyk7XG4gICAgICByZXR1cm4gX2xhc3RSZXN1bHQ7XG4gICAgfSk7XG4gICAgT2JqZWN0LmFzc2lnbihzZWxlY3Rvciwge1xuICAgICAgcmVzdWx0RnVuYzogcmVzdWx0RnVuYyxcbiAgICAgIG1lbW9pemVkUmVzdWx0RnVuYzogbWVtb2l6ZWRSZXN1bHRGdW5jLFxuICAgICAgZGVwZW5kZW5jaWVzOiBkZXBlbmRlbmNpZXMsXG4gICAgICBsYXN0UmVzdWx0OiBmdW5jdGlvbiBsYXN0UmVzdWx0KCkge1xuICAgICAgICByZXR1cm4gX2xhc3RSZXN1bHQ7XG4gICAgICB9LFxuICAgICAgcmVjb21wdXRhdGlvbnM6IGZ1bmN0aW9uIHJlY29tcHV0YXRpb25zKCkge1xuICAgICAgICByZXR1cm4gX3JlY29tcHV0YXRpb25zO1xuICAgICAgfSxcbiAgICAgIHJlc2V0UmVjb21wdXRhdGlvbnM6IGZ1bmN0aW9uIHJlc2V0UmVjb21wdXRhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBfcmVjb21wdXRhdGlvbnMgPSAwO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZWxlY3RvcjtcbiAgfTsgLy8gQHRzLWlnbm9yZVxuXG5cbiAgcmV0dXJuIGNyZWF0ZVNlbGVjdG9yO1xufVxuZXhwb3J0IHZhciBjcmVhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqL2NyZWF0ZVNlbGVjdG9yQ3JlYXRvcihkZWZhdWx0TWVtb2l6ZSk7XG4vLyBNYW51YWwgZGVmaW5pdGlvbiBvZiBzdGF0ZSBhbmQgb3V0cHV0IGFyZ3VtZW50c1xuZXhwb3J0IHZhciBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3Ioc2VsZWN0b3JzLCBzZWxlY3RvckNyZWF0b3IpIHtcbiAgaWYgKHNlbGVjdG9yQ3JlYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgc2VsZWN0b3JDcmVhdG9yID0gY3JlYXRlU2VsZWN0b3I7XG4gIH1cblxuICBpZiAodHlwZW9mIHNlbGVjdG9ycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciBleHBlY3RzIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCAnICsgKFwid2hlcmUgZWFjaCBwcm9wZXJ0eSBpcyBhIHNlbGVjdG9yLCBpbnN0ZWFkIHJlY2VpdmVkIGEgXCIgKyB0eXBlb2Ygc2VsZWN0b3JzKSk7XG4gIH1cblxuICB2YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzKHNlbGVjdG9ycyk7XG4gIHZhciByZXN1bHRTZWxlY3RvciA9IHNlbGVjdG9yQ3JlYXRvciggLy8gQHRzLWlnbm9yZVxuICBvYmplY3RLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yc1trZXldO1xuICB9KSwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICB2YWx1ZXNbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoY29tcG9zaXRpb24sIHZhbHVlLCBpbmRleCkge1xuICAgICAgY29tcG9zaXRpb25bb2JqZWN0S2V5c1tpbmRleF1dID0gdmFsdWU7XG4gICAgICByZXR1cm4gY29tcG9zaXRpb247XG4gICAgfSwge30pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdFNlbGVjdG9yO1xufTsiXSwibmFtZXMiOlsiZGVmYXVsdE1lbW9pemUiLCJkZWZhdWx0RXF1YWxpdHlDaGVjayIsImdldERlcGVuZGVuY2llcyIsImZ1bmNzIiwiZGVwZW5kZW5jaWVzIiwiQXJyYXkiLCJpc0FycmF5IiwiZXZlcnkiLCJkZXAiLCJkZXBlbmRlbmN5VHlwZXMiLCJtYXAiLCJuYW1lIiwiam9pbiIsIkVycm9yIiwiY3JlYXRlU2VsZWN0b3JDcmVhdG9yIiwibWVtb2l6ZSIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJtZW1vaXplT3B0aW9uc0Zyb21BcmdzIiwiX2tleSIsImNyZWF0ZVNlbGVjdG9yIiwiX2xlbjIiLCJfa2V5MiIsIl9yZWNvbXB1dGF0aW9ucyIsIl9sYXN0UmVzdWx0IiwiZGlyZWN0bHlQYXNzZWRPcHRpb25zIiwibWVtb2l6ZU9wdGlvbnMiLCJ1bmRlZmluZWQiLCJyZXN1bHRGdW5jIiwicG9wIiwiX2RpcmVjdGx5UGFzc2VkT3B0aW9uIiwiX2RpcmVjdGx5UGFzc2VkT3B0aW9uMiIsImZpbmFsTWVtb2l6ZU9wdGlvbnMiLCJtZW1vaXplZFJlc3VsdEZ1bmMiLCJhcHBseSIsInJlY29tcHV0YXRpb25XcmFwcGVyIiwiY29uY2F0Iiwic2VsZWN0b3IiLCJkZXBlbmRlbmNpZXNDaGVja2VyIiwicGFyYW1zIiwiaSIsInB1c2giLCJPYmplY3QiLCJhc3NpZ24iLCJsYXN0UmVzdWx0IiwicmVjb21wdXRhdGlvbnMiLCJyZXNldFJlY29tcHV0YXRpb25zIiwiY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIiwic2VsZWN0b3JzIiwic2VsZWN0b3JDcmVhdG9yIiwib2JqZWN0S2V5cyIsImtleXMiLCJyZXN1bHRTZWxlY3RvciIsImtleSIsIl9sZW4zIiwidmFsdWVzIiwiX2tleTMiLCJyZWR1Y2UiLCJjb21wb3NpdGlvbiIsInZhbHVlIiwiaW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/node_modules/reselect/es/index.js\n");

/***/ })

};
;