"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/linkifyjs";
exports.ids = ["vendor-chunks/linkifyjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/linkifyjs/dist/linkify.es.js":
/*!***************************************************!*\
  !*** ./node_modules/linkifyjs/dist/linkify.es.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultiToken: () => (/* binding */ MultiToken),\n/* harmony export */   Options: () => (/* binding */ Options),\n/* harmony export */   State: () => (/* binding */ State),\n/* harmony export */   createTokenClass: () => (/* binding */ createTokenClass),\n/* harmony export */   find: () => (/* binding */ find),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   multi: () => (/* binding */ multi),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   regexp: () => (/* binding */ regexp),\n/* harmony export */   registerCustomProtocol: () => (/* binding */ registerCustomProtocol),\n/* harmony export */   registerPlugin: () => (/* binding */ registerPlugin),\n/* harmony export */   registerTokenPlugin: () => (/* binding */ registerTokenPlugin),\n/* harmony export */   reset: () => (/* binding */ reset),\n/* harmony export */   stringToArray: () => (/* binding */ stringToArray),\n/* harmony export */   test: () => (/* binding */ test),\n/* harmony export */   tokenize: () => (/* binding */ tokenize)\n/* harmony export */ });\n// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY\n// https://data.iana.org/TLD/tlds-alpha-by-domain.txt\nvar tlds = \"aaa aarp abarth abb abbott abbvie abc able abogado abudhabi ac academy accenture accountant accountants aco actor ad adac ads adult ae aeg aero aetna af afl africa ag agakhan agency ai aig airbus airforce airtel akdn al alfaromeo alibaba alipay allfinanz allstate ally alsace alstom am amazon americanexpress americanfamily amex amfam amica amsterdam analytics android anquan anz ao aol apartments app apple aq aquarelle ar arab aramco archi army arpa art arte as asda asia associates at athleta attorney au auction audi audible audio auspost author auto autos avianca aw aws ax axa az azure ba baby baidu banamex bananarepublic band bank bar barcelona barclaycard barclays barefoot bargains baseball basketball bauhaus bayern bb bbc bbt bbva bcg bcn bd be beats beauty beer bentley berlin best bestbuy bet bf bg bh bharti bi bible bid bike bing bingo bio biz bj black blackfriday blockbuster blog bloomberg blue bm bms bmw bn bnpparibas bo boats boehringer bofa bom bond boo book booking bosch bostik boston bot boutique box br bradesco bridgestone broadway broker brother brussels bs bt bugatti build builders business buy buzz bv bw by bz bzh ca cab cafe cal call calvinklein cam camera camp cancerresearch canon capetown capital capitalone car caravan cards care career careers cars casa case cash casino cat catering catholic cba cbn cbre cbs cc cd center ceo cern cf cfa cfd cg ch chanel channel charity chase chat cheap chintai christmas chrome church ci cipriani circle cisco citadel citi citic city cityeats ck cl claims cleaning click clinic clinique clothing cloud club clubmed cm cn co coach codes coffee college cologne com comcast commbank community company compare computer comsec condos construction consulting contact contractors cooking cookingchannel cool coop corsica country coupon coupons courses cpa cr credit creditcard creditunion cricket crown crs cruise cruises cu cuisinella cv cw cx cy cymru cyou cz dabur dad dance data date dating datsun day dclk dds de deal dealer deals degree delivery dell deloitte delta democrat dental dentist desi design dev dhl diamonds diet digital direct directory discount discover dish diy dj dk dm dnp do docs doctor dog domains dot download drive dtv dubai dunlop dupont durban dvag dvr dz earth eat ec eco edeka edu education ee eg email emerck energy engineer engineering enterprises epson equipment er ericsson erni es esq estate et etisalat eu eurovision eus events exchange expert exposed express extraspace fage fail fairwinds faith family fan fans farm farmers fashion fast fedex feedback ferrari ferrero fi fiat fidelity fido film final finance financial fire firestone firmdale fish fishing fit fitness fj fk flickr flights flir florist flowers fly fm fo foo food foodnetwork football ford forex forsale forum foundation fox fr free fresenius frl frogans frontdoor frontier ftr fujitsu fun fund furniture futbol fyi ga gal gallery gallo gallup game games gap garden gay gb gbiz gd gdn ge gea gent genting george gf gg ggee gh gi gift gifts gives giving gl glass gle global globo gm gmail gmbh gmo gmx gn godaddy gold goldpoint golf goo goodyear goog google gop got gov gp gq gr grainger graphics gratis green gripe grocery group gs gt gu guardian gucci guge guide guitars guru gw gy hair hamburg hangout haus hbo hdfc hdfcbank health healthcare help helsinki here hermes hgtv hiphop hisamitsu hitachi hiv hk hkt hm hn hockey holdings holiday homedepot homegoods homes homesense honda horse hospital host hosting hot hoteles hotels hotmail house how hr hsbc ht hu hughes hyatt hyundai ibm icbc ice icu id ie ieee ifm ikano il im imamat imdb immo immobilien in inc industries infiniti info ing ink institute insurance insure int international intuit investments io ipiranga iq ir irish is ismaili ist istanbul it itau itv jaguar java jcb je jeep jetzt jewelry jio jll jm jmp jnj jo jobs joburg jot joy jp jpmorgan jprs juegos juniper kaufen kddi ke kerryhotels kerrylogistics kerryproperties kfh kg kh ki kia kids kim kinder kindle kitchen kiwi km kn koeln komatsu kosher kp kpmg kpn kr krd kred kuokgroup kw ky kyoto kz la lacaixa lamborghini lamer lancaster lancia land landrover lanxess lasalle lat latino latrobe law lawyer lb lc lds lease leclerc lefrak legal lego lexus lgbt li lidl life lifeinsurance lifestyle lighting like lilly limited limo lincoln linde link lipsy live living lk llc llp loan loans locker locus loft lol london lotte lotto love lpl lplfinancial lr ls lt ltd ltda lu lundbeck luxe luxury lv ly ma macys madrid maif maison makeup man management mango map market marketing markets marriott marshalls maserati mattel mba mc mckinsey md me med media meet melbourne meme memorial men menu merckmsd mg mh miami microsoft mil mini mint mit mitsubishi mk ml mlb mls mm mma mn mo mobi mobile moda moe moi mom monash money monster mormon mortgage moscow moto motorcycles mov movie mp mq mr ms msd mt mtn mtr mu museum music mutual mv mw mx my mz na nab nagoya name natura navy nba nc ne nec net netbank netflix network neustar new news next nextdirect nexus nf nfl ng ngo nhk ni nico nike nikon ninja nissan nissay nl no nokia northwesternmutual norton now nowruz nowtv np nr nra nrw ntt nu nyc nz obi observer office okinawa olayan olayangroup oldnavy ollo om omega one ong onl online ooo open oracle orange org organic origins osaka otsuka ott ovh pa page panasonic paris pars partners parts party passagens pay pccw pe pet pf pfizer pg ph pharmacy phd philips phone photo photography photos physio pics pictet pictures pid pin ping pink pioneer pizza pk pl place play playstation plumbing plus pm pn pnc pohl poker politie porn post pr pramerica praxi press prime pro prod productions prof progressive promo properties property protection pru prudential ps pt pub pw pwc py qa qpon quebec quest racing radio re read realestate realtor realty recipes red redstone redumbrella rehab reise reisen reit reliance ren rent rentals repair report republican rest restaurant review reviews rexroth rich richardli ricoh ril rio rip ro rocher rocks rodeo rogers room rs rsvp ru rugby ruhr run rw rwe ryukyu sa saarland safe safety sakura sale salon samsclub samsung sandvik sandvikcoromant sanofi sap sarl sas save saxo sb sbi sbs sc sca scb schaeffler schmidt scholarships school schule schwarz science scot sd se search seat secure security seek select sener services ses seven sew sex sexy sfr sg sh shangrila sharp shaw shell shia shiksha shoes shop shopping shouji show showtime si silk sina singles site sj sk ski skin sky skype sl sling sm smart smile sn sncf so soccer social softbank software sohu solar solutions song sony soy spa space sport spot sr srl ss st stada staples star statebank statefarm stc stcgroup stockholm storage store stream studio study style su sucks supplies supply support surf surgery suzuki sv swatch swiss sx sy sydney systems sz tab taipei talk taobao target tatamotors tatar tattoo tax taxi tc tci td tdk team tech technology tel temasek tennis teva tf tg th thd theater theatre tiaa tickets tienda tiffany tips tires tirol tj tjmaxx tjx tk tkmaxx tl tm tmall tn to today tokyo tools top toray toshiba total tours town toyota toys tr trade trading training travel travelchannel travelers travelersinsurance trust trv tt tube tui tunes tushu tv tvs tw tz ua ubank ubs ug uk unicom university uno uol ups us uy uz va vacations vana vanguard vc ve vegas ventures verisign verm\\xf6gensberater verm\\xf6gensberatung versicherung vet vg vi viajes video vig viking villas vin vip virgin visa vision viva vivo vlaanderen vn vodka volkswagen volvo vote voting voto voyage vu vuelos wales walmart walter wang wanggou watch watches weather weatherchannel webcam weber website wed wedding weibo weir wf whoswho wien wiki williamhill win windows wine winners wme wolterskluwer woodside work works world wow ws wtc wtf xbox xerox xfinity xihuan xin xxx xyz yachts yahoo yamaxun yandex ye yodobashi yoga yokohama you youtube yt yun za zappos zara zero zip zm zone zuerich zw\".split(\" \"); // Internationalized domain names containing non-ASCII\nvar utlds = \"ελ ευ бг бел дети ею католик ком мкд мон москва онлайн орг рус рф сайт срб укр қаз հայ ישראל קום ابوظبي اتصالات ارامكو الاردن البحرين الجزائر السعودية العليان المغرب امارات ایران بارت بازار بيتك بھارت تونس سودان سورية شبكة عراق عرب عمان فلسطين قطر كاثوليك كوم مصر مليسيا موريتانيا موقع همراه پاکستان ڀارت कॉम नेट भारत भारतम् भारोत संगठन বাংলা ভারত ভাৰত ਭਾਰਤ ભારત ଭାରତ இந்தியா இலங்கை சிங்கப்பூர் భారత్ ಭಾರತ ഭാരതം ලංකා คอม ไทย ລາວ გე みんな アマゾン クラウド グーグル コム ストア セール ファッション ポイント 世界 中信 中国 中國 中文网 亚马逊 企业 佛山 信息 健康 八卦 公司 公益 台湾 台灣 商城 商店 商标 嘉里 嘉里大酒店 在线 大拿 天主教 娱乐 家電 广东 微博 慈善 我爱你 手机 招聘 政务 政府 新加坡 新闻 时尚 書籍 机构 淡马锡 游戏 澳門 点看 移动 组织机构 网址 网店 网站 网络 联通 诺基亚 谷歌 购物 通販 集团 電訊盈科 飞利浦 食品 餐厅 香格里拉 香港 닷넷 닷컴 삼성 한국\".split(\" \");\n/**\n * @template A\n * @template B\n * @param {A} target\n * @param {B} properties\n * @return {A & B}\n */ var assign = function assign(target, properties) {\n    for(var key in properties){\n        target[key] = properties[key];\n    }\n    return target;\n};\n/**\n * Finite State Machine generation utilities\n */ /**\n * @template T\n * @typedef {{ [group: string]: T[] }} Collections\n */ /**\n * @typedef {{ [group: string]: true }} Flags\n */ // Keys in scanner Collections instances\nvar numeric = \"numeric\";\nvar ascii = \"ascii\";\nvar alpha = \"alpha\";\nvar asciinumeric = \"asciinumeric\";\nvar alphanumeric = \"alphanumeric\";\nvar domain = \"domain\";\nvar emoji = \"emoji\";\nvar scheme = \"scheme\";\nvar slashscheme = \"slashscheme\";\nvar whitespace = \"whitespace\";\n/**\n * @template T\n * @param {string} name\n * @param {Collections<T>} groups to register in\n * @returns {T[]} Current list of tokens in the given collection\n */ function registerGroup(name, groups) {\n    if (!(name in groups)) {\n        groups[name] = [];\n    }\n    return groups[name];\n}\n/**\n * @template T\n * @param {T} t token to add\n * @param {Collections<T>} groups\n * @param {Flags} flags\n */ function addToGroups(t, flags, groups) {\n    if (flags[numeric]) {\n        flags[asciinumeric] = true;\n        flags[alphanumeric] = true;\n    }\n    if (flags[ascii]) {\n        flags[asciinumeric] = true;\n        flags[alpha] = true;\n    }\n    if (flags[asciinumeric]) {\n        flags[alphanumeric] = true;\n    }\n    if (flags[alpha]) {\n        flags[alphanumeric] = true;\n    }\n    if (flags[alphanumeric]) {\n        flags[domain] = true;\n    }\n    if (flags[emoji]) {\n        flags[domain] = true;\n    }\n    for(var k in flags){\n        var group = registerGroup(k, groups);\n        if (group.indexOf(t) < 0) {\n            group.push(t);\n        }\n    }\n}\n/**\n * @template T\n * @param {T} t token to check\n * @param {Collections<T>} groups\n * @returns {Flags} group flags that contain this token\n */ function flagsForToken(t, groups) {\n    var result = {};\n    for(var c in groups){\n        if (groups[c].indexOf(t) >= 0) {\n            result[c] = true;\n        }\n    }\n    return result;\n}\n/**\n * @template T\n * @typedef {null | T } Transition\n */ /**\n * Define a basic state machine state. j is the list of character transitions,\n * jr is the list of regex-match transitions, jd is the default state to\n * transition to t is the accepting token type, if any. If this is the terminal\n * state, then it does not emit a token.\n *\n * The template type T represents the type of the token this state accepts. This\n * should be a string (such as of the token exports in `text.js`) or a\n * MultiToken subclass (from `multi.js`)\n *\n * @template T\n * @param {T} [token] Token that this state emits\n */ function State(token) {\n    if (token === void 0) {\n        token = null;\n    }\n    // this.n = null; // DEBUG: State name\n    /** @type {{ [input: string]: State<T> }} j */ this.j = {}; // IMPLEMENTATION 1\n    // this.j = []; // IMPLEMENTATION 2\n    /** @type {[RegExp, State<T>][]} jr */ this.jr = [];\n    /** @type {?State<T>} jd */ this.jd = null;\n    /** @type {?T} t */ this.t = token;\n}\n/**\n * Scanner token groups\n * @type Collections<string>\n */ State.groups = {};\nState.prototype = {\n    accepts: function accepts() {\n        return !!this.t;\n    },\n    /**\n   * Follow an existing transition from the given input to the next state.\n   * Does not mutate.\n   * @param {string} input character or token type to transition on\n   * @returns {?State<T>} the next state, if any\n   */ go: function go(input) {\n        var state = this;\n        var nextState = state.j[input];\n        if (nextState) {\n            return nextState;\n        }\n        for(var i = 0; i < state.jr.length; i++){\n            var regex = state.jr[i][0];\n            var _nextState = state.jr[i][1]; // note: might be empty to prevent default jump\n            if (_nextState && regex.test(input)) {\n                return _nextState;\n            }\n        } // Nowhere left to jump! Return default, if any\n        return state.jd;\n    },\n    /**\n   * Whether the state has a transition for the given input. Set the second\n   * argument to true to only look for an exact match (and not a default or\n   * regular-expression-based transition)\n   * @param {string} input\n   * @param {boolean} exactOnly\n   */ has: function has(input, exactOnly) {\n        if (exactOnly === void 0) {\n            exactOnly = false;\n        }\n        return exactOnly ? input in this.j : !!this.go(input);\n    },\n    /**\n   * Short for \"transition all\"; create a transition from the array of items\n   * in the given list to the same final resulting state.\n   * @param {string | string[]} inputs Group of inputs to transition on\n   * @param {Transition<T> | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   */ ta: function ta(inputs, next, flags, groups) {\n        for(var i = 0; i < inputs.length; i++){\n            this.tt(inputs[i], next, flags, groups);\n        }\n    },\n    /**\n   * Short for \"take regexp transition\"; defines a transition for this state\n   * when it encounters a token which matches the given regular expression\n   * @param {RegExp} regexp Regular expression transition (populate first)\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */ tr: function tr(regexp, next, flags, groups) {\n        groups = groups || State.groups;\n        var nextState;\n        if (next && next.j) {\n            nextState = next;\n        } else {\n            // Token with maybe token groups\n            nextState = new State(next);\n            if (flags && groups) {\n                addToGroups(next, flags, groups);\n            }\n        }\n        this.jr.push([\n            regexp,\n            nextState\n        ]);\n        return nextState;\n    },\n    /**\n   * Short for \"take transitions\", will take as many sequential transitions as\n   * the length of the given input and returns the\n   * resulting final state.\n   * @param {string | string[]} input\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */ ts: function ts(input, next, flags, groups) {\n        var state = this;\n        var len = input.length;\n        if (!len) {\n            return state;\n        }\n        for(var i = 0; i < len - 1; i++){\n            state = state.tt(input[i]);\n        }\n        return state.tt(input[len - 1], next, flags, groups);\n    },\n    /**\n   * Short for \"take transition\", this is a method for building/working with\n   * state machines.\n   *\n   * If a state already exists for the given input, returns it.\n   *\n   * If a token is specified, that state will emit that token when reached by\n   * the linkify engine.\n   *\n   * If no state exists, it will be initialized with some default transitions\n   * that resemble existing default transitions.\n   *\n   * If a state is given for the second argument, that state will be\n   * transitioned to on the given input regardless of what that input\n   * previously did.\n   *\n   * Specify a token group flags to define groups that this token belongs to.\n   * The token will be added to corresponding entires in the given groups\n   * object.\n   *\n   * @param {string} input character, token type to transition on\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of groups\n   * @returns {State<T>} taken after the given input\n   */ tt: function tt(input, next, flags, groups) {\n        groups = groups || State.groups;\n        var state = this; // Check if existing state given, just a basic transition\n        if (next && next.j) {\n            state.j[input] = next;\n            return next;\n        }\n        var t = next; // Take the transition with the usual default mechanisms and use that as\n        // a template for creating the next state\n        var nextState, templateState = state.go(input);\n        if (templateState) {\n            nextState = new State();\n            assign(nextState.j, templateState.j);\n            nextState.jr.push.apply(nextState.jr, templateState.jr);\n            nextState.jd = templateState.jd;\n            nextState.t = templateState.t;\n        } else {\n            nextState = new State();\n        }\n        if (t) {\n            // Ensure newly token is in the same groups as the old token\n            if (groups) {\n                if (nextState.t && typeof nextState.t === \"string\") {\n                    var allFlags = assign(flagsForToken(nextState.t, groups), flags);\n                    addToGroups(t, allFlags, groups);\n                } else if (flags) {\n                    addToGroups(t, flags, groups);\n                }\n            }\n            nextState.t = t; // overwrite anything that was previously there\n        }\n        state.j[input] = nextState;\n        return nextState;\n    }\n}; // Helper functions to improve minification (not exported outside linkifyjs module)\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */ var ta = function ta(state, input, next, flags, groups) {\n    return state.ta(input, next, flags, groups);\n};\n/**\n * @template T\n * @param {State<T>} state\n * @param {RegExp} regexp\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */ var tr = function tr(state, regexp, next, flags, groups) {\n    return state.tr(regexp, next, flags, groups);\n};\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */ var ts = function ts(state, input, next, flags, groups) {\n    return state.ts(input, next, flags, groups);\n};\n/**\n * @template T\n * @param {State<T>} state\n * @param {string} input\n * @param {T | State<T>} [next]\n * @param {Collections<T>} [groups]\n * @param {Flags} [flags]\n */ var tt = function tt(state, input, next, flags, groups) {\n    return state.tt(input, next, flags, groups);\n};\n/******************************************************************************\nText Tokens\nIdentifiers for token outputs from the regexp scanner\n******************************************************************************/ // A valid web domain token\nvar WORD = \"WORD\"; // only contains a-z\nvar UWORD = \"UWORD\"; // contains letters other than a-z, used for IDN\n// Special case of word\nvar LOCALHOST = \"LOCALHOST\"; // Valid top-level domain, special case of WORD (see tlds.js)\nvar TLD = \"TLD\"; // Valid IDN TLD, special case of UWORD (see tlds.js)\nvar UTLD = \"UTLD\"; // The scheme portion of a web URI protocol. Supported types include: `mailto`,\n// `file`, and user-defined custom protocols. Limited to schemes that contain\n// only letters\nvar SCHEME = \"SCHEME\"; // Similar to SCHEME, except makes distinction for schemes that must always be\n// followed by `://`, not just `:`. Supported types include `http`, `https`,\n// `ftp`, `ftps`\nvar SLASH_SCHEME = \"SLASH_SCHEME\"; // Any sequence of digits 0-9\nvar NUM = \"NUM\"; // Any number of consecutive whitespace characters that are not newline\nvar WS = \"WS\"; // New line (unix style)\nvar NL$1 = \"NL\"; // \\n\n// Opening/closing bracket classes\nvar OPENBRACE = \"OPENBRACE\"; // {\nvar OPENBRACKET = \"OPENBRACKET\"; // [\nvar OPENANGLEBRACKET = \"OPENANGLEBRACKET\"; // <\nvar OPENPAREN = \"OPENPAREN\"; // (\nvar CLOSEBRACE = \"CLOSEBRACE\"; // }\nvar CLOSEBRACKET = \"CLOSEBRACKET\"; // ]\nvar CLOSEANGLEBRACKET = \"CLOSEANGLEBRACKET\"; // >\nvar CLOSEPAREN = \"CLOSEPAREN\"; // )\n// Various symbols\nvar AMPERSAND = \"AMPERSAND\"; // &\nvar APOSTROPHE = \"APOSTROPHE\"; // '\nvar ASTERISK = \"ASTERISK\"; // *\nvar AT = \"AT\"; // @\nvar BACKSLASH = \"BACKSLASH\"; // \\\nvar BACKTICK = \"BACKTICK\"; // `\nvar CARET = \"CARET\"; // ^\nvar COLON = \"COLON\"; // :\nvar COMMA = \"COMMA\"; // ,\nvar DOLLAR = \"DOLLAR\"; // $\nvar DOT = \"DOT\"; // .\nvar EQUALS = \"EQUALS\"; // =\nvar EXCLAMATION = \"EXCLAMATION\"; // !\nvar HYPHEN = \"HYPHEN\"; // -\nvar PERCENT = \"PERCENT\"; // %\nvar PIPE = \"PIPE\"; // |\nvar PLUS = \"PLUS\"; // +\nvar POUND = \"POUND\"; // #\nvar QUERY = \"QUERY\"; // ?\nvar QUOTE = \"QUOTE\"; // \"\nvar SEMI = \"SEMI\"; // ;\nvar SLASH = \"SLASH\"; // /\nvar TILDE = \"TILDE\"; // ~\nvar UNDERSCORE = \"UNDERSCORE\"; // _\n// Emoji symbol\nvar EMOJI$1 = \"EMOJI\"; // Default token - anything that is not one of the above\nvar SYM = \"SYM\";\nvar tk = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    WORD: WORD,\n    UWORD: UWORD,\n    LOCALHOST: LOCALHOST,\n    TLD: TLD,\n    UTLD: UTLD,\n    SCHEME: SCHEME,\n    SLASH_SCHEME: SLASH_SCHEME,\n    NUM: NUM,\n    WS: WS,\n    NL: NL$1,\n    OPENBRACE: OPENBRACE,\n    OPENBRACKET: OPENBRACKET,\n    OPENANGLEBRACKET: OPENANGLEBRACKET,\n    OPENPAREN: OPENPAREN,\n    CLOSEBRACE: CLOSEBRACE,\n    CLOSEBRACKET: CLOSEBRACKET,\n    CLOSEANGLEBRACKET: CLOSEANGLEBRACKET,\n    CLOSEPAREN: CLOSEPAREN,\n    AMPERSAND: AMPERSAND,\n    APOSTROPHE: APOSTROPHE,\n    ASTERISK: ASTERISK,\n    AT: AT,\n    BACKSLASH: BACKSLASH,\n    BACKTICK: BACKTICK,\n    CARET: CARET,\n    COLON: COLON,\n    COMMA: COMMA,\n    DOLLAR: DOLLAR,\n    DOT: DOT,\n    EQUALS: EQUALS,\n    EXCLAMATION: EXCLAMATION,\n    HYPHEN: HYPHEN,\n    PERCENT: PERCENT,\n    PIPE: PIPE,\n    PLUS: PLUS,\n    POUND: POUND,\n    QUERY: QUERY,\n    QUOTE: QUOTE,\n    SEMI: SEMI,\n    SLASH: SLASH,\n    TILDE: TILDE,\n    UNDERSCORE: UNDERSCORE,\n    EMOJI: EMOJI$1,\n    SYM: SYM\n});\n// Note that these two Unicode ones expand into a really big one with Babel\nvar ASCII_LETTER = /[a-z]/;\nvar LETTER = /(?:[A-Za-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088E\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7CA\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7D9\\uA7F2-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF40\\uDF42-\\uDF49\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDF70-\\uDF81\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC71\\uDC72\\uDC75\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEB0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDEE0-\\uDEF2\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE70-\\uDEBE\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD837[\\uDF00-\\uDF1E]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDE90-\\uDEAD\\uDEC0-\\uDEEB]|\\uD839[\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF38\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A])/; // Any Unicode character with letter data type\nvar EMOJI = /(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26A7\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5-\\uDED7\\uDEDD-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFC\\uDFE0-\\uDFEB\\uDFF0]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7C\\uDE80-\\uDE86\\uDE90-\\uDEAC\\uDEB0-\\uDEBA\\uDEC0-\\uDEC5\\uDED0-\\uDED9\\uDEE0-\\uDEE7\\uDEF0-\\uDEF6])/; // Any Unicode emoji character\nvar EMOJI_VARIATION$1 = /\\ufe0f/;\nvar DIGIT = /\\d/;\nvar SPACE = /\\s/;\nvar regexp = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ASCII_LETTER: ASCII_LETTER,\n    LETTER: LETTER,\n    EMOJI: EMOJI,\n    EMOJI_VARIATION: EMOJI_VARIATION$1,\n    DIGIT: DIGIT,\n    SPACE: SPACE\n});\n/**\n\tThe scanner provides an interface that takes a string of text as input, and\n\toutputs an array of tokens instances that can be used for easy URL parsing.\n*/ var NL = \"\\n\"; // New line character\nvar EMOJI_VARIATION = \"️\"; // Variation selector, follows heart and others\nvar EMOJI_JOINER = \"‍\"; // zero-width joiner\n/**\n * Scanner output token:\n * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')\n * - `v` is the value of the token (e.g., '123', '❤️', 'com')\n * - `s` is the start index of the token in the original string\n * - `e` is the end index of the token in the original string\n * @typedef {{t: string, v: string, s: number, e: number}} Token\n */ /**\n * @template T\n * @typedef {{ [collection: string]: T[] }} Collections\n */ /**\n * Initialize the scanner character-based state machine for the given start\n * state\n * @param {[string, boolean][]} customSchemes List of custom schemes, where each\n * item is a length-2 tuple with the first element set to the string scheme, and\n * the second element set to `true` if the `://` after the scheme is optional\n */ function init$2(customSchemes) {\n    var _tr, _tr2, _tr3, _tr4, _tt, _tr5;\n    if (customSchemes === void 0) {\n        customSchemes = [];\n    }\n    // Frequently used states (name argument removed during minification)\n    /** @type Collections<string> */ var groups = {}; // of tokens\n    State.groups = groups;\n    /** @type State<string> */ var Start = new State(); // States for special URL symbols that accept immediately after start\n    tt(Start, \"'\", APOSTROPHE);\n    tt(Start, \"{\", OPENBRACE);\n    tt(Start, \"[\", OPENBRACKET);\n    tt(Start, \"<\", OPENANGLEBRACKET);\n    tt(Start, \"(\", OPENPAREN);\n    tt(Start, \"}\", CLOSEBRACE);\n    tt(Start, \"]\", CLOSEBRACKET);\n    tt(Start, \">\", CLOSEANGLEBRACKET);\n    tt(Start, \")\", CLOSEPAREN);\n    tt(Start, \"&\", AMPERSAND);\n    tt(Start, \"*\", ASTERISK);\n    tt(Start, \"@\", AT);\n    tt(Start, \"`\", BACKTICK);\n    tt(Start, \"^\", CARET);\n    tt(Start, \":\", COLON);\n    tt(Start, \",\", COMMA);\n    tt(Start, \"$\", DOLLAR);\n    tt(Start, \".\", DOT);\n    tt(Start, \"=\", EQUALS);\n    tt(Start, \"!\", EXCLAMATION);\n    tt(Start, \"-\", HYPHEN);\n    tt(Start, \"%\", PERCENT);\n    tt(Start, \"|\", PIPE);\n    tt(Start, \"+\", PLUS);\n    tt(Start, \"#\", POUND);\n    tt(Start, \"?\", QUERY);\n    tt(Start, '\"', QUOTE);\n    tt(Start, \"/\", SLASH);\n    tt(Start, \";\", SEMI);\n    tt(Start, \"~\", TILDE);\n    tt(Start, \"_\", UNDERSCORE);\n    tt(Start, \"\\\\\", BACKSLASH);\n    var Num = tr(Start, DIGIT, NUM, (_tr = {}, _tr[numeric] = true, _tr));\n    tr(Num, DIGIT, Num); // State which emits a word token\n    var Word = tr(Start, ASCII_LETTER, WORD, (_tr2 = {}, _tr2[ascii] = true, _tr2));\n    tr(Word, ASCII_LETTER, Word); // Same as previous, but specific to non-fsm.ascii alphabet words\n    var UWord = tr(Start, LETTER, UWORD, (_tr3 = {}, _tr3[alpha] = true, _tr3));\n    tr(UWord, ASCII_LETTER); // Non-accepting\n    tr(UWord, LETTER, UWord); // Whitespace jumps\n    // Tokens of only non-newline whitespace are arbitrarily long\n    // If any whitespace except newline, more whitespace!\n    var Ws = tr(Start, SPACE, WS, (_tr4 = {}, _tr4[whitespace] = true, _tr4));\n    tt(Start, NL, NL$1, (_tt = {}, _tt[whitespace] = true, _tt));\n    tt(Ws, NL); // non-accepting state to avoid mixing whitespaces\n    tr(Ws, SPACE, Ws); // Emoji tokens. They are not grouped by the scanner except in cases where a\n    // zero-width joiner is present\n    var Emoji = tr(Start, EMOJI, EMOJI$1, (_tr5 = {}, _tr5[emoji] = true, _tr5));\n    tr(Emoji, EMOJI, Emoji);\n    tt(Emoji, EMOJI_VARIATION, Emoji); // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy\n    var EmojiJoiner = tt(Emoji, EMOJI_JOINER);\n    tr(EmojiJoiner, EMOJI, Emoji); // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy\n    // Generates states for top-level domains\n    // Note that this is most accurate when tlds are in alphabetical order\n    var wordjr = [\n        [\n            ASCII_LETTER,\n            Word\n        ]\n    ];\n    var uwordjr = [\n        [\n            ASCII_LETTER,\n            null\n        ],\n        [\n            LETTER,\n            UWord\n        ]\n    ];\n    for(var i = 0; i < tlds.length; i++){\n        fastts(Start, tlds[i], TLD, WORD, wordjr);\n    }\n    for(var _i = 0; _i < utlds.length; _i++){\n        fastts(Start, utlds[_i], UTLD, UWORD, uwordjr);\n    }\n    addToGroups(TLD, {\n        tld: true,\n        ascii: true\n    }, groups);\n    addToGroups(UTLD, {\n        utld: true,\n        alpha: true\n    }, groups); // Collect the states generated by different protocols. NOTE: If any new TLDs\n    // get added that are also protocols, set the token to be the same as the\n    // protocol to ensure parsing works as expected.\n    fastts(Start, \"file\", SCHEME, WORD, wordjr);\n    fastts(Start, \"mailto\", SCHEME, WORD, wordjr);\n    fastts(Start, \"http\", SLASH_SCHEME, WORD, wordjr);\n    fastts(Start, \"https\", SLASH_SCHEME, WORD, wordjr);\n    fastts(Start, \"ftp\", SLASH_SCHEME, WORD, wordjr);\n    fastts(Start, \"ftps\", SLASH_SCHEME, WORD, wordjr);\n    addToGroups(SCHEME, {\n        scheme: true,\n        ascii: true\n    }, groups);\n    addToGroups(SLASH_SCHEME, {\n        slashscheme: true,\n        ascii: true\n    }, groups); // Register custom schemes. Assumes each scheme is asciinumeric with hyphens\n    customSchemes = customSchemes.sort(function(a, b) {\n        return a[0] > b[0] ? 1 : -1;\n    });\n    for(var _i2 = 0; _i2 < customSchemes.length; _i2++){\n        var _ref, _ref2;\n        var sch = customSchemes[_i2][0];\n        var optionalSlashSlash = customSchemes[_i2][1];\n        var flags = optionalSlashSlash ? (_ref = {}, _ref[scheme] = true, _ref) : (_ref2 = {}, _ref2[slashscheme] = true, _ref2);\n        if (sch.indexOf(\"-\") >= 0) {\n            flags[domain] = true;\n        } else if (!ASCII_LETTER.test(sch)) {\n            flags[numeric] = true; // numbers only\n        } else if (DIGIT.test(sch)) {\n            flags[asciinumeric] = true;\n        } else {\n            flags[ascii] = true;\n        }\n        ts(Start, sch, sch, flags);\n    } // Localhost token\n    ts(Start, \"localhost\", LOCALHOST, {\n        ascii: true\n    }); // Set default transition for start state (some symbol)\n    Start.jd = new State(SYM);\n    return {\n        start: Start,\n        tokens: assign({\n            groups: groups\n        }, tk)\n    };\n}\n/**\n\tGiven a string, returns an array of TOKEN instances representing the\n\tcomposition of that string.\n\n\t@method run\n\t@param {State<string>} start scanner starting state\n\t@param {string} str input string to scan\n\t@return {Token[]} list of tokens, each with a type and value\n*/ function run$1(start, str) {\n    // State machine is not case sensitive, so input is tokenized in lowercased\n    // form (still returns regular case). Uses selective `toLowerCase` because\n    // lowercasing the entire string causes the length and character position to\n    // vary in some non-English strings with V8-based runtimes.\n    var iterable = stringToArray(str.replace(/[A-Z]/g, function(c) {\n        return c.toLowerCase();\n    }));\n    var charCount = iterable.length; // <= len if there are emojis, etc\n    var tokens = []; // return value\n    // cursor through the string itself, accounting for characters that have\n    // width with length 2 such as emojis\n    var cursor = 0; // Cursor through the array-representation of the string\n    var charCursor = 0; // Tokenize the string\n    while(charCursor < charCount){\n        var state = start;\n        var nextState = null;\n        var tokenLength = 0;\n        var latestAccepting = null;\n        var sinceAccepts = -1;\n        var charsSinceAccepts = -1;\n        while(charCursor < charCount && (nextState = state.go(iterable[charCursor]))){\n            state = nextState; // Keep track of the latest accepting state\n            if (state.accepts()) {\n                sinceAccepts = 0;\n                charsSinceAccepts = 0;\n                latestAccepting = state;\n            } else if (sinceAccepts >= 0) {\n                sinceAccepts += iterable[charCursor].length;\n                charsSinceAccepts++;\n            }\n            tokenLength += iterable[charCursor].length;\n            cursor += iterable[charCursor].length;\n            charCursor++;\n        } // Roll back to the latest accepting state\n        cursor -= sinceAccepts;\n        charCursor -= charsSinceAccepts;\n        tokenLength -= sinceAccepts; // No more jumps, just make a new token from the last accepting one\n        tokens.push({\n            t: latestAccepting.t,\n            // token type/name\n            v: str.slice(cursor - tokenLength, cursor),\n            // string value\n            s: cursor - tokenLength,\n            // start index\n            e: cursor // end index (excluding)\n        });\n    }\n    return tokens;\n}\n/**\n * Convert a String to an Array of characters, taking into account that some\n * characters like emojis take up two string indexes.\n *\n * Adapted from core-js (MIT license)\n * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js\n *\n * @function stringToArray\n * @param {string} str\n * @returns {string[]}\n */ function stringToArray(str) {\n    var result = [];\n    var len = str.length;\n    var index = 0;\n    while(index < len){\n        var first = str.charCodeAt(index);\n        var second = void 0;\n        var char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character\n         : str.slice(index, index + 2); // two-index characters\n        result.push(char);\n        index += char.length;\n    }\n    return result;\n}\n/**\n * Fast version of ts function for when transition defaults are well known\n * @param {State<string>} state\n * @param {string} input\n * @param {string} t\n * @param {string} defaultt\n * @param {[RegExp, State<string>][]} jr\n * @returns {State<string>}\n */ function fastts(state, input, t, defaultt, jr) {\n    var next;\n    var len = input.length;\n    for(var i = 0; i < len - 1; i++){\n        var char = input[i];\n        if (state.j[char]) {\n            next = state.j[char];\n        } else {\n            next = new State(defaultt);\n            next.jr = jr.slice();\n            state.j[char] = next;\n        }\n        state = next;\n    }\n    next = new State(t);\n    next.jr = jr.slice();\n    state.j[input[len - 1]] = next;\n    return next;\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\n/**\n * An object where each key is a valid DOM Event Name such as `click` or `focus`\n * and each value is an event handler function.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/Element#events\n * @typedef {?{ [event: string]: Function }} EventListeners\n */ /**\n * All formatted properties required to render a link, including `tagName`,\n * `attributes`, `content` and `eventListeners`.\n * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,\n * eventListeners: EventListeners }} IntermediateRepresentation\n */ /**\n * Specify either an object described by the template type `O` or a function.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `O`\n * @template O\n * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj\n */ /**\n * Specify either a function described by template type `F` or an object.\n *\n * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each\n * value should be a function with template type `F` that is called when the\n * corresponding link type is encountered.\n * @template F\n * @typedef {F | { [type: string]: F}} OptFn\n */ /**\n * Specify either a value with template type `V`, a function that returns `V` or\n * an object where each value resolves to `V`.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `V`\n *\n * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).\n * Each value should either have type `V` or a function that returns V. This\n * function similarly takes a string value and a token.\n *\n * Example valid types for `Opt<string>`:\n *\n * ```js\n * 'hello'\n * (value, type, token) => 'world'\n * { url: 'hello', email: (value, token) => 'world'}\n * ```\n * @template V\n * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt\n */ /**\n * See available options: https://linkify.js.org/docs/options.html\n * @typedef {{\n * \tdefaultProtocol?: string,\n *  events?: OptObj<EventListeners>,\n * \tformat?: Opt<string>,\n * \tformatHref?: Opt<string>,\n * \tnl2br?: boolean,\n * \ttagName?: Opt<any>,\n * \ttarget?: Opt<string>,\n * \trel?: Opt<string>,\n * \tvalidate?: Opt<boolean>,\n * \ttruncate?: Opt<number>,\n * \tclassName?: Opt<string>,\n * \tattributes?: OptObj<({ [attr: string]: any })>,\n *  ignoreTags?: string[],\n * \trender?: OptFn<((ir: IntermediateRepresentation) => any)>\n * }} Opts\n */ /**\n * @type Required<Opts>\n */ var defaults = {\n    defaultProtocol: \"http\",\n    events: null,\n    format: noop,\n    formatHref: noop,\n    nl2br: false,\n    tagName: \"a\",\n    target: null,\n    rel: null,\n    validate: true,\n    truncate: Infinity,\n    className: null,\n    attributes: null,\n    ignoreTags: [],\n    render: null\n};\n/**\n * Utility class for linkify interfaces to apply specified\n * {@link Opts formatting and rendering options}.\n *\n * @param {Opts | Options} [opts] Option value overrides.\n * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For\n *   internal use) default render function that determines how to generate an\n *   HTML element based on a link token's derived tagName, attributes and HTML.\n *   Similar to render option\n */ function Options(opts, defaultRender) {\n    if (defaultRender === void 0) {\n        defaultRender = null;\n    }\n    var o = assign({}, defaults);\n    if (opts) {\n        o = assign(o, opts instanceof Options ? opts.o : opts);\n    } // Ensure all ignored tags are uppercase\n    var ignoredTags = o.ignoreTags;\n    var uppercaseIgnoredTags = [];\n    for(var i = 0; i < ignoredTags.length; i++){\n        uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());\n    }\n    /** @protected */ this.o = o;\n    if (defaultRender) {\n        this.defaultRender = defaultRender;\n    }\n    this.ignoreTags = uppercaseIgnoredTags;\n}\nOptions.prototype = {\n    o: defaults,\n    /**\n   * @type string[]\n   */ ignoreTags: [],\n    /**\n   * @param {IntermediateRepresentation} ir\n   * @returns {any}\n   */ defaultRender: function defaultRender(ir) {\n        return ir;\n    },\n    /**\n   * Returns true or false based on whether a token should be displayed as a\n   * link based on the user options.\n   * @param {MultiToken} token\n   * @returns {boolean}\n   */ check: function check(token) {\n        return this.get(\"validate\", token.toString(), token);\n    },\n    // Private methods\n    /**\n   * Resolve an option's value based on the value of the option and the given\n   * params. If operator and token are specified and the target option is\n   * callable, automatically calls the function with the given argument.\n   * @template {keyof Opts} K\n   * @param {K} key Name of option to use\n   * @param {string} [operator] will be passed to the target option if it's a\n   * function. If not specified, RAW function value gets returned\n   * @param {MultiToken} [token] The token from linkify.tokenize\n   * @returns {Opts[K] | any}\n   */ get: function get(key, operator, token) {\n        var isCallable = operator != null;\n        var option = this.o[key];\n        if (!option) {\n            return option;\n        }\n        if (typeof option === \"object\") {\n            option = token.t in option ? option[token.t] : defaults[key];\n            if (typeof option === \"function\" && isCallable) {\n                option = option(operator, token);\n            }\n        } else if (typeof option === \"function\" && isCallable) {\n            option = option(operator, token.t, token);\n        }\n        return option;\n    },\n    /**\n   * @template {keyof Opts} L\n   * @param {L} key Name of options object to use\n   * @param {string} [operator]\n   * @param {MultiToken} [token]\n   * @returns {Opts[L] | any}\n   */ getObj: function getObj(key, operator, token) {\n        var obj = this.o[key];\n        if (typeof obj === \"function\" && operator != null) {\n            obj = obj(operator, token.t, token);\n        }\n        return obj;\n    },\n    /**\n   * Convert the given token to a rendered element that may be added to the\n   * calling-interface's DOM\n   * @param {MultiToken} token Token to render to an HTML element\n   * @returns {any} Render result; e.g., HTML string, DOM element, React\n   *   Component, etc.\n   */ render: function render(token) {\n        var ir = token.render(this); // intermediate representation\n        var renderFn = this.get(\"render\", null, token) || this.defaultRender;\n        return renderFn(ir, token.t, token);\n    }\n};\nfunction noop(val) {\n    return val;\n}\nvar options = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    defaults: defaults,\n    Options: Options,\n    assign: assign\n});\n/******************************************************************************\n\tMulti-Tokens\n\tTokens composed of arrays of TextTokens\n******************************************************************************/ /**\n * @param {string} value\n * @param {Token[]} tokens\n */ function MultiToken(value, tokens) {\n    this.t = \"token\";\n    this.v = value;\n    this.tk = tokens;\n}\n/**\n * Abstract class used for manufacturing tokens of text tokens. That is rather\n * than the value for a token being a small string of text, it's value an array\n * of text tokens.\n *\n * Used for grouping together URLs, emails, hashtags, and other potential\n * creations.\n * @class MultiToken\n * @property {string} t\n * @property {string} v\n * @property {Token[]} tk\n * @abstract\n */ MultiToken.prototype = {\n    isLink: false,\n    /**\n   * Return the string this token represents.\n   * @return {string}\n   */ toString: function toString() {\n        return this.v;\n    },\n    /**\n   * What should the value for this token be in the `href` HTML attribute?\n   * Returns the `.toString` value by default.\n   * @param {string} [scheme]\n   * @return {string}\n  */ toHref: function toHref(scheme) {\n        return this.toString();\n    },\n    /**\n   * @param {Options} options Formatting options\n   * @returns {string}\n   */ toFormattedString: function toFormattedString(options) {\n        var val = this.toString();\n        var truncate = options.get(\"truncate\", val, this);\n        var formatted = options.get(\"format\", val, this);\n        return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + \"…\" : formatted;\n    },\n    /**\n   *\n   * @param {Options} options\n   * @returns {string}\n   */ toFormattedHref: function toFormattedHref(options) {\n        return options.get(\"formatHref\", this.toHref(options.get(\"defaultProtocol\")), this);\n    },\n    /**\n   * The start index of this token in the original input string\n   * @returns {number}\n   */ startIndex: function startIndex() {\n        return this.tk[0].s;\n    },\n    /**\n   * The end index of this token in the original input string (up to this\n   * index but not including it)\n   * @returns {number}\n   */ endIndex: function endIndex() {\n        return this.tk[this.tk.length - 1].e;\n    },\n    /**\n  \tReturns an object  of relevant values for this token, which includes keys\n  \t* type - Kind of token ('url', 'email', etc.)\n  \t* value - Original text\n  \t* href - The value that should be added to the anchor tag's href\n  \t\tattribute\n  \t\t@method toObject\n  \t@param {string} [protocol] `'http'` by default\n  */ toObject: function toObject(protocol) {\n        if (protocol === void 0) {\n            protocol = defaults.defaultProtocol;\n        }\n        return {\n            type: this.t,\n            value: this.toString(),\n            isLink: this.isLink,\n            href: this.toHref(protocol),\n            start: this.startIndex(),\n            end: this.endIndex()\n        };\n    },\n    /**\n   *\n   * @param {Options} options Formatting option\n   */ toFormattedObject: function toFormattedObject(options) {\n        return {\n            type: this.t,\n            value: this.toFormattedString(options),\n            isLink: this.isLink,\n            href: this.toFormattedHref(options),\n            start: this.startIndex(),\n            end: this.endIndex()\n        };\n    },\n    /**\n   * Whether this token should be rendered as a link according to the given options\n   * @param {Options} options\n   * @returns {boolean}\n   */ validate: function validate(options) {\n        return options.get(\"validate\", this.toString(), this);\n    },\n    /**\n   * Return an object that represents how this link should be rendered.\n   * @param {Options} options Formattinng options\n   */ render: function render(options) {\n        var token = this;\n        var href = this.toFormattedHref(options);\n        var tagName = options.get(\"tagName\", href, token);\n        var content = this.toFormattedString(options);\n        var attributes = {};\n        var className = options.get(\"className\", href, token);\n        var target = options.get(\"target\", href, token);\n        var rel = options.get(\"rel\", href, token);\n        var attrs = options.getObj(\"attributes\", href, token);\n        var eventListeners = options.getObj(\"events\", href, token);\n        attributes.href = href;\n        if (className) {\n            attributes.class = className;\n        }\n        if (target) {\n            attributes.target = target;\n        }\n        if (rel) {\n            attributes.rel = rel;\n        }\n        if (attrs) {\n            assign(attributes, attrs);\n        }\n        return {\n            tagName: tagName,\n            attributes: attributes,\n            content: content,\n            eventListeners: eventListeners\n        };\n    }\n}; // Base token\n/**\n * Create a new token that can be emitted by the parser state machine\n * @param {string} type readable type of the token\n * @param {object} props properties to assign or override, including isLink = true or false\n * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class\n */ function createTokenClass(type, props) {\n    var Token = /*#__PURE__*/ function(_MultiToken) {\n        _inheritsLoose(Token, _MultiToken);\n        function Token(value, tokens) {\n            var _this;\n            _this = _MultiToken.call(this, value, tokens) || this;\n            _this.t = type;\n            return _this;\n        }\n        return Token;\n    }(MultiToken);\n    for(var p in props){\n        Token.prototype[p] = props[p];\n    }\n    Token.t = type;\n    return Token;\n}\n/**\n\tRepresents a list of tokens making up a valid email address\n*/ var Email = createTokenClass(\"email\", {\n    isLink: true,\n    toHref: function toHref() {\n        return \"mailto:\" + this.toString();\n    }\n});\n/**\n\tRepresents some plain text\n*/ var Text = createTokenClass(\"text\");\n/**\n\tMulti-linebreak token - represents a line break\n\t@class Nl\n*/ var Nl = createTokenClass(\"nl\");\n/**\n\tRepresents a list of text tokens making up a valid URL\n\t@class Url\n*/ var Url = createTokenClass(\"url\", {\n    isLink: true,\n    /**\n  \tLowercases relevant parts of the domain and adds the protocol if\n  \trequired. Note that this will not escape unsafe HTML characters in the\n  \tURL.\n  \t\t@param {string} [scheme] default scheme (e.g., 'https')\n  \t@return {string} the full href\n  */ toHref: function toHref(scheme) {\n        if (scheme === void 0) {\n            scheme = defaults.defaultProtocol;\n        }\n        // Check if already has a prefix scheme\n        return this.hasProtocol() ? this.v : scheme + \"://\" + this.v;\n    },\n    /**\n   * Check whether this URL token has a protocol\n   * @return {boolean}\n   */ hasProtocol: function hasProtocol() {\n        var tokens = this.tk;\n        return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;\n    }\n});\nvar multi = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    MultiToken: MultiToken,\n    Base: MultiToken,\n    createTokenClass: createTokenClass,\n    Email: Email,\n    Text: Text,\n    Nl: Nl,\n    Url: Url\n});\n/**\n\tNot exactly parser, more like the second-stage scanner (although we can\n\ttheoretically hotswap the code here with a real parser in the future... but\n\tfor a little URL-finding utility abstract syntax trees may be a little\n\toverkill).\n\n\tURL format: http://en.wikipedia.org/wiki/URI_scheme\n\tEmail format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in\n\treference)\n\n\t@module linkify\n\t@submodule parser\n\t@main run\n*/ var makeState = function makeState(arg) {\n    return new State(arg);\n};\n/**\n * Generate the parser multi token-based state machine\n * @param {{ groups: Collections<string> }} tokens\n */ function init$1(_ref) {\n    var groups = _ref.groups;\n    // Types of characters the URL can definitely end in\n    var qsAccepting = groups.domain.concat([\n        AMPERSAND,\n        ASTERISK,\n        AT,\n        BACKSLASH,\n        BACKTICK,\n        CARET,\n        DOLLAR,\n        EQUALS,\n        HYPHEN,\n        NUM,\n        PERCENT,\n        PIPE,\n        PLUS,\n        POUND,\n        SLASH,\n        SYM,\n        TILDE,\n        UNDERSCORE\n    ]); // Types of tokens that can follow a URL and be part of the query string\n    // but cannot be the very last characters\n    // Characters that cannot appear in the URL at all should be excluded\n    var qsNonAccepting = [\n        APOSTROPHE,\n        CLOSEANGLEBRACKET,\n        CLOSEBRACE,\n        CLOSEBRACKET,\n        CLOSEPAREN,\n        COLON,\n        COMMA,\n        DOT,\n        EXCLAMATION,\n        OPENANGLEBRACKET,\n        OPENBRACE,\n        OPENBRACKET,\n        OPENPAREN,\n        QUERY,\n        QUOTE,\n        SEMI\n    ]; // For addresses without the mailto prefix\n    // Tokens allowed in the localpart of the email\n    var localpartAccepting = [\n        AMPERSAND,\n        APOSTROPHE,\n        ASTERISK,\n        BACKSLASH,\n        BACKTICK,\n        CARET,\n        CLOSEBRACE,\n        DOLLAR,\n        EQUALS,\n        HYPHEN,\n        NUM,\n        OPENBRACE,\n        PERCENT,\n        PIPE,\n        PLUS,\n        POUND,\n        QUERY,\n        SLASH,\n        SYM,\n        TILDE,\n        UNDERSCORE\n    ]; // The universal starting state.\n    /**\n   * @type State<Token>\n   */ var Start = makeState();\n    var Localpart = tt(Start, TILDE); // Local part of the email address\n    ta(Localpart, localpartAccepting, Localpart);\n    ta(Localpart, groups.domain, Localpart);\n    var Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();\n    ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)\n    ta(Start, groups.scheme, Scheme); // e.g., 'mailto'\n    ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'\n    ta(Domain, localpartAccepting, Localpart);\n    ta(Domain, groups.domain, Domain);\n    var LocalpartAt = tt(Domain, AT); // Local part of the email address plus @\n    tt(Localpart, AT, LocalpartAt); // close to an email address now\n    var LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)\n    ta(LocalpartDot, localpartAccepting, Localpart);\n    ta(LocalpartDot, groups.domain, Localpart);\n    var EmailDomain = makeState();\n    ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name\n    ta(EmailDomain, groups.domain, EmailDomain);\n    var EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT\n    ta(EmailDomainDot, groups.domain, EmailDomain);\n    var Email$1 = makeState(Email); // Possible email address (could have more tlds)\n    ta(EmailDomainDot, groups.tld, Email$1);\n    ta(EmailDomainDot, groups.utld, Email$1);\n    tt(LocalpartAt, LOCALHOST, Email$1); // Hyphen can jump back to a domain name\n    var EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name\n    ta(EmailDomainHyphen, groups.domain, EmailDomain);\n    ta(Email$1, groups.domain, EmailDomain);\n    tt(Email$1, DOT, EmailDomainDot);\n    tt(Email$1, HYPHEN, EmailDomainHyphen); // Final possible email states\n    var EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)\n    /*const EmailColonPort = */ ta(EmailColon, groups.numeric, Email); // URL followed by colon and port numner\n    // Account for dots and hyphens. Hyphens are usually parts of domain names\n    // (but not TLDs)\n    var DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen\n    var DomainDot = tt(Domain, DOT); // domain followed by DOT\n    ta(DomainHyphen, groups.domain, Domain);\n    ta(DomainDot, localpartAccepting, Localpart);\n    ta(DomainDot, groups.domain, Domain);\n    var DomainDotTld = makeState(Url); // Simplest possible URL with no query string\n    ta(DomainDot, groups.tld, DomainDotTld);\n    ta(DomainDot, groups.utld, DomainDotTld);\n    ta(DomainDotTld, groups.domain, Domain);\n    ta(DomainDotTld, localpartAccepting, Localpart);\n    tt(DomainDotTld, DOT, DomainDot);\n    tt(DomainDotTld, HYPHEN, DomainHyphen);\n    tt(DomainDotTld, AT, LocalpartAt);\n    var DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)\n    var DomainDotTldColonPort = makeState(Url); // TLD followed by a port number\n    ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort); // Long URL with optional port and maybe query string\n    var Url$1 = makeState(Url); // URL with extra symbols at the end, followed by an opening bracket\n    var UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)\n    // Query strings\n    ta(Url$1, qsAccepting, Url$1);\n    ta(Url$1, qsNonAccepting, UrlNonaccept);\n    ta(UrlNonaccept, qsAccepting, Url$1);\n    ta(UrlNonaccept, qsNonAccepting, UrlNonaccept); // Become real URLs after `SLASH` or `COLON NUM SLASH`\n    // Here works with or without scheme:// prefix\n    tt(DomainDotTld, SLASH, Url$1);\n    tt(DomainDotTldColonPort, SLASH, Url$1); // Note that domains that begin with schemes are treated slighly differently\n    var UriPrefix = tt(Scheme, COLON); // e.g., 'mailto:' or 'http://'\n    var SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'\n    var SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'\n    tt(SlashSchemeColonSlash, SLASH, UriPrefix); // Scheme states can transition to domain states\n    ta(Scheme, groups.domain, Domain);\n    tt(Scheme, DOT, DomainDot);\n    tt(Scheme, HYPHEN, DomainHyphen);\n    ta(SlashScheme, groups.domain, Domain);\n    tt(SlashScheme, DOT, DomainDot);\n    tt(SlashScheme, HYPHEN, DomainHyphen); // Force URL with scheme prefix followed by anything sane\n    ta(UriPrefix, groups.domain, Url$1);\n    tt(UriPrefix, SLASH, Url$1); // URL, followed by an opening bracket\n    var UrlOpenbrace = tt(Url$1, OPENBRACE); // URL followed by {\n    var UrlOpenbracket = tt(Url$1, OPENBRACKET); // URL followed by [\n    var UrlOpenanglebracket = tt(Url$1, OPENANGLEBRACKET); // URL followed by <\n    var UrlOpenparen = tt(Url$1, OPENPAREN); // URL followed by (\n    tt(UrlNonaccept, OPENBRACE, UrlOpenbrace);\n    tt(UrlNonaccept, OPENBRACKET, UrlOpenbracket);\n    tt(UrlNonaccept, OPENANGLEBRACKET, UrlOpenanglebracket);\n    tt(UrlNonaccept, OPENPAREN, UrlOpenparen); // Closing bracket component. This character WILL be included in the URL\n    tt(UrlOpenbrace, CLOSEBRACE, Url$1);\n    tt(UrlOpenbracket, CLOSEBRACKET, Url$1);\n    tt(UrlOpenanglebracket, CLOSEANGLEBRACKET, Url$1);\n    tt(UrlOpenparen, CLOSEPAREN, Url$1);\n    tt(UrlOpenbrace, CLOSEBRACE, Url$1); // URL that beings with an opening bracket, followed by a symbols.\n    // Note that the final state can still be `UrlOpenbrace` (if the URL only\n    // has a single opening bracket for some reason).\n    var UrlOpenbraceQ = makeState(Url); // URL followed by { and some symbols that the URL can end it\n    var UrlOpenbracketQ = makeState(Url); // URL followed by [ and some symbols that the URL can end it\n    var UrlOpenanglebracketQ = makeState(Url); // URL followed by < and some symbols that the URL can end it\n    var UrlOpenparenQ = makeState(Url); // URL followed by ( and some symbols that the URL can end it\n    ta(UrlOpenbrace, qsAccepting, UrlOpenbraceQ);\n    ta(UrlOpenbracket, qsAccepting, UrlOpenbracketQ);\n    ta(UrlOpenanglebracket, qsAccepting, UrlOpenanglebracketQ);\n    ta(UrlOpenparen, qsAccepting, UrlOpenparenQ);\n    var UrlOpenbraceSyms = makeState(); // UrlOpenbrace followed by some symbols it cannot end it\n    var UrlOpenbracketSyms = makeState(); // UrlOpenbracketQ followed by some symbols it cannot end it\n    var UrlOpenanglebracketSyms = makeState(); // UrlOpenanglebracketQ followed by some symbols it cannot end it\n    var UrlOpenparenSyms = makeState(); // UrlOpenparenQ followed by some symbols it cannot end it\n    ta(UrlOpenbrace, qsNonAccepting);\n    ta(UrlOpenbracket, qsNonAccepting);\n    ta(UrlOpenanglebracket, qsNonAccepting);\n    ta(UrlOpenparen, qsNonAccepting); // URL that begins with an opening bracket, followed by some symbols\n    ta(UrlOpenbraceQ, qsAccepting, UrlOpenbraceQ);\n    ta(UrlOpenbracketQ, qsAccepting, UrlOpenbracketQ);\n    ta(UrlOpenanglebracketQ, qsAccepting, UrlOpenanglebracketQ);\n    ta(UrlOpenparenQ, qsAccepting, UrlOpenparenQ);\n    ta(UrlOpenbraceQ, qsNonAccepting, UrlOpenbraceQ);\n    ta(UrlOpenbracketQ, qsNonAccepting, UrlOpenbracketQ);\n    ta(UrlOpenanglebracketQ, qsNonAccepting, UrlOpenanglebracketQ);\n    ta(UrlOpenparenQ, qsNonAccepting, UrlOpenparenQ);\n    ta(UrlOpenbraceSyms, qsAccepting, UrlOpenbraceSyms);\n    ta(UrlOpenbracketSyms, qsAccepting, UrlOpenbracketQ);\n    ta(UrlOpenanglebracketSyms, qsAccepting, UrlOpenanglebracketQ);\n    ta(UrlOpenparenSyms, qsAccepting, UrlOpenparenQ);\n    ta(UrlOpenbraceSyms, qsNonAccepting, UrlOpenbraceSyms);\n    ta(UrlOpenbracketSyms, qsNonAccepting, UrlOpenbracketSyms);\n    ta(UrlOpenanglebracketSyms, qsNonAccepting, UrlOpenanglebracketSyms);\n    ta(UrlOpenparenSyms, qsNonAccepting, UrlOpenparenSyms); // Close brace/bracket to become regular URL\n    tt(UrlOpenbracketQ, CLOSEBRACKET, Url$1);\n    tt(UrlOpenanglebracketQ, CLOSEANGLEBRACKET, Url$1);\n    tt(UrlOpenparenQ, CLOSEPAREN, Url$1);\n    tt(UrlOpenbraceQ, CLOSEBRACE, Url$1);\n    tt(UrlOpenbracketSyms, CLOSEBRACKET, Url$1);\n    tt(UrlOpenanglebracketSyms, CLOSEANGLEBRACKET, Url$1);\n    tt(UrlOpenparenSyms, CLOSEPAREN, Url$1);\n    tt(UrlOpenbraceSyms, CLOSEPAREN, Url$1);\n    tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state\n    tt(Start, NL$1, Nl); // single new line\n    return {\n        start: Start,\n        tokens: tk\n    };\n}\n/**\n * Run the parser state machine on a list of scanned string-based tokens to\n * create a list of multi tokens, each of which represents a URL, email address,\n * plain text, etc.\n *\n * @param {State<MultiToken>} start parser start state\n * @param {string} input the original input used to generate the given tokens\n * @param {Token[]} tokens list of scanned tokens\n * @returns {MultiToken[]}\n */ function run(start, input, tokens) {\n    var len = tokens.length;\n    var cursor = 0;\n    var multis = [];\n    var textTokens = [];\n    while(cursor < len){\n        var state = start;\n        var secondState = null;\n        var nextState = null;\n        var multiLength = 0;\n        var latestAccepting = null;\n        var sinceAccepts = -1;\n        while(cursor < len && !(secondState = state.go(tokens[cursor].t))){\n            // Starting tokens with nowhere to jump to.\n            // Consider these to be just plain text\n            textTokens.push(tokens[cursor++]);\n        }\n        while(cursor < len && (nextState = secondState || state.go(tokens[cursor].t))){\n            // Get the next state\n            secondState = null;\n            state = nextState; // Keep track of the latest accepting state\n            if (state.accepts()) {\n                sinceAccepts = 0;\n                latestAccepting = state;\n            } else if (sinceAccepts >= 0) {\n                sinceAccepts++;\n            }\n            cursor++;\n            multiLength++;\n        }\n        if (sinceAccepts < 0) {\n            // No accepting state was found, part of a regular text token add\n            // the first text token to the text tokens array and try again from\n            // the next\n            cursor -= multiLength;\n            if (cursor < len) {\n                textTokens.push(tokens[cursor]);\n                cursor++;\n            }\n        } else {\n            // Accepting state!\n            // First close off the textTokens (if available)\n            if (textTokens.length > 0) {\n                multis.push(initMultiToken(Text, input, textTokens));\n                textTokens = [];\n            } // Roll back to the latest accepting state\n            cursor -= sinceAccepts;\n            multiLength -= sinceAccepts; // Create a new multitoken\n            var Multi = latestAccepting.t;\n            var subtokens = tokens.slice(cursor - multiLength, cursor);\n            multis.push(initMultiToken(Multi, input, subtokens));\n        }\n    } // Finally close off the textTokens (if available)\n    if (textTokens.length > 0) {\n        multis.push(initMultiToken(Text, input, textTokens));\n    }\n    return multis;\n}\n/**\n * Utility function for instantiating a new multitoken with all the relevant\n * fields during parsing.\n * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate\n * @param {string} input original input string\n * @param {Token[]} tokens consecutive tokens scanned from input string\n * @returns {MultiToken}\n */ function initMultiToken(Multi, input, tokens) {\n    var startIdx = tokens[0].s;\n    var endIdx = tokens[tokens.length - 1].e;\n    var value = input.slice(startIdx, endIdx);\n    return new Multi(value, tokens);\n}\nvar warn = typeof console !== \"undefined\" && console && console.warn || function() {};\nvar warnAdvice = \"To avoid this warning, please register all custom schemes before invoking linkify the first time.\"; // Side-effect initialization state\nvar INIT = {\n    scanner: null,\n    parser: null,\n    tokenQueue: [],\n    pluginQueue: [],\n    customSchemes: [],\n    initialized: false\n};\n/**\n * @typedef {{\n * \tstart: State<string>,\n * \ttokens: { groups: Collections<string> } & typeof tk\n * }} ScannerInit\n */ /**\n * @typedef {{\n * \tstart: State<MultiToken>,\n * \ttokens: typeof multi\n * }} ParserInit\n */ /**\n * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin\n */ /**\n * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin\n */ /**\n * De-register all plugins and reset the internal state-machine. Used for\n * testing; not required in practice.\n * @private\n */ function reset() {\n    State.groups = {};\n    INIT.scanner = null;\n    INIT.parser = null;\n    INIT.tokenQueue = [];\n    INIT.pluginQueue = [];\n    INIT.customSchemes = [];\n    INIT.initialized = false;\n}\n/**\n * Register a token plugin to allow the scanner to recognize additional token\n * types before the parser state machine is constructed from the results.\n * @param {string} name of plugin to register\n * @param {TokenPlugin} plugin function that accepts the scanner state machine\n * and available scanner tokens and collections and extends the state machine to\n * recognize additional tokens or groups.\n */ function registerTokenPlugin(name, plugin) {\n    if (typeof plugin !== \"function\") {\n        throw new Error(\"linkifyjs: Invalid token plugin \" + plugin + \" (expects function)\");\n    }\n    for(var i = 0; i < INIT.tokenQueue.length; i++){\n        if (name === INIT.tokenQueue[i][0]) {\n            warn('linkifyjs: token plugin \"' + name + '\" already registered - will be overwritten');\n            INIT.tokenQueue[i] = [\n                name,\n                plugin\n            ];\n            return;\n        }\n    }\n    INIT.tokenQueue.push([\n        name,\n        plugin\n    ]);\n    if (INIT.initialized) {\n        warn('linkifyjs: already initialized - will not register token plugin \"' + name + '\" until you manually call linkify.init(). ' + warnAdvice);\n    }\n}\n/**\n * Register a linkify plugin\n * @param {string} name of plugin to register\n * @param {Plugin} plugin function that accepts the parser state machine and\n * extends the parser to recognize additional link types\n */ function registerPlugin(name, plugin) {\n    if (typeof plugin !== \"function\") {\n        throw new Error(\"linkifyjs: Invalid plugin \" + plugin + \" (expects function)\");\n    }\n    for(var i = 0; i < INIT.pluginQueue.length; i++){\n        if (name === INIT.pluginQueue[i][0]) {\n            warn('linkifyjs: plugin \"' + name + '\" already registered - will be overwritten');\n            INIT.pluginQueue[i] = [\n                name,\n                plugin\n            ];\n            return;\n        }\n    }\n    INIT.pluginQueue.push([\n        name,\n        plugin\n    ]);\n    if (INIT.initialized) {\n        warn('linkifyjs: already initialized - will not register plugin \"' + name + '\" until you manually call linkify.init(). ' + warnAdvice);\n    }\n}\n/**\n * Detect URLs with the following additional protocol. Anything with format\n * \"protocol://...\" will be considered a link. If `optionalSlashSlash` is set to\n * `true`, anything with format \"protocol:...\" will be considered a link.\n * @param {string} protocol\n * @param {boolean} [optionalSlashSlash]\n */ function registerCustomProtocol(scheme, optionalSlashSlash) {\n    if (optionalSlashSlash === void 0) {\n        optionalSlashSlash = false;\n    }\n    if (INIT.initialized) {\n        warn('linkifyjs: already initialized - will not register custom scheme \"' + scheme + '\" until you manually call linkify.init(). ' + warnAdvice);\n    }\n    if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {\n        throw new Error('linkifyjs: incorrect scheme format.\\n 1. Must only contain digits, lowercase ASCII letters or \"-\"\\n 2. Cannot start or end with \"-\"\\n 3. \"-\" cannot repeat');\n    }\n    INIT.customSchemes.push([\n        scheme,\n        optionalSlashSlash\n    ]);\n}\n/**\n * Initialize the linkify state machine. Called automatically the first time\n * linkify is called on a string, but may be called manually as well.\n */ function init() {\n    // Initialize scanner state machine and plugins\n    INIT.scanner = init$2(INIT.customSchemes);\n    for(var i = 0; i < INIT.tokenQueue.length; i++){\n        INIT.tokenQueue[i][1]({\n            scanner: INIT.scanner\n        });\n    } // Initialize parser state machine and plugins\n    INIT.parser = init$1(INIT.scanner.tokens);\n    for(var _i = 0; _i < INIT.pluginQueue.length; _i++){\n        INIT.pluginQueue[_i][1]({\n            scanner: INIT.scanner,\n            parser: INIT.parser\n        });\n    }\n    INIT.initialized = true;\n}\n/**\n * Parse a string into tokens that represent linkable and non-linkable sub-components\n * @param {string} str\n * @return {MultiToken[]} tokens\n */ function tokenize(str) {\n    if (!INIT.initialized) {\n        init();\n    }\n    return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));\n}\n/**\n * Find a list of linkable items in the given string.\n * @param {string} str string to find links in\n * @param {string | Opts} [type] either formatting options or specific type of\n * links to find, e.g., 'url' or 'email'\n * @param {Opts} [opts] formatting options for final output. Cannot be specified\n * if opts already provided in `type` argument\n*/ function find(str, type, opts) {\n    if (type === void 0) {\n        type = null;\n    }\n    if (opts === void 0) {\n        opts = null;\n    }\n    if (type && typeof type === \"object\") {\n        if (opts) {\n            throw Error(\"linkifyjs: Invalid link type \" + type + \"; must be a string\");\n        }\n        opts = type;\n        type = null;\n    }\n    var options = new Options(opts);\n    var tokens = tokenize(str);\n    var filtered = [];\n    for(var i = 0; i < tokens.length; i++){\n        var token = tokens[i];\n        if (token.isLink && (!type || token.t === type)) {\n            filtered.push(token.toFormattedObject(options));\n        }\n    }\n    return filtered;\n}\n/**\n * Is the given string valid linkable text of some sort. Note that this does not\n * trim the text for you.\n *\n * Optionally pass in a second `type` param, which is the type of link to test\n * for.\n *\n * For example,\n *\n *     linkify.test(str, 'email');\n *\n * Returns `true` if str is a valid email.\n * @param {string} str string to test for links\n * @param {string} [type] optional specific link type to look for\n * @returns boolean true/false\n */ function test(str, type) {\n    if (type === void 0) {\n        type = null;\n    }\n    var tokens = tokenize(str);\n    return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlua2lmeWpzL2Rpc3QvbGlua2lmeS5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNERBQTREO0FBQzVELHFEQUFxRDtBQUNyRCxJQUFJQSxPQUFPLHd5UEF1ekNQQyxLQUFLLENBQUMsTUFBTSxzREFBc0Q7QUFFdEUsSUFBSUMsUUFBUSw2cUJBc0pSRCxLQUFLLENBQUM7QUFFVjs7Ozs7O0NBTUMsR0FDRCxJQUFJRSxTQUFTLFNBQVNBLE9BQU9DLE1BQU0sRUFBRUMsVUFBVTtJQUM3QyxJQUFLLElBQUlDLE9BQU9ELFdBQVk7UUFDMUJELE1BQU0sQ0FBQ0UsSUFBSSxHQUFHRCxVQUFVLENBQUNDLElBQUk7SUFDL0I7SUFFQSxPQUFPRjtBQUNUO0FBRUE7O0NBRUMsR0FDRDs7O0NBR0MsR0FFRDs7Q0FFQyxHQUNELHdDQUF3QztBQUV4QyxJQUFJRyxVQUFVO0FBQ2QsSUFBSUMsUUFBUTtBQUNaLElBQUlDLFFBQVE7QUFDWixJQUFJQyxlQUFlO0FBQ25CLElBQUlDLGVBQWU7QUFDbkIsSUFBSUMsU0FBUztBQUNiLElBQUlDLFFBQVE7QUFDWixJQUFJQyxTQUFTO0FBQ2IsSUFBSUMsY0FBYztBQUNsQixJQUFJQyxhQUFhO0FBQ2pCOzs7OztDQUtDLEdBRUQsU0FBU0MsY0FBY0MsSUFBSSxFQUFFQyxNQUFNO0lBQ2pDLElBQUksQ0FBRUQsQ0FBQUEsUUFBUUMsTUFBSyxHQUFJO1FBQ3JCQSxNQUFNLENBQUNELEtBQUssR0FBRyxFQUFFO0lBQ25CO0lBRUEsT0FBT0MsTUFBTSxDQUFDRCxLQUFLO0FBQ3JCO0FBQ0E7Ozs7O0NBS0MsR0FHRCxTQUFTRSxZQUFZQyxDQUFDLEVBQUVDLEtBQUssRUFBRUgsTUFBTTtJQUNuQyxJQUFJRyxLQUFLLENBQUNmLFFBQVEsRUFBRTtRQUNsQmUsS0FBSyxDQUFDWixhQUFhLEdBQUc7UUFDdEJZLEtBQUssQ0FBQ1gsYUFBYSxHQUFHO0lBQ3hCO0lBRUEsSUFBSVcs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QUFLNE0sSUFBRztBQUNqRjtBQUUrTCIsInNvdXJjZXMiOlsid2VicGFjazovL211bHRpdmVyc3gtZGFwcC8uL25vZGVfbW9kdWxlcy9saW5raWZ5anMvZGlzdC9saW5raWZ5LmVzLmpzP2VkMjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVEhJUyBGSUxFIElTIEFVVE9NQVRJQ0FMTFkgR0VORVJBVEVEIERPIE5PVCBFRElUIERJUkVDVExZXG4vLyBodHRwczovL2RhdGEuaWFuYS5vcmcvVExEL3RsZHMtYWxwaGEtYnktZG9tYWluLnR4dFxudmFyIHRsZHMgPSAnYWFhIFxcXG5hYXJwIFxcXG5hYmFydGggXFxcbmFiYiBcXFxuYWJib3R0IFxcXG5hYmJ2aWUgXFxcbmFiYyBcXFxuYWJsZSBcXFxuYWJvZ2FkbyBcXFxuYWJ1ZGhhYmkgXFxcbmFjIFxcXG5hY2FkZW15IFxcXG5hY2NlbnR1cmUgXFxcbmFjY291bnRhbnQgXFxcbmFjY291bnRhbnRzIFxcXG5hY28gXFxcbmFjdG9yIFxcXG5hZCBcXFxuYWRhYyBcXFxuYWRzIFxcXG5hZHVsdCBcXFxuYWUgXFxcbmFlZyBcXFxuYWVybyBcXFxuYWV0bmEgXFxcbmFmIFxcXG5hZmwgXFxcbmFmcmljYSBcXFxuYWcgXFxcbmFnYWtoYW4gXFxcbmFnZW5jeSBcXFxuYWkgXFxcbmFpZyBcXFxuYWlyYnVzIFxcXG5haXJmb3JjZSBcXFxuYWlydGVsIFxcXG5ha2RuIFxcXG5hbCBcXFxuYWxmYXJvbWVvIFxcXG5hbGliYWJhIFxcXG5hbGlwYXkgXFxcbmFsbGZpbmFueiBcXFxuYWxsc3RhdGUgXFxcbmFsbHkgXFxcbmFsc2FjZSBcXFxuYWxzdG9tIFxcXG5hbSBcXFxuYW1hem9uIFxcXG5hbWVyaWNhbmV4cHJlc3MgXFxcbmFtZXJpY2FuZmFtaWx5IFxcXG5hbWV4IFxcXG5hbWZhbSBcXFxuYW1pY2EgXFxcbmFtc3RlcmRhbSBcXFxuYW5hbHl0aWNzIFxcXG5hbmRyb2lkIFxcXG5hbnF1YW4gXFxcbmFueiBcXFxuYW8gXFxcbmFvbCBcXFxuYXBhcnRtZW50cyBcXFxuYXBwIFxcXG5hcHBsZSBcXFxuYXEgXFxcbmFxdWFyZWxsZSBcXFxuYXIgXFxcbmFyYWIgXFxcbmFyYW1jbyBcXFxuYXJjaGkgXFxcbmFybXkgXFxcbmFycGEgXFxcbmFydCBcXFxuYXJ0ZSBcXFxuYXMgXFxcbmFzZGEgXFxcbmFzaWEgXFxcbmFzc29jaWF0ZXMgXFxcbmF0IFxcXG5hdGhsZXRhIFxcXG5hdHRvcm5leSBcXFxuYXUgXFxcbmF1Y3Rpb24gXFxcbmF1ZGkgXFxcbmF1ZGlibGUgXFxcbmF1ZGlvIFxcXG5hdXNwb3N0IFxcXG5hdXRob3IgXFxcbmF1dG8gXFxcbmF1dG9zIFxcXG5hdmlhbmNhIFxcXG5hdyBcXFxuYXdzIFxcXG5heCBcXFxuYXhhIFxcXG5heiBcXFxuYXp1cmUgXFxcbmJhIFxcXG5iYWJ5IFxcXG5iYWlkdSBcXFxuYmFuYW1leCBcXFxuYmFuYW5hcmVwdWJsaWMgXFxcbmJhbmQgXFxcbmJhbmsgXFxcbmJhciBcXFxuYmFyY2Vsb25hIFxcXG5iYXJjbGF5Y2FyZCBcXFxuYmFyY2xheXMgXFxcbmJhcmVmb290IFxcXG5iYXJnYWlucyBcXFxuYmFzZWJhbGwgXFxcbmJhc2tldGJhbGwgXFxcbmJhdWhhdXMgXFxcbmJheWVybiBcXFxuYmIgXFxcbmJiYyBcXFxuYmJ0IFxcXG5iYnZhIFxcXG5iY2cgXFxcbmJjbiBcXFxuYmQgXFxcbmJlIFxcXG5iZWF0cyBcXFxuYmVhdXR5IFxcXG5iZWVyIFxcXG5iZW50bGV5IFxcXG5iZXJsaW4gXFxcbmJlc3QgXFxcbmJlc3RidXkgXFxcbmJldCBcXFxuYmYgXFxcbmJnIFxcXG5iaCBcXFxuYmhhcnRpIFxcXG5iaSBcXFxuYmlibGUgXFxcbmJpZCBcXFxuYmlrZSBcXFxuYmluZyBcXFxuYmluZ28gXFxcbmJpbyBcXFxuYml6IFxcXG5iaiBcXFxuYmxhY2sgXFxcbmJsYWNrZnJpZGF5IFxcXG5ibG9ja2J1c3RlciBcXFxuYmxvZyBcXFxuYmxvb21iZXJnIFxcXG5ibHVlIFxcXG5ibSBcXFxuYm1zIFxcXG5ibXcgXFxcbmJuIFxcXG5ibnBwYXJpYmFzIFxcXG5ibyBcXFxuYm9hdHMgXFxcbmJvZWhyaW5nZXIgXFxcbmJvZmEgXFxcbmJvbSBcXFxuYm9uZCBcXFxuYm9vIFxcXG5ib29rIFxcXG5ib29raW5nIFxcXG5ib3NjaCBcXFxuYm9zdGlrIFxcXG5ib3N0b24gXFxcbmJvdCBcXFxuYm91dGlxdWUgXFxcbmJveCBcXFxuYnIgXFxcbmJyYWRlc2NvIFxcXG5icmlkZ2VzdG9uZSBcXFxuYnJvYWR3YXkgXFxcbmJyb2tlciBcXFxuYnJvdGhlciBcXFxuYnJ1c3NlbHMgXFxcbmJzIFxcXG5idCBcXFxuYnVnYXR0aSBcXFxuYnVpbGQgXFxcbmJ1aWxkZXJzIFxcXG5idXNpbmVzcyBcXFxuYnV5IFxcXG5idXp6IFxcXG5idiBcXFxuYncgXFxcbmJ5IFxcXG5ieiBcXFxuYnpoIFxcXG5jYSBcXFxuY2FiIFxcXG5jYWZlIFxcXG5jYWwgXFxcbmNhbGwgXFxcbmNhbHZpbmtsZWluIFxcXG5jYW0gXFxcbmNhbWVyYSBcXFxuY2FtcCBcXFxuY2FuY2VycmVzZWFyY2ggXFxcbmNhbm9uIFxcXG5jYXBldG93biBcXFxuY2FwaXRhbCBcXFxuY2FwaXRhbG9uZSBcXFxuY2FyIFxcXG5jYXJhdmFuIFxcXG5jYXJkcyBcXFxuY2FyZSBcXFxuY2FyZWVyIFxcXG5jYXJlZXJzIFxcXG5jYXJzIFxcXG5jYXNhIFxcXG5jYXNlIFxcXG5jYXNoIFxcXG5jYXNpbm8gXFxcbmNhdCBcXFxuY2F0ZXJpbmcgXFxcbmNhdGhvbGljIFxcXG5jYmEgXFxcbmNibiBcXFxuY2JyZSBcXFxuY2JzIFxcXG5jYyBcXFxuY2QgXFxcbmNlbnRlciBcXFxuY2VvIFxcXG5jZXJuIFxcXG5jZiBcXFxuY2ZhIFxcXG5jZmQgXFxcbmNnIFxcXG5jaCBcXFxuY2hhbmVsIFxcXG5jaGFubmVsIFxcXG5jaGFyaXR5IFxcXG5jaGFzZSBcXFxuY2hhdCBcXFxuY2hlYXAgXFxcbmNoaW50YWkgXFxcbmNocmlzdG1hcyBcXFxuY2hyb21lIFxcXG5jaHVyY2ggXFxcbmNpIFxcXG5jaXByaWFuaSBcXFxuY2lyY2xlIFxcXG5jaXNjbyBcXFxuY2l0YWRlbCBcXFxuY2l0aSBcXFxuY2l0aWMgXFxcbmNpdHkgXFxcbmNpdHllYXRzIFxcXG5jayBcXFxuY2wgXFxcbmNsYWltcyBcXFxuY2xlYW5pbmcgXFxcbmNsaWNrIFxcXG5jbGluaWMgXFxcbmNsaW5pcXVlIFxcXG5jbG90aGluZyBcXFxuY2xvdWQgXFxcbmNsdWIgXFxcbmNsdWJtZWQgXFxcbmNtIFxcXG5jbiBcXFxuY28gXFxcbmNvYWNoIFxcXG5jb2RlcyBcXFxuY29mZmVlIFxcXG5jb2xsZWdlIFxcXG5jb2xvZ25lIFxcXG5jb20gXFxcbmNvbWNhc3QgXFxcbmNvbW1iYW5rIFxcXG5jb21tdW5pdHkgXFxcbmNvbXBhbnkgXFxcbmNvbXBhcmUgXFxcbmNvbXB1dGVyIFxcXG5jb21zZWMgXFxcbmNvbmRvcyBcXFxuY29uc3RydWN0aW9uIFxcXG5jb25zdWx0aW5nIFxcXG5jb250YWN0IFxcXG5jb250cmFjdG9ycyBcXFxuY29va2luZyBcXFxuY29va2luZ2NoYW5uZWwgXFxcbmNvb2wgXFxcbmNvb3AgXFxcbmNvcnNpY2EgXFxcbmNvdW50cnkgXFxcbmNvdXBvbiBcXFxuY291cG9ucyBcXFxuY291cnNlcyBcXFxuY3BhIFxcXG5jciBcXFxuY3JlZGl0IFxcXG5jcmVkaXRjYXJkIFxcXG5jcmVkaXR1bmlvbiBcXFxuY3JpY2tldCBcXFxuY3Jvd24gXFxcbmNycyBcXFxuY3J1aXNlIFxcXG5jcnVpc2VzIFxcXG5jdSBcXFxuY3Vpc2luZWxsYSBcXFxuY3YgXFxcbmN3IFxcXG5jeCBcXFxuY3kgXFxcbmN5bXJ1IFxcXG5jeW91IFxcXG5jeiBcXFxuZGFidXIgXFxcbmRhZCBcXFxuZGFuY2UgXFxcbmRhdGEgXFxcbmRhdGUgXFxcbmRhdGluZyBcXFxuZGF0c3VuIFxcXG5kYXkgXFxcbmRjbGsgXFxcbmRkcyBcXFxuZGUgXFxcbmRlYWwgXFxcbmRlYWxlciBcXFxuZGVhbHMgXFxcbmRlZ3JlZSBcXFxuZGVsaXZlcnkgXFxcbmRlbGwgXFxcbmRlbG9pdHRlIFxcXG5kZWx0YSBcXFxuZGVtb2NyYXQgXFxcbmRlbnRhbCBcXFxuZGVudGlzdCBcXFxuZGVzaSBcXFxuZGVzaWduIFxcXG5kZXYgXFxcbmRobCBcXFxuZGlhbW9uZHMgXFxcbmRpZXQgXFxcbmRpZ2l0YWwgXFxcbmRpcmVjdCBcXFxuZGlyZWN0b3J5IFxcXG5kaXNjb3VudCBcXFxuZGlzY292ZXIgXFxcbmRpc2ggXFxcbmRpeSBcXFxuZGogXFxcbmRrIFxcXG5kbSBcXFxuZG5wIFxcXG5kbyBcXFxuZG9jcyBcXFxuZG9jdG9yIFxcXG5kb2cgXFxcbmRvbWFpbnMgXFxcbmRvdCBcXFxuZG93bmxvYWQgXFxcbmRyaXZlIFxcXG5kdHYgXFxcbmR1YmFpIFxcXG5kdW5sb3AgXFxcbmR1cG9udCBcXFxuZHVyYmFuIFxcXG5kdmFnIFxcXG5kdnIgXFxcbmR6IFxcXG5lYXJ0aCBcXFxuZWF0IFxcXG5lYyBcXFxuZWNvIFxcXG5lZGVrYSBcXFxuZWR1IFxcXG5lZHVjYXRpb24gXFxcbmVlIFxcXG5lZyBcXFxuZW1haWwgXFxcbmVtZXJjayBcXFxuZW5lcmd5IFxcXG5lbmdpbmVlciBcXFxuZW5naW5lZXJpbmcgXFxcbmVudGVycHJpc2VzIFxcXG5lcHNvbiBcXFxuZXF1aXBtZW50IFxcXG5lciBcXFxuZXJpY3Nzb24gXFxcbmVybmkgXFxcbmVzIFxcXG5lc3EgXFxcbmVzdGF0ZSBcXFxuZXQgXFxcbmV0aXNhbGF0IFxcXG5ldSBcXFxuZXVyb3Zpc2lvbiBcXFxuZXVzIFxcXG5ldmVudHMgXFxcbmV4Y2hhbmdlIFxcXG5leHBlcnQgXFxcbmV4cG9zZWQgXFxcbmV4cHJlc3MgXFxcbmV4dHJhc3BhY2UgXFxcbmZhZ2UgXFxcbmZhaWwgXFxcbmZhaXJ3aW5kcyBcXFxuZmFpdGggXFxcbmZhbWlseSBcXFxuZmFuIFxcXG5mYW5zIFxcXG5mYXJtIFxcXG5mYXJtZXJzIFxcXG5mYXNoaW9uIFxcXG5mYXN0IFxcXG5mZWRleCBcXFxuZmVlZGJhY2sgXFxcbmZlcnJhcmkgXFxcbmZlcnJlcm8gXFxcbmZpIFxcXG5maWF0IFxcXG5maWRlbGl0eSBcXFxuZmlkbyBcXFxuZmlsbSBcXFxuZmluYWwgXFxcbmZpbmFuY2UgXFxcbmZpbmFuY2lhbCBcXFxuZmlyZSBcXFxuZmlyZXN0b25lIFxcXG5maXJtZGFsZSBcXFxuZmlzaCBcXFxuZmlzaGluZyBcXFxuZml0IFxcXG5maXRuZXNzIFxcXG5maiBcXFxuZmsgXFxcbmZsaWNrciBcXFxuZmxpZ2h0cyBcXFxuZmxpciBcXFxuZmxvcmlzdCBcXFxuZmxvd2VycyBcXFxuZmx5IFxcXG5mbSBcXFxuZm8gXFxcbmZvbyBcXFxuZm9vZCBcXFxuZm9vZG5ldHdvcmsgXFxcbmZvb3RiYWxsIFxcXG5mb3JkIFxcXG5mb3JleCBcXFxuZm9yc2FsZSBcXFxuZm9ydW0gXFxcbmZvdW5kYXRpb24gXFxcbmZveCBcXFxuZnIgXFxcbmZyZWUgXFxcbmZyZXNlbml1cyBcXFxuZnJsIFxcXG5mcm9nYW5zIFxcXG5mcm9udGRvb3IgXFxcbmZyb250aWVyIFxcXG5mdHIgXFxcbmZ1aml0c3UgXFxcbmZ1biBcXFxuZnVuZCBcXFxuZnVybml0dXJlIFxcXG5mdXRib2wgXFxcbmZ5aSBcXFxuZ2EgXFxcbmdhbCBcXFxuZ2FsbGVyeSBcXFxuZ2FsbG8gXFxcbmdhbGx1cCBcXFxuZ2FtZSBcXFxuZ2FtZXMgXFxcbmdhcCBcXFxuZ2FyZGVuIFxcXG5nYXkgXFxcbmdiIFxcXG5nYml6IFxcXG5nZCBcXFxuZ2RuIFxcXG5nZSBcXFxuZ2VhIFxcXG5nZW50IFxcXG5nZW50aW5nIFxcXG5nZW9yZ2UgXFxcbmdmIFxcXG5nZyBcXFxuZ2dlZSBcXFxuZ2ggXFxcbmdpIFxcXG5naWZ0IFxcXG5naWZ0cyBcXFxuZ2l2ZXMgXFxcbmdpdmluZyBcXFxuZ2wgXFxcbmdsYXNzIFxcXG5nbGUgXFxcbmdsb2JhbCBcXFxuZ2xvYm8gXFxcbmdtIFxcXG5nbWFpbCBcXFxuZ21iaCBcXFxuZ21vIFxcXG5nbXggXFxcbmduIFxcXG5nb2RhZGR5IFxcXG5nb2xkIFxcXG5nb2xkcG9pbnQgXFxcbmdvbGYgXFxcbmdvbyBcXFxuZ29vZHllYXIgXFxcbmdvb2cgXFxcbmdvb2dsZSBcXFxuZ29wIFxcXG5nb3QgXFxcbmdvdiBcXFxuZ3AgXFxcbmdxIFxcXG5nciBcXFxuZ3JhaW5nZXIgXFxcbmdyYXBoaWNzIFxcXG5ncmF0aXMgXFxcbmdyZWVuIFxcXG5ncmlwZSBcXFxuZ3JvY2VyeSBcXFxuZ3JvdXAgXFxcbmdzIFxcXG5ndCBcXFxuZ3UgXFxcbmd1YXJkaWFuIFxcXG5ndWNjaSBcXFxuZ3VnZSBcXFxuZ3VpZGUgXFxcbmd1aXRhcnMgXFxcbmd1cnUgXFxcbmd3IFxcXG5neSBcXFxuaGFpciBcXFxuaGFtYnVyZyBcXFxuaGFuZ291dCBcXFxuaGF1cyBcXFxuaGJvIFxcXG5oZGZjIFxcXG5oZGZjYmFuayBcXFxuaGVhbHRoIFxcXG5oZWFsdGhjYXJlIFxcXG5oZWxwIFxcXG5oZWxzaW5raSBcXFxuaGVyZSBcXFxuaGVybWVzIFxcXG5oZ3R2IFxcXG5oaXBob3AgXFxcbmhpc2FtaXRzdSBcXFxuaGl0YWNoaSBcXFxuaGl2IFxcXG5oayBcXFxuaGt0IFxcXG5obSBcXFxuaG4gXFxcbmhvY2tleSBcXFxuaG9sZGluZ3MgXFxcbmhvbGlkYXkgXFxcbmhvbWVkZXBvdCBcXFxuaG9tZWdvb2RzIFxcXG5ob21lcyBcXFxuaG9tZXNlbnNlIFxcXG5ob25kYSBcXFxuaG9yc2UgXFxcbmhvc3BpdGFsIFxcXG5ob3N0IFxcXG5ob3N0aW5nIFxcXG5ob3QgXFxcbmhvdGVsZXMgXFxcbmhvdGVscyBcXFxuaG90bWFpbCBcXFxuaG91c2UgXFxcbmhvdyBcXFxuaHIgXFxcbmhzYmMgXFxcbmh0IFxcXG5odSBcXFxuaHVnaGVzIFxcXG5oeWF0dCBcXFxuaHl1bmRhaSBcXFxuaWJtIFxcXG5pY2JjIFxcXG5pY2UgXFxcbmljdSBcXFxuaWQgXFxcbmllIFxcXG5pZWVlIFxcXG5pZm0gXFxcbmlrYW5vIFxcXG5pbCBcXFxuaW0gXFxcbmltYW1hdCBcXFxuaW1kYiBcXFxuaW1tbyBcXFxuaW1tb2JpbGllbiBcXFxuaW4gXFxcbmluYyBcXFxuaW5kdXN0cmllcyBcXFxuaW5maW5pdGkgXFxcbmluZm8gXFxcbmluZyBcXFxuaW5rIFxcXG5pbnN0aXR1dGUgXFxcbmluc3VyYW5jZSBcXFxuaW5zdXJlIFxcXG5pbnQgXFxcbmludGVybmF0aW9uYWwgXFxcbmludHVpdCBcXFxuaW52ZXN0bWVudHMgXFxcbmlvIFxcXG5pcGlyYW5nYSBcXFxuaXEgXFxcbmlyIFxcXG5pcmlzaCBcXFxuaXMgXFxcbmlzbWFpbGkgXFxcbmlzdCBcXFxuaXN0YW5idWwgXFxcbml0IFxcXG5pdGF1IFxcXG5pdHYgXFxcbmphZ3VhciBcXFxuamF2YSBcXFxuamNiIFxcXG5qZSBcXFxuamVlcCBcXFxuamV0enQgXFxcbmpld2VscnkgXFxcbmppbyBcXFxuamxsIFxcXG5qbSBcXFxuam1wIFxcXG5qbmogXFxcbmpvIFxcXG5qb2JzIFxcXG5qb2J1cmcgXFxcbmpvdCBcXFxuam95IFxcXG5qcCBcXFxuanBtb3JnYW4gXFxcbmpwcnMgXFxcbmp1ZWdvcyBcXFxuanVuaXBlciBcXFxua2F1ZmVuIFxcXG5rZGRpIFxcXG5rZSBcXFxua2Vycnlob3RlbHMgXFxcbmtlcnJ5bG9naXN0aWNzIFxcXG5rZXJyeXByb3BlcnRpZXMgXFxcbmtmaCBcXFxua2cgXFxcbmtoIFxcXG5raSBcXFxua2lhIFxcXG5raWRzIFxcXG5raW0gXFxcbmtpbmRlciBcXFxua2luZGxlIFxcXG5raXRjaGVuIFxcXG5raXdpIFxcXG5rbSBcXFxua24gXFxcbmtvZWxuIFxcXG5rb21hdHN1IFxcXG5rb3NoZXIgXFxcbmtwIFxcXG5rcG1nIFxcXG5rcG4gXFxcbmtyIFxcXG5rcmQgXFxcbmtyZWQgXFxcbmt1b2tncm91cCBcXFxua3cgXFxcbmt5IFxcXG5reW90byBcXFxua3ogXFxcbmxhIFxcXG5sYWNhaXhhIFxcXG5sYW1ib3JnaGluaSBcXFxubGFtZXIgXFxcbmxhbmNhc3RlciBcXFxubGFuY2lhIFxcXG5sYW5kIFxcXG5sYW5kcm92ZXIgXFxcbmxhbnhlc3MgXFxcbmxhc2FsbGUgXFxcbmxhdCBcXFxubGF0aW5vIFxcXG5sYXRyb2JlIFxcXG5sYXcgXFxcbmxhd3llciBcXFxubGIgXFxcbmxjIFxcXG5sZHMgXFxcbmxlYXNlIFxcXG5sZWNsZXJjIFxcXG5sZWZyYWsgXFxcbmxlZ2FsIFxcXG5sZWdvIFxcXG5sZXh1cyBcXFxubGdidCBcXFxubGkgXFxcbmxpZGwgXFxcbmxpZmUgXFxcbmxpZmVpbnN1cmFuY2UgXFxcbmxpZmVzdHlsZSBcXFxubGlnaHRpbmcgXFxcbmxpa2UgXFxcbmxpbGx5IFxcXG5saW1pdGVkIFxcXG5saW1vIFxcXG5saW5jb2xuIFxcXG5saW5kZSBcXFxubGluayBcXFxubGlwc3kgXFxcbmxpdmUgXFxcbmxpdmluZyBcXFxubGsgXFxcbmxsYyBcXFxubGxwIFxcXG5sb2FuIFxcXG5sb2FucyBcXFxubG9ja2VyIFxcXG5sb2N1cyBcXFxubG9mdCBcXFxubG9sIFxcXG5sb25kb24gXFxcbmxvdHRlIFxcXG5sb3R0byBcXFxubG92ZSBcXFxubHBsIFxcXG5scGxmaW5hbmNpYWwgXFxcbmxyIFxcXG5scyBcXFxubHQgXFxcbmx0ZCBcXFxubHRkYSBcXFxubHUgXFxcbmx1bmRiZWNrIFxcXG5sdXhlIFxcXG5sdXh1cnkgXFxcbmx2IFxcXG5seSBcXFxubWEgXFxcbm1hY3lzIFxcXG5tYWRyaWQgXFxcbm1haWYgXFxcbm1haXNvbiBcXFxubWFrZXVwIFxcXG5tYW4gXFxcbm1hbmFnZW1lbnQgXFxcbm1hbmdvIFxcXG5tYXAgXFxcbm1hcmtldCBcXFxubWFya2V0aW5nIFxcXG5tYXJrZXRzIFxcXG5tYXJyaW90dCBcXFxubWFyc2hhbGxzIFxcXG5tYXNlcmF0aSBcXFxubWF0dGVsIFxcXG5tYmEgXFxcbm1jIFxcXG5tY2tpbnNleSBcXFxubWQgXFxcbm1lIFxcXG5tZWQgXFxcbm1lZGlhIFxcXG5tZWV0IFxcXG5tZWxib3VybmUgXFxcbm1lbWUgXFxcbm1lbW9yaWFsIFxcXG5tZW4gXFxcbm1lbnUgXFxcbm1lcmNrbXNkIFxcXG5tZyBcXFxubWggXFxcbm1pYW1pIFxcXG5taWNyb3NvZnQgXFxcbm1pbCBcXFxubWluaSBcXFxubWludCBcXFxubWl0IFxcXG5taXRzdWJpc2hpIFxcXG5tayBcXFxubWwgXFxcbm1sYiBcXFxubWxzIFxcXG5tbSBcXFxubW1hIFxcXG5tbiBcXFxubW8gXFxcbm1vYmkgXFxcbm1vYmlsZSBcXFxubW9kYSBcXFxubW9lIFxcXG5tb2kgXFxcbm1vbSBcXFxubW9uYXNoIFxcXG5tb25leSBcXFxubW9uc3RlciBcXFxubW9ybW9uIFxcXG5tb3J0Z2FnZSBcXFxubW9zY293IFxcXG5tb3RvIFxcXG5tb3RvcmN5Y2xlcyBcXFxubW92IFxcXG5tb3ZpZSBcXFxubXAgXFxcbm1xIFxcXG5tciBcXFxubXMgXFxcbm1zZCBcXFxubXQgXFxcbm10biBcXFxubXRyIFxcXG5tdSBcXFxubXVzZXVtIFxcXG5tdXNpYyBcXFxubXV0dWFsIFxcXG5tdiBcXFxubXcgXFxcbm14IFxcXG5teSBcXFxubXogXFxcbm5hIFxcXG5uYWIgXFxcbm5hZ295YSBcXFxubmFtZSBcXFxubmF0dXJhIFxcXG5uYXZ5IFxcXG5uYmEgXFxcbm5jIFxcXG5uZSBcXFxubmVjIFxcXG5uZXQgXFxcbm5ldGJhbmsgXFxcbm5ldGZsaXggXFxcbm5ldHdvcmsgXFxcbm5ldXN0YXIgXFxcbm5ldyBcXFxubmV3cyBcXFxubmV4dCBcXFxubmV4dGRpcmVjdCBcXFxubmV4dXMgXFxcbm5mIFxcXG5uZmwgXFxcbm5nIFxcXG5uZ28gXFxcbm5oayBcXFxubmkgXFxcbm5pY28gXFxcbm5pa2UgXFxcbm5pa29uIFxcXG5uaW5qYSBcXFxubmlzc2FuIFxcXG5uaXNzYXkgXFxcbm5sIFxcXG5ubyBcXFxubm9raWEgXFxcbm5vcnRod2VzdGVybm11dHVhbCBcXFxubm9ydG9uIFxcXG5ub3cgXFxcbm5vd3J1eiBcXFxubm93dHYgXFxcbm5wIFxcXG5uciBcXFxubnJhIFxcXG5ucncgXFxcbm50dCBcXFxubnUgXFxcbm55YyBcXFxubnogXFxcbm9iaSBcXFxub2JzZXJ2ZXIgXFxcbm9mZmljZSBcXFxub2tpbmF3YSBcXFxub2xheWFuIFxcXG5vbGF5YW5ncm91cCBcXFxub2xkbmF2eSBcXFxub2xsbyBcXFxub20gXFxcbm9tZWdhIFxcXG5vbmUgXFxcbm9uZyBcXFxub25sIFxcXG5vbmxpbmUgXFxcbm9vbyBcXFxub3BlbiBcXFxub3JhY2xlIFxcXG5vcmFuZ2UgXFxcbm9yZyBcXFxub3JnYW5pYyBcXFxub3JpZ2lucyBcXFxub3Nha2EgXFxcbm90c3VrYSBcXFxub3R0IFxcXG5vdmggXFxcbnBhIFxcXG5wYWdlIFxcXG5wYW5hc29uaWMgXFxcbnBhcmlzIFxcXG5wYXJzIFxcXG5wYXJ0bmVycyBcXFxucGFydHMgXFxcbnBhcnR5IFxcXG5wYXNzYWdlbnMgXFxcbnBheSBcXFxucGNjdyBcXFxucGUgXFxcbnBldCBcXFxucGYgXFxcbnBmaXplciBcXFxucGcgXFxcbnBoIFxcXG5waGFybWFjeSBcXFxucGhkIFxcXG5waGlsaXBzIFxcXG5waG9uZSBcXFxucGhvdG8gXFxcbnBob3RvZ3JhcGh5IFxcXG5waG90b3MgXFxcbnBoeXNpbyBcXFxucGljcyBcXFxucGljdGV0IFxcXG5waWN0dXJlcyBcXFxucGlkIFxcXG5waW4gXFxcbnBpbmcgXFxcbnBpbmsgXFxcbnBpb25lZXIgXFxcbnBpenphIFxcXG5wayBcXFxucGwgXFxcbnBsYWNlIFxcXG5wbGF5IFxcXG5wbGF5c3RhdGlvbiBcXFxucGx1bWJpbmcgXFxcbnBsdXMgXFxcbnBtIFxcXG5wbiBcXFxucG5jIFxcXG5wb2hsIFxcXG5wb2tlciBcXFxucG9saXRpZSBcXFxucG9ybiBcXFxucG9zdCBcXFxucHIgXFxcbnByYW1lcmljYSBcXFxucHJheGkgXFxcbnByZXNzIFxcXG5wcmltZSBcXFxucHJvIFxcXG5wcm9kIFxcXG5wcm9kdWN0aW9ucyBcXFxucHJvZiBcXFxucHJvZ3Jlc3NpdmUgXFxcbnByb21vIFxcXG5wcm9wZXJ0aWVzIFxcXG5wcm9wZXJ0eSBcXFxucHJvdGVjdGlvbiBcXFxucHJ1IFxcXG5wcnVkZW50aWFsIFxcXG5wcyBcXFxucHQgXFxcbnB1YiBcXFxucHcgXFxcbnB3YyBcXFxucHkgXFxcbnFhIFxcXG5xcG9uIFxcXG5xdWViZWMgXFxcbnF1ZXN0IFxcXG5yYWNpbmcgXFxcbnJhZGlvIFxcXG5yZSBcXFxucmVhZCBcXFxucmVhbGVzdGF0ZSBcXFxucmVhbHRvciBcXFxucmVhbHR5IFxcXG5yZWNpcGVzIFxcXG5yZWQgXFxcbnJlZHN0b25lIFxcXG5yZWR1bWJyZWxsYSBcXFxucmVoYWIgXFxcbnJlaXNlIFxcXG5yZWlzZW4gXFxcbnJlaXQgXFxcbnJlbGlhbmNlIFxcXG5yZW4gXFxcbnJlbnQgXFxcbnJlbnRhbHMgXFxcbnJlcGFpciBcXFxucmVwb3J0IFxcXG5yZXB1YmxpY2FuIFxcXG5yZXN0IFxcXG5yZXN0YXVyYW50IFxcXG5yZXZpZXcgXFxcbnJldmlld3MgXFxcbnJleHJvdGggXFxcbnJpY2ggXFxcbnJpY2hhcmRsaSBcXFxucmljb2ggXFxcbnJpbCBcXFxucmlvIFxcXG5yaXAgXFxcbnJvIFxcXG5yb2NoZXIgXFxcbnJvY2tzIFxcXG5yb2RlbyBcXFxucm9nZXJzIFxcXG5yb29tIFxcXG5ycyBcXFxucnN2cCBcXFxucnUgXFxcbnJ1Z2J5IFxcXG5ydWhyIFxcXG5ydW4gXFxcbnJ3IFxcXG5yd2UgXFxcbnJ5dWt5dSBcXFxuc2EgXFxcbnNhYXJsYW5kIFxcXG5zYWZlIFxcXG5zYWZldHkgXFxcbnNha3VyYSBcXFxuc2FsZSBcXFxuc2Fsb24gXFxcbnNhbXNjbHViIFxcXG5zYW1zdW5nIFxcXG5zYW5kdmlrIFxcXG5zYW5kdmlrY29yb21hbnQgXFxcbnNhbm9maSBcXFxuc2FwIFxcXG5zYXJsIFxcXG5zYXMgXFxcbnNhdmUgXFxcbnNheG8gXFxcbnNiIFxcXG5zYmkgXFxcbnNicyBcXFxuc2MgXFxcbnNjYSBcXFxuc2NiIFxcXG5zY2hhZWZmbGVyIFxcXG5zY2htaWR0IFxcXG5zY2hvbGFyc2hpcHMgXFxcbnNjaG9vbCBcXFxuc2NodWxlIFxcXG5zY2h3YXJ6IFxcXG5zY2llbmNlIFxcXG5zY290IFxcXG5zZCBcXFxuc2UgXFxcbnNlYXJjaCBcXFxuc2VhdCBcXFxuc2VjdXJlIFxcXG5zZWN1cml0eSBcXFxuc2VlayBcXFxuc2VsZWN0IFxcXG5zZW5lciBcXFxuc2VydmljZXMgXFxcbnNlcyBcXFxuc2V2ZW4gXFxcbnNldyBcXFxuc2V4IFxcXG5zZXh5IFxcXG5zZnIgXFxcbnNnIFxcXG5zaCBcXFxuc2hhbmdyaWxhIFxcXG5zaGFycCBcXFxuc2hhdyBcXFxuc2hlbGwgXFxcbnNoaWEgXFxcbnNoaWtzaGEgXFxcbnNob2VzIFxcXG5zaG9wIFxcXG5zaG9wcGluZyBcXFxuc2hvdWppIFxcXG5zaG93IFxcXG5zaG93dGltZSBcXFxuc2kgXFxcbnNpbGsgXFxcbnNpbmEgXFxcbnNpbmdsZXMgXFxcbnNpdGUgXFxcbnNqIFxcXG5zayBcXFxuc2tpIFxcXG5za2luIFxcXG5za3kgXFxcbnNreXBlIFxcXG5zbCBcXFxuc2xpbmcgXFxcbnNtIFxcXG5zbWFydCBcXFxuc21pbGUgXFxcbnNuIFxcXG5zbmNmIFxcXG5zbyBcXFxuc29jY2VyIFxcXG5zb2NpYWwgXFxcbnNvZnRiYW5rIFxcXG5zb2Z0d2FyZSBcXFxuc29odSBcXFxuc29sYXIgXFxcbnNvbHV0aW9ucyBcXFxuc29uZyBcXFxuc29ueSBcXFxuc295IFxcXG5zcGEgXFxcbnNwYWNlIFxcXG5zcG9ydCBcXFxuc3BvdCBcXFxuc3IgXFxcbnNybCBcXFxuc3MgXFxcbnN0IFxcXG5zdGFkYSBcXFxuc3RhcGxlcyBcXFxuc3RhciBcXFxuc3RhdGViYW5rIFxcXG5zdGF0ZWZhcm0gXFxcbnN0YyBcXFxuc3RjZ3JvdXAgXFxcbnN0b2NraG9sbSBcXFxuc3RvcmFnZSBcXFxuc3RvcmUgXFxcbnN0cmVhbSBcXFxuc3R1ZGlvIFxcXG5zdHVkeSBcXFxuc3R5bGUgXFxcbnN1IFxcXG5zdWNrcyBcXFxuc3VwcGxpZXMgXFxcbnN1cHBseSBcXFxuc3VwcG9ydCBcXFxuc3VyZiBcXFxuc3VyZ2VyeSBcXFxuc3V6dWtpIFxcXG5zdiBcXFxuc3dhdGNoIFxcXG5zd2lzcyBcXFxuc3ggXFxcbnN5IFxcXG5zeWRuZXkgXFxcbnN5c3RlbXMgXFxcbnN6IFxcXG50YWIgXFxcbnRhaXBlaSBcXFxudGFsayBcXFxudGFvYmFvIFxcXG50YXJnZXQgXFxcbnRhdGFtb3RvcnMgXFxcbnRhdGFyIFxcXG50YXR0b28gXFxcbnRheCBcXFxudGF4aSBcXFxudGMgXFxcbnRjaSBcXFxudGQgXFxcbnRkayBcXFxudGVhbSBcXFxudGVjaCBcXFxudGVjaG5vbG9neSBcXFxudGVsIFxcXG50ZW1hc2VrIFxcXG50ZW5uaXMgXFxcbnRldmEgXFxcbnRmIFxcXG50ZyBcXFxudGggXFxcbnRoZCBcXFxudGhlYXRlciBcXFxudGhlYXRyZSBcXFxudGlhYSBcXFxudGlja2V0cyBcXFxudGllbmRhIFxcXG50aWZmYW55IFxcXG50aXBzIFxcXG50aXJlcyBcXFxudGlyb2wgXFxcbnRqIFxcXG50am1heHggXFxcbnRqeCBcXFxudGsgXFxcbnRrbWF4eCBcXFxudGwgXFxcbnRtIFxcXG50bWFsbCBcXFxudG4gXFxcbnRvIFxcXG50b2RheSBcXFxudG9reW8gXFxcbnRvb2xzIFxcXG50b3AgXFxcbnRvcmF5IFxcXG50b3NoaWJhIFxcXG50b3RhbCBcXFxudG91cnMgXFxcbnRvd24gXFxcbnRveW90YSBcXFxudG95cyBcXFxudHIgXFxcbnRyYWRlIFxcXG50cmFkaW5nIFxcXG50cmFpbmluZyBcXFxudHJhdmVsIFxcXG50cmF2ZWxjaGFubmVsIFxcXG50cmF2ZWxlcnMgXFxcbnRyYXZlbGVyc2luc3VyYW5jZSBcXFxudHJ1c3QgXFxcbnRydiBcXFxudHQgXFxcbnR1YmUgXFxcbnR1aSBcXFxudHVuZXMgXFxcbnR1c2h1IFxcXG50diBcXFxudHZzIFxcXG50dyBcXFxudHogXFxcbnVhIFxcXG51YmFuayBcXFxudWJzIFxcXG51ZyBcXFxudWsgXFxcbnVuaWNvbSBcXFxudW5pdmVyc2l0eSBcXFxudW5vIFxcXG51b2wgXFxcbnVwcyBcXFxudXMgXFxcbnV5IFxcXG51eiBcXFxudmEgXFxcbnZhY2F0aW9ucyBcXFxudmFuYSBcXFxudmFuZ3VhcmQgXFxcbnZjIFxcXG52ZSBcXFxudmVnYXMgXFxcbnZlbnR1cmVzIFxcXG52ZXJpc2lnbiBcXFxudmVybcO2Z2Vuc2JlcmF0ZXIgXFxcbnZlcm3DtmdlbnNiZXJhdHVuZyBcXFxudmVyc2ljaGVydW5nIFxcXG52ZXQgXFxcbnZnIFxcXG52aSBcXFxudmlhamVzIFxcXG52aWRlbyBcXFxudmlnIFxcXG52aWtpbmcgXFxcbnZpbGxhcyBcXFxudmluIFxcXG52aXAgXFxcbnZpcmdpbiBcXFxudmlzYSBcXFxudmlzaW9uIFxcXG52aXZhIFxcXG52aXZvIFxcXG52bGFhbmRlcmVuIFxcXG52biBcXFxudm9ka2EgXFxcbnZvbGtzd2FnZW4gXFxcbnZvbHZvIFxcXG52b3RlIFxcXG52b3RpbmcgXFxcbnZvdG8gXFxcbnZveWFnZSBcXFxudnUgXFxcbnZ1ZWxvcyBcXFxud2FsZXMgXFxcbndhbG1hcnQgXFxcbndhbHRlciBcXFxud2FuZyBcXFxud2FuZ2dvdSBcXFxud2F0Y2ggXFxcbndhdGNoZXMgXFxcbndlYXRoZXIgXFxcbndlYXRoZXJjaGFubmVsIFxcXG53ZWJjYW0gXFxcbndlYmVyIFxcXG53ZWJzaXRlIFxcXG53ZWQgXFxcbndlZGRpbmcgXFxcbndlaWJvIFxcXG53ZWlyIFxcXG53ZiBcXFxud2hvc3dobyBcXFxud2llbiBcXFxud2lraSBcXFxud2lsbGlhbWhpbGwgXFxcbndpbiBcXFxud2luZG93cyBcXFxud2luZSBcXFxud2lubmVycyBcXFxud21lIFxcXG53b2x0ZXJza2x1d2VyIFxcXG53b29kc2lkZSBcXFxud29yayBcXFxud29ya3MgXFxcbndvcmxkIFxcXG53b3cgXFxcbndzIFxcXG53dGMgXFxcbnd0ZiBcXFxueGJveCBcXFxueGVyb3ggXFxcbnhmaW5pdHkgXFxcbnhpaHVhbiBcXFxueGluIFxcXG54eHggXFxcbnh5eiBcXFxueWFjaHRzIFxcXG55YWhvbyBcXFxueWFtYXh1biBcXFxueWFuZGV4IFxcXG55ZSBcXFxueW9kb2Jhc2hpIFxcXG55b2dhIFxcXG55b2tvaGFtYSBcXFxueW91IFxcXG55b3V0dWJlIFxcXG55dCBcXFxueXVuIFxcXG56YSBcXFxuemFwcG9zIFxcXG56YXJhIFxcXG56ZXJvIFxcXG56aXAgXFxcbnptIFxcXG56b25lIFxcXG56dWVyaWNoIFxcXG56dycuc3BsaXQoJyAnKTsgLy8gSW50ZXJuYXRpb25hbGl6ZWQgZG9tYWluIG5hbWVzIGNvbnRhaW5pbmcgbm9uLUFTQ0lJXG5cbnZhciB1dGxkcyA9ICfOtc67IFxcXG7Otc+FIFxcXG7QsdCzIFxcXG7QsdC10LsgXFxcbtC00LXRgtC4IFxcXG7QtdGOIFxcXG7QutCw0YLQvtC70LjQuiBcXFxu0LrQvtC8IFxcXG7QvNC60LQgXFxcbtC80L7QvSBcXFxu0LzQvtGB0LrQstCwIFxcXG7QvtC90LvQsNC50L0gXFxcbtC+0YDQsyBcXFxu0YDRg9GBIFxcXG7RgNGEIFxcXG7RgdCw0LnRgiBcXFxu0YHRgNCxIFxcXG7Rg9C60YAgXFxcbtKb0LDQtyBcXFxu1bDVodW1IFxcXG7Xmdep16jXkNecIFxcXG7Xp9eV150gXFxcbtin2KjZiNi42KjZiiBcXFxu2KfYqti12KfZhNin2KogXFxcbtin2LHYp9mF2YPZiCBcXFxu2KfZhNin2LHYr9mGIFxcXG7Yp9mE2KjYrdix2YrZhiBcXFxu2KfZhNis2LLYp9im2LEgXFxcbtin2YTYs9i52YjYr9mK2KkgXFxcbtin2YTYudmE2YrYp9mGIFxcXG7Yp9mE2YXYutix2KggXFxcbtin2YXYp9ix2KfYqiBcXFxu2KfbjNix2KfZhiBcXFxu2KjYp9ix2KogXFxcbtio2KfYstin2LEgXFxcbtio2YrYqtmDIFxcXG7YqNq+2KfYsdiqIFxcXG7YqtmI2YbYsyBcXFxu2LPZiNiv2KfZhiBcXFxu2LPZiNix2YrYqSBcXFxu2LTYqNmD2KkgXFxcbti52LHYp9mCIFxcXG7Yudix2KggXFxcbti52YXYp9mGIFxcXG7ZgdmE2LPYt9mK2YYgXFxcbtmC2LfYsSBcXFxu2YPYp9ir2YjZhNmK2YMgXFxcbtmD2YjZhSBcXFxu2YXYtdixIFxcXG7ZhdmE2YrYs9mK2KcgXFxcbtmF2YjYsdmK2KrYp9mG2YrYpyBcXFxu2YXZiNmC2LkgXFxcbtmH2YXYsdin2YcgXFxcbtm+2Kfaqdiz2KrYp9mGIFxcXG7agNin2LHYqiBcXFxu4KSV4KWJ4KSuIFxcXG7gpKjgpYfgpJ8gXFxcbuCkreCkvuCksOCkpCBcXFxu4KSt4KS+4KSw4KSk4KSu4KWNIFxcXG7gpK3gpL7gpLDgpYvgpKQgXFxcbuCkuOCkguCkl+CkoOCkqCBcXFxu4Kas4Ka+4KaC4Kay4Ka+IFxcXG7gpq3gpr7gprDgpqQgXFxcbuCmreCmvuCnsOCmpCBcXFxu4Kit4Ki+4Kiw4KikIFxcXG7gqq3gqr7gqrDgqqQgXFxcbuCsreCsvuCssOCspCBcXFxu4K6H4K6o4K+N4K6k4K6/4K6v4K6+IFxcXG7grofgrrLgrpngr43grpXgr4ggXFxcbuCumuCuv+CumeCvjeCuleCuquCvjeCuquCvguCusOCvjSBcXFxu4LCt4LC+4LCw4LCk4LGNIFxcXG7gsq3gsr7gsrDgsqQgXFxcbuC0reC0vuC0sOC0pOC0giBcXFxu4La94LaC4Laa4LePIFxcXG7guITguK3guKEgXFxcbuC5hOC4l+C4oiBcXFxu4Lql4Lqy4LqnIFxcXG7hg5Lhg5QgXFxcbuOBv+OCk+OBqiBcXFxu44Ki44Oe44K+44OzIFxcXG7jgq/jg6njgqbjg4kgXFxcbuOCsOODvOOCsOODqyBcXFxu44Kz44OgIFxcXG7jgrnjg4jjgqIgXFxcbuOCu+ODvOODqyBcXFxu44OV44Kh44OD44K344On44OzIFxcXG7jg53jgqTjg7Pjg4ggXFxcbuS4lueVjCBcXFxu5Lit5L+hIFxcXG7kuK3lm70gXFxcbuS4reWciyBcXFxu5Lit5paH572RIFxcXG7kuprpqazpgIogXFxcbuS8geS4miBcXFxu5L2b5bGxIFxcXG7kv6Hmga8gXFxcbuWBpeW6tyBcXFxu5YWr5Y2mIFxcXG7lhazlj7ggXFxcbuWFrOebiiBcXFxu5Y+w5rm+IFxcXG7lj7DngaMgXFxcbuWVhuWfjiBcXFxu5ZWG5bqXIFxcXG7llYbmoIcgXFxcbuWYiemHjCBcXFxu5ZiJ6YeM5aSn6YWS5bqXIFxcXG7lnKjnur8gXFxcbuWkp+aLvyBcXFxu5aSp5Li75pWZIFxcXG7lqLHkuZAgXFxcbuWutumbuyBcXFxu5bm/5LicIFxcXG7lvq7ljZogXFxcbuaFiOWWhCBcXFxu5oiR54ix5L2gIFxcXG7miYvmnLogXFxcbuaLm+iBmCBcXFxu5pS/5YqhIFxcXG7mlL/lupwgXFxcbuaWsOWKoOWdoSBcXFxu5paw6Ze7IFxcXG7ml7blsJogXFxcbuabuOexjSBcXFxu5py65p6EIFxcXG7mt6HpqazplKEgXFxcbua4uOaIjyBcXFxu5r6z6ZaAIFxcXG7ngrnnnIsgXFxcbuenu+WKqCBcXFxu57uE57uH5py65p6EIFxcXG7nvZHlnYAgXFxcbue9keW6lyBcXFxu572R56uZIFxcXG7nvZHnu5wgXFxcbuiBlOmAmiBcXFxu6K+65Z+65LqaIFxcXG7osLfmrYwgXFxcbui0reeJqSBcXFxu6YCa6LKpIFxcXG7pm4blm6IgXFxcbumbu+ioiuebiOenkSBcXFxu6aOe5Yip5rWmIFxcXG7po5/lk4EgXFxcbumkkOWOhSBcXFxu6aaZ5qC86YeM5ouJIFxcXG7pppnmuK8gXFxcbuuLt+uEtyBcXFxu64u37Lu0IFxcXG7sgrzshLEgXFxcbu2VnOq1rScuc3BsaXQoJyAnKTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgQVxuICogQHRlbXBsYXRlIEJcbiAqIEBwYXJhbSB7QX0gdGFyZ2V0XG4gKiBAcGFyYW0ge0J9IHByb3BlcnRpZXNcbiAqIEByZXR1cm4ge0EgJiBCfVxuICovXG52YXIgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgcHJvcGVydGllcykge1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcGVydGllcykge1xuICAgIHRhcmdldFtrZXldID0gcHJvcGVydGllc1trZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogRmluaXRlIFN0YXRlIE1hY2hpbmUgZ2VuZXJhdGlvbiB1dGlsaXRpZXNcbiAqL1xuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge3sgW2dyb3VwOiBzdHJpbmddOiBUW10gfX0gQ29sbGVjdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7IFtncm91cDogc3RyaW5nXTogdHJ1ZSB9fSBGbGFnc1xuICovXG4vLyBLZXlzIGluIHNjYW5uZXIgQ29sbGVjdGlvbnMgaW5zdGFuY2VzXG5cbnZhciBudW1lcmljID0gJ251bWVyaWMnO1xudmFyIGFzY2lpID0gJ2FzY2lpJztcbnZhciBhbHBoYSA9ICdhbHBoYSc7XG52YXIgYXNjaWludW1lcmljID0gJ2FzY2lpbnVtZXJpYyc7XG52YXIgYWxwaGFudW1lcmljID0gJ2FscGhhbnVtZXJpYyc7XG52YXIgZG9tYWluID0gJ2RvbWFpbic7XG52YXIgZW1vamkgPSAnZW1vamknO1xudmFyIHNjaGVtZSA9ICdzY2hlbWUnO1xudmFyIHNsYXNoc2NoZW1lID0gJ3NsYXNoc2NoZW1lJztcbnZhciB3aGl0ZXNwYWNlID0gJ3doaXRlc3BhY2UnO1xuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IGdyb3VwcyB0byByZWdpc3RlciBpblxuICogQHJldHVybnMge1RbXX0gQ3VycmVudCBsaXN0IG9mIHRva2VucyBpbiB0aGUgZ2l2ZW4gY29sbGVjdGlvblxuICovXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyR3JvdXAobmFtZSwgZ3JvdXBzKSB7XG4gIGlmICghKG5hbWUgaW4gZ3JvdXBzKSkge1xuICAgIGdyb3Vwc1tuYW1lXSA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGdyb3Vwc1tuYW1lXTtcbn1cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdCB0b2tlbiB0byBhZGRcbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IGdyb3Vwc1xuICogQHBhcmFtIHtGbGFnc30gZmxhZ3NcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZFRvR3JvdXBzKHQsIGZsYWdzLCBncm91cHMpIHtcbiAgaWYgKGZsYWdzW251bWVyaWNdKSB7XG4gICAgZmxhZ3NbYXNjaWludW1lcmljXSA9IHRydWU7XG4gICAgZmxhZ3NbYWxwaGFudW1lcmljXSA9IHRydWU7XG4gIH1cblxuICBpZiAoZmxhZ3NbYXNjaWldKSB7XG4gICAgZmxhZ3NbYXNjaWludW1lcmljXSA9IHRydWU7XG4gICAgZmxhZ3NbYWxwaGFdID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChmbGFnc1thc2NpaW51bWVyaWNdKSB7XG4gICAgZmxhZ3NbYWxwaGFudW1lcmljXSA9IHRydWU7XG4gIH1cblxuICBpZiAoZmxhZ3NbYWxwaGFdKSB7XG4gICAgZmxhZ3NbYWxwaGFudW1lcmljXSA9IHRydWU7XG4gIH1cblxuICBpZiAoZmxhZ3NbYWxwaGFudW1lcmljXSkge1xuICAgIGZsYWdzW2RvbWFpbl0gPSB0cnVlO1xuICB9XG5cbiAgaWYgKGZsYWdzW2Vtb2ppXSkge1xuICAgIGZsYWdzW2RvbWFpbl0gPSB0cnVlO1xuICB9XG5cbiAgZm9yICh2YXIgayBpbiBmbGFncykge1xuICAgIHZhciBncm91cCA9IHJlZ2lzdGVyR3JvdXAoaywgZ3JvdXBzKTtcblxuICAgIGlmIChncm91cC5pbmRleE9mKHQpIDwgMCkge1xuICAgICAgZ3JvdXAucHVzaCh0KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdCB0b2tlbiB0byBjaGVja1xuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gZ3JvdXBzXG4gKiBAcmV0dXJucyB7RmxhZ3N9IGdyb3VwIGZsYWdzIHRoYXQgY29udGFpbiB0aGlzIHRva2VuXG4gKi9cblxuZnVuY3Rpb24gZmxhZ3NGb3JUb2tlbih0LCBncm91cHMpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGZvciAodmFyIGMgaW4gZ3JvdXBzKSB7XG4gICAgaWYgKGdyb3Vwc1tjXS5pbmRleE9mKHQpID49IDApIHtcbiAgICAgIHJlc3VsdFtjXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHtudWxsIHwgVCB9IFRyYW5zaXRpb25cbiAqL1xuXG4vKipcbiAqIERlZmluZSBhIGJhc2ljIHN0YXRlIG1hY2hpbmUgc3RhdGUuIGogaXMgdGhlIGxpc3Qgb2YgY2hhcmFjdGVyIHRyYW5zaXRpb25zLFxuICoganIgaXMgdGhlIGxpc3Qgb2YgcmVnZXgtbWF0Y2ggdHJhbnNpdGlvbnMsIGpkIGlzIHRoZSBkZWZhdWx0IHN0YXRlIHRvXG4gKiB0cmFuc2l0aW9uIHRvIHQgaXMgdGhlIGFjY2VwdGluZyB0b2tlbiB0eXBlLCBpZiBhbnkuIElmIHRoaXMgaXMgdGhlIHRlcm1pbmFsXG4gKiBzdGF0ZSwgdGhlbiBpdCBkb2VzIG5vdCBlbWl0IGEgdG9rZW4uXG4gKlxuICogVGhlIHRlbXBsYXRlIHR5cGUgVCByZXByZXNlbnRzIHRoZSB0eXBlIG9mIHRoZSB0b2tlbiB0aGlzIHN0YXRlIGFjY2VwdHMuIFRoaXNcbiAqIHNob3VsZCBiZSBhIHN0cmluZyAoc3VjaCBhcyBvZiB0aGUgdG9rZW4gZXhwb3J0cyBpbiBgdGV4dC5qc2ApIG9yIGFcbiAqIE11bHRpVG9rZW4gc3ViY2xhc3MgKGZyb20gYG11bHRpLmpzYClcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBbdG9rZW5dIFRva2VuIHRoYXQgdGhpcyBzdGF0ZSBlbWl0c1xuICovXG5cblxuZnVuY3Rpb24gU3RhdGUodG9rZW4pIHtcbiAgaWYgKHRva2VuID09PSB2b2lkIDApIHtcbiAgICB0b2tlbiA9IG51bGw7XG4gIH1cblxuICAvLyB0aGlzLm4gPSBudWxsOyAvLyBERUJVRzogU3RhdGUgbmFtZVxuXG4gIC8qKiBAdHlwZSB7eyBbaW5wdXQ6IHN0cmluZ106IFN0YXRlPFQ+IH19IGogKi9cbiAgdGhpcy5qID0ge307IC8vIElNUExFTUVOVEFUSU9OIDFcbiAgLy8gdGhpcy5qID0gW107IC8vIElNUExFTUVOVEFUSU9OIDJcblxuICAvKiogQHR5cGUge1tSZWdFeHAsIFN0YXRlPFQ+XVtdfSBqciAqL1xuXG4gIHRoaXMuanIgPSBbXTtcbiAgLyoqIEB0eXBlIHs/U3RhdGU8VD59IGpkICovXG5cbiAgdGhpcy5qZCA9IG51bGw7XG4gIC8qKiBAdHlwZSB7P1R9IHQgKi9cblxuICB0aGlzLnQgPSB0b2tlbjtcbn1cbi8qKlxuICogU2Nhbm5lciB0b2tlbiBncm91cHNcbiAqIEB0eXBlIENvbGxlY3Rpb25zPHN0cmluZz5cbiAqL1xuXG5TdGF0ZS5ncm91cHMgPSB7fTtcblN0YXRlLnByb3RvdHlwZSA9IHtcbiAgYWNjZXB0czogZnVuY3Rpb24gYWNjZXB0cygpIHtcbiAgICByZXR1cm4gISF0aGlzLnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvbGxvdyBhbiBleGlzdGluZyB0cmFuc2l0aW9uIGZyb20gdGhlIGdpdmVuIGlucHV0IHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKiBEb2VzIG5vdCBtdXRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBjaGFyYWN0ZXIgb3IgdG9rZW4gdHlwZSB0byB0cmFuc2l0aW9uIG9uXG4gICAqIEByZXR1cm5zIHs/U3RhdGU8VD59IHRoZSBuZXh0IHN0YXRlLCBpZiBhbnlcbiAgICovXG4gIGdvOiBmdW5jdGlvbiBnbyhpbnB1dCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXM7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHN0YXRlLmpbaW5wdXRdO1xuXG4gICAgaWYgKG5leHRTdGF0ZSkge1xuICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmpyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmVnZXggPSBzdGF0ZS5qcltpXVswXTtcbiAgICAgIHZhciBfbmV4dFN0YXRlID0gc3RhdGUuanJbaV1bMV07IC8vIG5vdGU6IG1pZ2h0IGJlIGVtcHR5IHRvIHByZXZlbnQgZGVmYXVsdCBqdW1wXG5cbiAgICAgIGlmIChfbmV4dFN0YXRlICYmIHJlZ2V4LnRlc3QoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBfbmV4dFN0YXRlO1xuICAgICAgfVxuICAgIH0gLy8gTm93aGVyZSBsZWZ0IHRvIGp1bXAhIFJldHVybiBkZWZhdWx0LCBpZiBhbnlcblxuXG4gICAgcmV0dXJuIHN0YXRlLmpkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdGF0ZSBoYXMgYSB0cmFuc2l0aW9uIGZvciB0aGUgZ2l2ZW4gaW5wdXQuIFNldCB0aGUgc2Vjb25kXG4gICAqIGFyZ3VtZW50IHRvIHRydWUgdG8gb25seSBsb29rIGZvciBhbiBleGFjdCBtYXRjaCAoYW5kIG5vdCBhIGRlZmF1bHQgb3JcbiAgICogcmVndWxhci1leHByZXNzaW9uLWJhc2VkIHRyYW5zaXRpb24pXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV4YWN0T25seVxuICAgKi9cbiAgaGFzOiBmdW5jdGlvbiBoYXMoaW5wdXQsIGV4YWN0T25seSkge1xuICAgIGlmIChleGFjdE9ubHkgPT09IHZvaWQgMCkge1xuICAgICAgZXhhY3RPbmx5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4YWN0T25seSA/IGlucHV0IGluIHRoaXMuaiA6ICEhdGhpcy5nbyhpbnB1dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNob3J0IGZvciBcInRyYW5zaXRpb24gYWxsXCI7IGNyZWF0ZSBhIHRyYW5zaXRpb24gZnJvbSB0aGUgYXJyYXkgb2YgaXRlbXNcbiAgICogaW4gdGhlIGdpdmVuIGxpc3QgdG8gdGhlIHNhbWUgZmluYWwgcmVzdWx0aW5nIHN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBpbnB1dHMgR3JvdXAgb2YgaW5wdXRzIHRvIHRyYW5zaXRpb24gb25cbiAgICogQHBhcmFtIHtUcmFuc2l0aW9uPFQ+IHwgU3RhdGU8VD59IFtuZXh0XSBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXSBDb2xsZWN0aW9ucyBmbGFncyB0byBhZGQgdG9rZW4gdG9cbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc10gTWFzdGVyIGxpc3Qgb2YgdG9rZW4gZ3JvdXBzXG4gICAqL1xuICB0YTogZnVuY3Rpb24gdGEoaW5wdXRzLCBuZXh0LCBmbGFncywgZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMudHQoaW5wdXRzW2ldLCBuZXh0LCBmbGFncywgZ3JvdXBzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNob3J0IGZvciBcInRha2UgcmVnZXhwIHRyYW5zaXRpb25cIjsgZGVmaW5lcyBhIHRyYW5zaXRpb24gZm9yIHRoaXMgc3RhdGVcbiAgICogd2hlbiBpdCBlbmNvdW50ZXJzIGEgdG9rZW4gd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHAgUmVndWxhciBleHByZXNzaW9uIHRyYW5zaXRpb24gKHBvcHVsYXRlIGZpcnN0KVxuICAgKiBAcGFyYW0ge1QgfCBTdGF0ZTxUPn0gW25leHRdIFRyYW5zaXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdIENvbGxlY3Rpb25zIGZsYWdzIHRvIGFkZCB0b2tlbiB0b1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXSBNYXN0ZXIgbGlzdCBvZiB0b2tlbiBncm91cHNcbiAgICogQHJldHVybnMge1N0YXRlPFQ+fSB0YWtlbiBhZnRlciB0aGUgZ2l2ZW4gaW5wdXRcbiAgICovXG4gIHRyOiBmdW5jdGlvbiB0cihyZWdleHAsIG5leHQsIGZsYWdzLCBncm91cHMpIHtcbiAgICBncm91cHMgPSBncm91cHMgfHwgU3RhdGUuZ3JvdXBzO1xuICAgIHZhciBuZXh0U3RhdGU7XG5cbiAgICBpZiAobmV4dCAmJiBuZXh0LmopIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRva2VuIHdpdGggbWF5YmUgdG9rZW4gZ3JvdXBzXG4gICAgICBuZXh0U3RhdGUgPSBuZXcgU3RhdGUobmV4dCk7XG5cbiAgICAgIGlmIChmbGFncyAmJiBncm91cHMpIHtcbiAgICAgICAgYWRkVG9Hcm91cHMobmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5qci5wdXNoKFtyZWdleHAsIG5leHRTdGF0ZV0pO1xuICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNob3J0IGZvciBcInRha2UgdHJhbnNpdGlvbnNcIiwgd2lsbCB0YWtlIGFzIG1hbnkgc2VxdWVudGlhbCB0cmFuc2l0aW9ucyBhc1xuICAgKiB0aGUgbGVuZ3RoIG9mIHRoZSBnaXZlbiBpbnB1dCBhbmQgcmV0dXJucyB0aGVcbiAgICogcmVzdWx0aW5nIGZpbmFsIHN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBpbnB1dFxuICAgKiBAcGFyYW0ge1QgfCBTdGF0ZTxUPn0gW25leHRdIFRyYW5zaXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdIENvbGxlY3Rpb25zIGZsYWdzIHRvIGFkZCB0b2tlbiB0b1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXSBNYXN0ZXIgbGlzdCBvZiB0b2tlbiBncm91cHNcbiAgICogQHJldHVybnMge1N0YXRlPFQ+fSB0YWtlbiBhZnRlciB0aGUgZ2l2ZW4gaW5wdXRcbiAgICovXG4gIHRzOiBmdW5jdGlvbiB0cyhpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXM7XG4gICAgdmFyIGxlbiA9IGlucHV0Lmxlbmd0aDtcblxuICAgIGlmICghbGVuKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgIHN0YXRlID0gc3RhdGUudHQoaW5wdXRbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS50dChpbnB1dFtsZW4gLSAxXSwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNob3J0IGZvciBcInRha2UgdHJhbnNpdGlvblwiLCB0aGlzIGlzIGEgbWV0aG9kIGZvciBidWlsZGluZy93b3JraW5nIHdpdGhcbiAgICogc3RhdGUgbWFjaGluZXMuXG4gICAqXG4gICAqIElmIGEgc3RhdGUgYWxyZWFkeSBleGlzdHMgZm9yIHRoZSBnaXZlbiBpbnB1dCwgcmV0dXJucyBpdC5cbiAgICpcbiAgICogSWYgYSB0b2tlbiBpcyBzcGVjaWZpZWQsIHRoYXQgc3RhdGUgd2lsbCBlbWl0IHRoYXQgdG9rZW4gd2hlbiByZWFjaGVkIGJ5XG4gICAqIHRoZSBsaW5raWZ5IGVuZ2luZS5cbiAgICpcbiAgICogSWYgbm8gc3RhdGUgZXhpc3RzLCBpdCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggc29tZSBkZWZhdWx0IHRyYW5zaXRpb25zXG4gICAqIHRoYXQgcmVzZW1ibGUgZXhpc3RpbmcgZGVmYXVsdCB0cmFuc2l0aW9ucy5cbiAgICpcbiAgICogSWYgYSBzdGF0ZSBpcyBnaXZlbiBmb3IgdGhlIHNlY29uZCBhcmd1bWVudCwgdGhhdCBzdGF0ZSB3aWxsIGJlXG4gICAqIHRyYW5zaXRpb25lZCB0byBvbiB0aGUgZ2l2ZW4gaW5wdXQgcmVnYXJkbGVzcyBvZiB3aGF0IHRoYXQgaW5wdXRcbiAgICogcHJldmlvdXNseSBkaWQuXG4gICAqXG4gICAqIFNwZWNpZnkgYSB0b2tlbiBncm91cCBmbGFncyB0byBkZWZpbmUgZ3JvdXBzIHRoYXQgdGhpcyB0b2tlbiBiZWxvbmdzIHRvLlxuICAgKiBUaGUgdG9rZW4gd2lsbCBiZSBhZGRlZCB0byBjb3JyZXNwb25kaW5nIGVudGlyZXMgaW4gdGhlIGdpdmVuIGdyb3Vwc1xuICAgKiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBjaGFyYWN0ZXIsIHRva2VuIHR5cGUgdG8gdHJhbnNpdGlvbiBvblxuICAgKiBAcGFyYW0ge1QgfCBTdGF0ZTxUPn0gW25leHRdIFRyYW5zaXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdIENvbGxlY3Rpb25zIGZsYWdzIHRvIGFkZCB0b2tlbiB0b1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXSBNYXN0ZXIgbGlzdCBvZiBncm91cHNcbiAgICogQHJldHVybnMge1N0YXRlPFQ+fSB0YWtlbiBhZnRlciB0aGUgZ2l2ZW4gaW5wdXRcbiAgICovXG4gIHR0OiBmdW5jdGlvbiB0dChpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcykge1xuICAgIGdyb3VwcyA9IGdyb3VwcyB8fCBTdGF0ZS5ncm91cHM7XG4gICAgdmFyIHN0YXRlID0gdGhpczsgLy8gQ2hlY2sgaWYgZXhpc3Rpbmcgc3RhdGUgZ2l2ZW4sIGp1c3QgYSBiYXNpYyB0cmFuc2l0aW9uXG5cbiAgICBpZiAobmV4dCAmJiBuZXh0LmopIHtcbiAgICAgIHN0YXRlLmpbaW5wdXRdID0gbmV4dDtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cblxuICAgIHZhciB0ID0gbmV4dDsgLy8gVGFrZSB0aGUgdHJhbnNpdGlvbiB3aXRoIHRoZSB1c3VhbCBkZWZhdWx0IG1lY2hhbmlzbXMgYW5kIHVzZSB0aGF0IGFzXG4gICAgLy8gYSB0ZW1wbGF0ZSBmb3IgY3JlYXRpbmcgdGhlIG5leHQgc3RhdGVcblxuICAgIHZhciBuZXh0U3RhdGUsXG4gICAgICAgIHRlbXBsYXRlU3RhdGUgPSBzdGF0ZS5nbyhpbnB1dCk7XG5cbiAgICBpZiAodGVtcGxhdGVTdGF0ZSkge1xuICAgICAgbmV4dFN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgICBhc3NpZ24obmV4dFN0YXRlLmosIHRlbXBsYXRlU3RhdGUuaik7XG4gICAgICBuZXh0U3RhdGUuanIucHVzaC5hcHBseShuZXh0U3RhdGUuanIsIHRlbXBsYXRlU3RhdGUuanIpO1xuICAgICAgbmV4dFN0YXRlLmpkID0gdGVtcGxhdGVTdGF0ZS5qZDtcbiAgICAgIG5leHRTdGF0ZS50ID0gdGVtcGxhdGVTdGF0ZS50O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAodCkge1xuICAgICAgLy8gRW5zdXJlIG5ld2x5IHRva2VuIGlzIGluIHRoZSBzYW1lIGdyb3VwcyBhcyB0aGUgb2xkIHRva2VuXG4gICAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICAgIGlmIChuZXh0U3RhdGUudCAmJiB0eXBlb2YgbmV4dFN0YXRlLnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGFsbEZsYWdzID0gYXNzaWduKGZsYWdzRm9yVG9rZW4obmV4dFN0YXRlLnQsIGdyb3VwcyksIGZsYWdzKTtcbiAgICAgICAgICBhZGRUb0dyb3Vwcyh0LCBhbGxGbGFncywgZ3JvdXBzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmbGFncykge1xuICAgICAgICAgIGFkZFRvR3JvdXBzKHQsIGZsYWdzLCBncm91cHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHRTdGF0ZS50ID0gdDsgLy8gb3ZlcndyaXRlIGFueXRoaW5nIHRoYXQgd2FzIHByZXZpb3VzbHkgdGhlcmVcbiAgICB9XG5cbiAgICBzdGF0ZS5qW2lucHV0XSA9IG5leHRTdGF0ZTtcbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9XG59OyAvLyBIZWxwZXIgZnVuY3Rpb25zIHRvIGltcHJvdmUgbWluaWZpY2F0aW9uIChub3QgZXhwb3J0ZWQgb3V0c2lkZSBsaW5raWZ5anMgbW9kdWxlKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N0YXRlPFQ+fSBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gaW5wdXRcbiAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc11cbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdXG4gKi9cblxudmFyIHRhID0gZnVuY3Rpb24gdGEoc3RhdGUsIGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKSB7XG4gIHJldHVybiBzdGF0ZS50YShpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG59O1xuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTdGF0ZTxUPn0gc3RhdGVcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF1cbiAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc11cbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdXG4gKi9cblxudmFyIHRyID0gZnVuY3Rpb24gdHIoc3RhdGUsIHJlZ2V4cCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcykge1xuICByZXR1cm4gc3RhdGUudHIocmVnZXhwLCBuZXh0LCBmbGFncywgZ3JvdXBzKTtcbn07XG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N0YXRlPFQ+fSBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gaW5wdXRcbiAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF1cbiAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc11cbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdXG4gKi9cblxudmFyIHRzID0gZnVuY3Rpb24gdHMoc3RhdGUsIGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKSB7XG4gIHJldHVybiBzdGF0ZS50cyhpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG59O1xuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTdGF0ZTxUPn0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHtUIHwgU3RhdGU8VD59IFtuZXh0XVxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc11cbiAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc11cbiAqL1xuXG52YXIgdHQgPSBmdW5jdGlvbiB0dChzdGF0ZSwgaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpIHtcbiAgcmV0dXJuIHN0YXRlLnR0KGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKTtcbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblRleHQgVG9rZW5zXG5JZGVudGlmaWVycyBmb3IgdG9rZW4gb3V0cHV0cyBmcm9tIHRoZSByZWdleHAgc2Nhbm5lclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLy8gQSB2YWxpZCB3ZWIgZG9tYWluIHRva2VuXG52YXIgV09SRCA9ICdXT1JEJzsgLy8gb25seSBjb250YWlucyBhLXpcblxudmFyIFVXT1JEID0gJ1VXT1JEJzsgLy8gY29udGFpbnMgbGV0dGVycyBvdGhlciB0aGFuIGEteiwgdXNlZCBmb3IgSUROXG4vLyBTcGVjaWFsIGNhc2Ugb2Ygd29yZFxuXG52YXIgTE9DQUxIT1NUID0gJ0xPQ0FMSE9TVCc7IC8vIFZhbGlkIHRvcC1sZXZlbCBkb21haW4sIHNwZWNpYWwgY2FzZSBvZiBXT1JEIChzZWUgdGxkcy5qcylcblxudmFyIFRMRCA9ICdUTEQnOyAvLyBWYWxpZCBJRE4gVExELCBzcGVjaWFsIGNhc2Ugb2YgVVdPUkQgKHNlZSB0bGRzLmpzKVxuXG52YXIgVVRMRCA9ICdVVExEJzsgLy8gVGhlIHNjaGVtZSBwb3J0aW9uIG9mIGEgd2ViIFVSSSBwcm90b2NvbC4gU3VwcG9ydGVkIHR5cGVzIGluY2x1ZGU6IGBtYWlsdG9gLFxuLy8gYGZpbGVgLCBhbmQgdXNlci1kZWZpbmVkIGN1c3RvbSBwcm90b2NvbHMuIExpbWl0ZWQgdG8gc2NoZW1lcyB0aGF0IGNvbnRhaW5cbi8vIG9ubHkgbGV0dGVyc1xuXG52YXIgU0NIRU1FID0gJ1NDSEVNRSc7IC8vIFNpbWlsYXIgdG8gU0NIRU1FLCBleGNlcHQgbWFrZXMgZGlzdGluY3Rpb24gZm9yIHNjaGVtZXMgdGhhdCBtdXN0IGFsd2F5cyBiZVxuLy8gZm9sbG93ZWQgYnkgYDovL2AsIG5vdCBqdXN0IGA6YC4gU3VwcG9ydGVkIHR5cGVzIGluY2x1ZGUgYGh0dHBgLCBgaHR0cHNgLFxuLy8gYGZ0cGAsIGBmdHBzYFxuXG52YXIgU0xBU0hfU0NIRU1FID0gJ1NMQVNIX1NDSEVNRSc7IC8vIEFueSBzZXF1ZW5jZSBvZiBkaWdpdHMgMC05XG5cbnZhciBOVU0gPSAnTlVNJzsgLy8gQW55IG51bWJlciBvZiBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IG5ld2xpbmVcblxudmFyIFdTID0gJ1dTJzsgLy8gTmV3IGxpbmUgKHVuaXggc3R5bGUpXG5cbnZhciBOTCQxID0gJ05MJzsgLy8gXFxuXG4vLyBPcGVuaW5nL2Nsb3NpbmcgYnJhY2tldCBjbGFzc2VzXG5cbnZhciBPUEVOQlJBQ0UgPSAnT1BFTkJSQUNFJzsgLy8ge1xuXG52YXIgT1BFTkJSQUNLRVQgPSAnT1BFTkJSQUNLRVQnOyAvLyBbXG5cbnZhciBPUEVOQU5HTEVCUkFDS0VUID0gJ09QRU5BTkdMRUJSQUNLRVQnOyAvLyA8XG5cbnZhciBPUEVOUEFSRU4gPSAnT1BFTlBBUkVOJzsgLy8gKFxuXG52YXIgQ0xPU0VCUkFDRSA9ICdDTE9TRUJSQUNFJzsgLy8gfVxuXG52YXIgQ0xPU0VCUkFDS0VUID0gJ0NMT1NFQlJBQ0tFVCc7IC8vIF1cblxudmFyIENMT1NFQU5HTEVCUkFDS0VUID0gJ0NMT1NFQU5HTEVCUkFDS0VUJzsgLy8gPlxuXG52YXIgQ0xPU0VQQVJFTiA9ICdDTE9TRVBBUkVOJzsgLy8gKVxuLy8gVmFyaW91cyBzeW1ib2xzXG5cbnZhciBBTVBFUlNBTkQgPSAnQU1QRVJTQU5EJzsgLy8gJlxuXG52YXIgQVBPU1RST1BIRSA9ICdBUE9TVFJPUEhFJzsgLy8gJ1xuXG52YXIgQVNURVJJU0sgPSAnQVNURVJJU0snOyAvLyAqXG5cbnZhciBBVCA9ICdBVCc7IC8vIEBcblxudmFyIEJBQ0tTTEFTSCA9ICdCQUNLU0xBU0gnOyAvLyBcXFxuXG52YXIgQkFDS1RJQ0sgPSAnQkFDS1RJQ0snOyAvLyBgXG5cbnZhciBDQVJFVCA9ICdDQVJFVCc7IC8vIF5cblxudmFyIENPTE9OID0gJ0NPTE9OJzsgLy8gOlxuXG52YXIgQ09NTUEgPSAnQ09NTUEnOyAvLyAsXG5cbnZhciBET0xMQVIgPSAnRE9MTEFSJzsgLy8gJFxuXG52YXIgRE9UID0gJ0RPVCc7IC8vIC5cblxudmFyIEVRVUFMUyA9ICdFUVVBTFMnOyAvLyA9XG5cbnZhciBFWENMQU1BVElPTiA9ICdFWENMQU1BVElPTic7IC8vICFcblxudmFyIEhZUEhFTiA9ICdIWVBIRU4nOyAvLyAtXG5cbnZhciBQRVJDRU5UID0gJ1BFUkNFTlQnOyAvLyAlXG5cbnZhciBQSVBFID0gJ1BJUEUnOyAvLyB8XG5cbnZhciBQTFVTID0gJ1BMVVMnOyAvLyArXG5cbnZhciBQT1VORCA9ICdQT1VORCc7IC8vICNcblxudmFyIFFVRVJZID0gJ1FVRVJZJzsgLy8gP1xuXG52YXIgUVVPVEUgPSAnUVVPVEUnOyAvLyBcIlxuXG52YXIgU0VNSSA9ICdTRU1JJzsgLy8gO1xuXG52YXIgU0xBU0ggPSAnU0xBU0gnOyAvLyAvXG5cbnZhciBUSUxERSA9ICdUSUxERSc7IC8vIH5cblxudmFyIFVOREVSU0NPUkUgPSAnVU5ERVJTQ09SRSc7IC8vIF9cbi8vIEVtb2ppIHN5bWJvbFxuXG52YXIgRU1PSkkkMSA9ICdFTU9KSSc7IC8vIERlZmF1bHQgdG9rZW4gLSBhbnl0aGluZyB0aGF0IGlzIG5vdCBvbmUgb2YgdGhlIGFib3ZlXG5cbnZhciBTWU0gPSAnU1lNJztcblxudmFyIHRrID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdFdPUkQ6IFdPUkQsXG5cdFVXT1JEOiBVV09SRCxcblx0TE9DQUxIT1NUOiBMT0NBTEhPU1QsXG5cdFRMRDogVExELFxuXHRVVExEOiBVVExELFxuXHRTQ0hFTUU6IFNDSEVNRSxcblx0U0xBU0hfU0NIRU1FOiBTTEFTSF9TQ0hFTUUsXG5cdE5VTTogTlVNLFxuXHRXUzogV1MsXG5cdE5MOiBOTCQxLFxuXHRPUEVOQlJBQ0U6IE9QRU5CUkFDRSxcblx0T1BFTkJSQUNLRVQ6IE9QRU5CUkFDS0VULFxuXHRPUEVOQU5HTEVCUkFDS0VUOiBPUEVOQU5HTEVCUkFDS0VULFxuXHRPUEVOUEFSRU46IE9QRU5QQVJFTixcblx0Q0xPU0VCUkFDRTogQ0xPU0VCUkFDRSxcblx0Q0xPU0VCUkFDS0VUOiBDTE9TRUJSQUNLRVQsXG5cdENMT1NFQU5HTEVCUkFDS0VUOiBDTE9TRUFOR0xFQlJBQ0tFVCxcblx0Q0xPU0VQQVJFTjogQ0xPU0VQQVJFTixcblx0QU1QRVJTQU5EOiBBTVBFUlNBTkQsXG5cdEFQT1NUUk9QSEU6IEFQT1NUUk9QSEUsXG5cdEFTVEVSSVNLOiBBU1RFUklTSyxcblx0QVQ6IEFULFxuXHRCQUNLU0xBU0g6IEJBQ0tTTEFTSCxcblx0QkFDS1RJQ0s6IEJBQ0tUSUNLLFxuXHRDQVJFVDogQ0FSRVQsXG5cdENPTE9OOiBDT0xPTixcblx0Q09NTUE6IENPTU1BLFxuXHRET0xMQVI6IERPTExBUixcblx0RE9UOiBET1QsXG5cdEVRVUFMUzogRVFVQUxTLFxuXHRFWENMQU1BVElPTjogRVhDTEFNQVRJT04sXG5cdEhZUEhFTjogSFlQSEVOLFxuXHRQRVJDRU5UOiBQRVJDRU5ULFxuXHRQSVBFOiBQSVBFLFxuXHRQTFVTOiBQTFVTLFxuXHRQT1VORDogUE9VTkQsXG5cdFFVRVJZOiBRVUVSWSxcblx0UVVPVEU6IFFVT1RFLFxuXHRTRU1JOiBTRU1JLFxuXHRTTEFTSDogU0xBU0gsXG5cdFRJTERFOiBUSUxERSxcblx0VU5ERVJTQ09SRTogVU5ERVJTQ09SRSxcblx0RU1PSkk6IEVNT0pJJDEsXG5cdFNZTTogU1lNXG59KTtcblxuLy8gTm90ZSB0aGF0IHRoZXNlIHR3byBVbmljb2RlIG9uZXMgZXhwYW5kIGludG8gYSByZWFsbHkgYmlnIG9uZSB3aXRoIEJhYmVsXG52YXIgQVNDSUlfTEVUVEVSID0gL1thLXpdLztcbnZhciBMRVRURVIgPSAvKD86W0EtWmEtelxceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYwLVxcdTA1ODhcXHUwNUQwLVxcdTA1RUFcXHUwNUVGLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZBXFx1MDg3MC1cXHUwODg3XFx1MDg4OS1cXHUwODhFXFx1MDhBMC1cXHUwOEM5XFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwOUZDXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNURcXHUwQzYwXFx1MEM2MVxcdTBDODBcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNC1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDU0LVxcdTBENTZcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg2LVxcdTBFOEFcXHUwRThDLVxcdTBFQTNcXHUwRUE1XFx1MEVBNy1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkYxLVxcdTE2RjhcXHUxNzAwLVxcdTE3MTFcXHUxNzFGLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3OFxcdTE4ODAtXFx1MTg4NFxcdTE4ODctXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRDXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQzgwLVxcdTFDODhcXHUxQzkwLVxcdTFDQkFcXHUxQ0JELVxcdTFDQkZcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjNcXHUxQ0Y1XFx1MUNGNlxcdTFDRkFcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE4M1xcdTIxODRcXHUyQzAwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJFMkZcXHUzMDA1XFx1MzAwNlxcdTMwMzEtXFx1MzAzNVxcdTMwM0JcXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJGXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJGXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REJGXFx1NEUwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RTVcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3Q0FcXHVBN0QwXFx1QTdEMVxcdUE3RDNcXHVBN0Q1LVxcdUE3RDlcXHVBN0YyLVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE4RkVcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY5XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYyRC1cXHVERjQwXFx1REY0Mi1cXHVERjQ5XFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURENzAtXFx1REQ3QVxcdUREN0MtXFx1REQ4QVxcdUREOEMtXFx1REQ5MlxcdUREOTRcXHVERDk1XFx1REQ5Ny1cXHVEREExXFx1RERBMy1cXHVEREIxXFx1RERCMy1cXHVEREI5XFx1RERCQlxcdUREQkNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjdcXHVERjgwLVxcdURGODVcXHVERjg3LVxcdURGQjBcXHVERkIyLVxcdURGQkFdfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTM1XFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMlxcdUREMDAtXFx1REQyM1xcdURFODAtXFx1REVBOVxcdURFQjBcXHVERUIxXFx1REYwMC1cXHVERjFDXFx1REYyN1xcdURGMzAtXFx1REY0NVxcdURGNzAtXFx1REY4MVxcdURGQjAtXFx1REZDNFxcdURGRTAtXFx1REZGNl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzcxXFx1REM3MlxcdURDNzVcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDQ0XFx1REQ0N1xcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzM0XFx1REM0Ny1cXHVEQzRBXFx1REM1Ri1cXHVEQzYxXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURFQjhcXHVERjAwLVxcdURGMUFcXHVERjQwLVxcdURGNDZdfFxcdUQ4MDZbXFx1REMwMC1cXHVEQzJCXFx1RENBMC1cXHVEQ0RGXFx1RENGRi1cXHVERDA2XFx1REQwOVxcdUREMEMtXFx1REQxM1xcdUREMTVcXHVERDE2XFx1REQxOC1cXHVERDJGXFx1REQzRlxcdURENDFcXHVEREEwLVxcdUREQTdcXHVEREFBLVxcdURERDBcXHVEREUxXFx1RERFM1xcdURFMDBcXHVERTBCLVxcdURFMzJcXHVERTNBXFx1REU1MFxcdURFNUMtXFx1REU4OVxcdURFOURcXHVERUIwLVxcdURFRjhdfFxcdUQ4MDdbXFx1REMwMC1cXHVEQzA4XFx1REMwQS1cXHVEQzJFXFx1REM0MFxcdURDNzItXFx1REM4RlxcdUREMDAtXFx1REQwNlxcdUREMDhcXHVERDA5XFx1REQwQi1cXHVERDMwXFx1REQ0NlxcdURENjAtXFx1REQ2NVxcdURENjdcXHVERDY4XFx1REQ2QS1cXHVERDg5XFx1REQ5OFxcdURFRTAtXFx1REVGMlxcdURGQjBdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDODAtXFx1REQ0M118XFx1RDgwQltcXHVERjkwLVxcdURGRjBdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDgyMlxcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3MlxcdUQ4NzQtXFx1RDg3OVxcdUQ4ODAtXFx1RDg4M11bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REU3MC1cXHVERUJFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURFNDAtXFx1REU3RlxcdURGMDAtXFx1REY0QVxcdURGNTBcXHVERjkzLVxcdURGOUZcXHVERkUwXFx1REZFMVxcdURGRTNdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkY3XXxcXHVEODIzW1xcdURDMDAtXFx1RENENVxcdUREMDAtXFx1REQwOF18XFx1RDgyQltcXHVERkYwLVxcdURGRjNcXHVERkY1LVxcdURGRkJcXHVERkZEXFx1REZGRV18XFx1RDgyQ1tcXHVEQzAwLVxcdUREMjJcXHVERDUwLVxcdURENTJcXHVERDY0LVxcdURENjdcXHVERDcwLVxcdURFRkJdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JdfFxcdUQ4MzdbXFx1REYwMC1cXHVERjFFXXxcXHVEODM4W1xcdUREMDAtXFx1REQyQ1xcdUREMzctXFx1REQzRFxcdURENEVcXHVERTkwLVxcdURFQURcXHVERUMwLVxcdURFRUJdfFxcdUQ4MzlbXFx1REZFMC1cXHVERkU2XFx1REZFOC1cXHVERkVCXFx1REZFRFxcdURGRUVcXHVERkYwLVxcdURGRkVdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1REQwMC1cXHVERDQzXFx1REQ0Ql18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVERlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzhcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMVxcdURFQjAtXFx1REZGRl18XFx1RDg3QVtcXHVEQzAwLVxcdURGRTBdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXXxcXHVEODg0W1xcdURDMDAtXFx1REY0QV0pLzsgLy8gQW55IFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggbGV0dGVyIGRhdGEgdHlwZVxuXG52YXIgRU1PSkkgPSAvKD86WyNcXCowLTlcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA0XFx1MjYwRVxcdTI2MTFcXHUyNjE0XFx1MjYxNVxcdTI2MThcXHUyNjFEXFx1MjYyMFxcdTI2MjJcXHUyNjIzXFx1MjYyNlxcdTI2MkFcXHUyNjJFXFx1MjYyRlxcdTI2MzgtXFx1MjYzQVxcdTI2NDBcXHUyNjQyXFx1MjY0OC1cXHUyNjUzXFx1MjY1RlxcdTI2NjBcXHUyNjYzXFx1MjY2NVxcdTI2NjZcXHUyNjY4XFx1MjY3QlxcdTI2N0VcXHUyNjdGXFx1MjY5Mi1cXHUyNjk3XFx1MjY5OVxcdTI2OUJcXHUyNjlDXFx1MjZBMFxcdTI2QTFcXHUyNkE3XFx1MjZBQVxcdTI2QUJcXHUyNkIwXFx1MjZCMVxcdTI2QkRcXHUyNkJFXFx1MjZDNFxcdTI2QzVcXHUyNkM4XFx1MjZDRVxcdTI2Q0ZcXHUyNkQxXFx1MjZEM1xcdTI2RDRcXHUyNkU5XFx1MjZFQVxcdTI2RjAtXFx1MjZGNVxcdTI2RjctXFx1MjZGQVxcdTI2RkRcXHUyNzAyXFx1MjcwNVxcdTI3MDgtXFx1MjcwRFxcdTI3MEZcXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2M1xcdTI3NjRcXHUyNzk1LVxcdTI3OTdcXHUyN0ExXFx1MjdCMFxcdTI3QkZcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURDMDRcXHVEQ0NGXFx1REQ3MFxcdURENzFcXHVERDdFXFx1REQ3RlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREU2LVxcdURERkZcXHVERTAxXFx1REUwMlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGMjFcXHVERjI0LVxcdURGOTNcXHVERjk2XFx1REY5N1xcdURGOTktXFx1REY5QlxcdURGOUUtXFx1REZGMFxcdURGRjMtXFx1REZGNVxcdURGRjctXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURDRkRcXHVEQ0ZGLVxcdUREM0RcXHVERDQ5LVxcdURENEVcXHVERDUwLVxcdURENjdcXHVERDZGXFx1REQ3MFxcdURENzMtXFx1REQ3QVxcdUREODdcXHVERDhBLVxcdUREOERcXHVERDkwXFx1REQ5NVxcdUREOTZcXHVEREE0XFx1RERBNVxcdUREQThcXHVEREIxXFx1RERCMlxcdUREQkNcXHVEREMyLVxcdUREQzRcXHVEREQxLVxcdURERDNcXHVERERDLVxcdUREREVcXHVEREUxXFx1RERFM1xcdURERThcXHVEREVGXFx1RERGM1xcdURERkEtXFx1REU0RlxcdURFODAtXFx1REVDNVxcdURFQ0ItXFx1REVEMlxcdURFRDUtXFx1REVEN1xcdURFREQtXFx1REVFNVxcdURFRTlcXHVERUVCXFx1REVFQ1xcdURFRjBcXHVERUYzLVxcdURFRkNcXHVERkUwLVxcdURGRUJcXHVERkYwXXxcXHVEODNFW1xcdUREMEMtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1RERGRlxcdURFNzAtXFx1REU3NFxcdURFNzgtXFx1REU3Q1xcdURFODAtXFx1REU4NlxcdURFOTAtXFx1REVBQ1xcdURFQjAtXFx1REVCQVxcdURFQzAtXFx1REVDNVxcdURFRDAtXFx1REVEOVxcdURFRTAtXFx1REVFN1xcdURFRjAtXFx1REVGNl0pLzsgLy8gQW55IFVuaWNvZGUgZW1vamkgY2hhcmFjdGVyXG5cbnZhciBFTU9KSV9WQVJJQVRJT04kMSA9IC9cXHVmZTBmLztcbnZhciBESUdJVCA9IC9cXGQvO1xudmFyIFNQQUNFID0gL1xccy87XG5cbnZhciByZWdleHAgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0QVNDSUlfTEVUVEVSOiBBU0NJSV9MRVRURVIsXG5cdExFVFRFUjogTEVUVEVSLFxuXHRFTU9KSTogRU1PSkksXG5cdEVNT0pJX1ZBUklBVElPTjogRU1PSklfVkFSSUFUSU9OJDEsXG5cdERJR0lUOiBESUdJVCxcblx0U1BBQ0U6IFNQQUNFXG59KTtcblxuLyoqXG5cdFRoZSBzY2FubmVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSB0aGF0IHRha2VzIGEgc3RyaW5nIG9mIHRleHQgYXMgaW5wdXQsIGFuZFxuXHRvdXRwdXRzIGFuIGFycmF5IG9mIHRva2VucyBpbnN0YW5jZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZWFzeSBVUkwgcGFyc2luZy5cbiovXG52YXIgTkwgPSAnXFxuJzsgLy8gTmV3IGxpbmUgY2hhcmFjdGVyXG5cbnZhciBFTU9KSV9WQVJJQVRJT04gPSBcIlxcdUZFMEZcIjsgLy8gVmFyaWF0aW9uIHNlbGVjdG9yLCBmb2xsb3dzIGhlYXJ0IGFuZCBvdGhlcnNcblxudmFyIEVNT0pJX0pPSU5FUiA9IFwiXFx1MjAwRFwiOyAvLyB6ZXJvLXdpZHRoIGpvaW5lclxuXG4vKipcbiAqIFNjYW5uZXIgb3V0cHV0IHRva2VuOlxuICogLSBgdGAgaXMgdGhlIHRva2VuIG5hbWUgKGUuZy4sICdOVU0nLCAnRU1PSkknLCAnVExEJylcbiAqIC0gYHZgIGlzIHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4gKGUuZy4sICcxMjMnLCAn4p2k77iPJywgJ2NvbScpXG4gKiAtIGBzYCBpcyB0aGUgc3RhcnQgaW5kZXggb2YgdGhlIHRva2VuIGluIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAqIC0gYGVgIGlzIHRoZSBlbmQgaW5kZXggb2YgdGhlIHRva2VuIGluIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAqIEB0eXBlZGVmIHt7dDogc3RyaW5nLCB2OiBzdHJpbmcsIHM6IG51bWJlciwgZTogbnVtYmVyfX0gVG9rZW5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7eyBbY29sbGVjdGlvbjogc3RyaW5nXTogVFtdIH19IENvbGxlY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBzY2FubmVyIGNoYXJhY3Rlci1iYXNlZCBzdGF0ZSBtYWNoaW5lIGZvciB0aGUgZ2l2ZW4gc3RhcnRcbiAqIHN0YXRlXG4gKiBAcGFyYW0ge1tzdHJpbmcsIGJvb2xlYW5dW119IGN1c3RvbVNjaGVtZXMgTGlzdCBvZiBjdXN0b20gc2NoZW1lcywgd2hlcmUgZWFjaFxuICogaXRlbSBpcyBhIGxlbmd0aC0yIHR1cGxlIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgc2V0IHRvIHRoZSBzdHJpbmcgc2NoZW1lLCBhbmRcbiAqIHRoZSBzZWNvbmQgZWxlbWVudCBzZXQgdG8gYHRydWVgIGlmIHRoZSBgOi8vYCBhZnRlciB0aGUgc2NoZW1lIGlzIG9wdGlvbmFsXG4gKi9cblxuZnVuY3Rpb24gaW5pdCQyKGN1c3RvbVNjaGVtZXMpIHtcbiAgdmFyIF90ciwgX3RyMiwgX3RyMywgX3RyNCwgX3R0LCBfdHI1O1xuXG4gIGlmIChjdXN0b21TY2hlbWVzID09PSB2b2lkIDApIHtcbiAgICBjdXN0b21TY2hlbWVzID0gW107XG4gIH1cblxuICAvLyBGcmVxdWVudGx5IHVzZWQgc3RhdGVzIChuYW1lIGFyZ3VtZW50IHJlbW92ZWQgZHVyaW5nIG1pbmlmaWNhdGlvbilcblxuICAvKiogQHR5cGUgQ29sbGVjdGlvbnM8c3RyaW5nPiAqL1xuICB2YXIgZ3JvdXBzID0ge307IC8vIG9mIHRva2Vuc1xuXG4gIFN0YXRlLmdyb3VwcyA9IGdyb3VwcztcbiAgLyoqIEB0eXBlIFN0YXRlPHN0cmluZz4gKi9cblxuICB2YXIgU3RhcnQgPSBuZXcgU3RhdGUoKTsgLy8gU3RhdGVzIGZvciBzcGVjaWFsIFVSTCBzeW1ib2xzIHRoYXQgYWNjZXB0IGltbWVkaWF0ZWx5IGFmdGVyIHN0YXJ0XG5cbiAgdHQoU3RhcnQsIFwiJ1wiLCBBUE9TVFJPUEhFKTtcbiAgdHQoU3RhcnQsICd7JywgT1BFTkJSQUNFKTtcbiAgdHQoU3RhcnQsICdbJywgT1BFTkJSQUNLRVQpO1xuICB0dChTdGFydCwgJzwnLCBPUEVOQU5HTEVCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICcoJywgT1BFTlBBUkVOKTtcbiAgdHQoU3RhcnQsICd9JywgQ0xPU0VCUkFDRSk7XG4gIHR0KFN0YXJ0LCAnXScsIENMT1NFQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnPicsIENMT1NFQU5HTEVCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICcpJywgQ0xPU0VQQVJFTik7XG4gIHR0KFN0YXJ0LCAnJicsIEFNUEVSU0FORCk7XG4gIHR0KFN0YXJ0LCAnKicsIEFTVEVSSVNLKTtcbiAgdHQoU3RhcnQsICdAJywgQVQpO1xuICB0dChTdGFydCwgJ2AnLCBCQUNLVElDSyk7XG4gIHR0KFN0YXJ0LCAnXicsIENBUkVUKTtcbiAgdHQoU3RhcnQsICc6JywgQ09MT04pO1xuICB0dChTdGFydCwgJywnLCBDT01NQSk7XG4gIHR0KFN0YXJ0LCAnJCcsIERPTExBUik7XG4gIHR0KFN0YXJ0LCAnLicsIERPVCk7XG4gIHR0KFN0YXJ0LCAnPScsIEVRVUFMUyk7XG4gIHR0KFN0YXJ0LCAnIScsIEVYQ0xBTUFUSU9OKTtcbiAgdHQoU3RhcnQsICctJywgSFlQSEVOKTtcbiAgdHQoU3RhcnQsICclJywgUEVSQ0VOVCk7XG4gIHR0KFN0YXJ0LCAnfCcsIFBJUEUpO1xuICB0dChTdGFydCwgJysnLCBQTFVTKTtcbiAgdHQoU3RhcnQsICcjJywgUE9VTkQpO1xuICB0dChTdGFydCwgJz8nLCBRVUVSWSk7XG4gIHR0KFN0YXJ0LCAnXCInLCBRVU9URSk7XG4gIHR0KFN0YXJ0LCAnLycsIFNMQVNIKTtcbiAgdHQoU3RhcnQsICc7JywgU0VNSSk7XG4gIHR0KFN0YXJ0LCAnficsIFRJTERFKTtcbiAgdHQoU3RhcnQsICdfJywgVU5ERVJTQ09SRSk7XG4gIHR0KFN0YXJ0LCAnXFxcXCcsIEJBQ0tTTEFTSCk7XG4gIHZhciBOdW0gPSB0cihTdGFydCwgRElHSVQsIE5VTSwgKF90ciA9IHt9LCBfdHJbbnVtZXJpY10gPSB0cnVlLCBfdHIpKTtcbiAgdHIoTnVtLCBESUdJVCwgTnVtKTsgLy8gU3RhdGUgd2hpY2ggZW1pdHMgYSB3b3JkIHRva2VuXG5cbiAgdmFyIFdvcmQgPSB0cihTdGFydCwgQVNDSUlfTEVUVEVSLCBXT1JELCAoX3RyMiA9IHt9LCBfdHIyW2FzY2lpXSA9IHRydWUsIF90cjIpKTtcbiAgdHIoV29yZCwgQVNDSUlfTEVUVEVSLCBXb3JkKTsgLy8gU2FtZSBhcyBwcmV2aW91cywgYnV0IHNwZWNpZmljIHRvIG5vbi1mc20uYXNjaWkgYWxwaGFiZXQgd29yZHNcblxuICB2YXIgVVdvcmQgPSB0cihTdGFydCwgTEVUVEVSLCBVV09SRCwgKF90cjMgPSB7fSwgX3RyM1thbHBoYV0gPSB0cnVlLCBfdHIzKSk7XG4gIHRyKFVXb3JkLCBBU0NJSV9MRVRURVIpOyAvLyBOb24tYWNjZXB0aW5nXG5cbiAgdHIoVVdvcmQsIExFVFRFUiwgVVdvcmQpOyAvLyBXaGl0ZXNwYWNlIGp1bXBzXG4gIC8vIFRva2VucyBvZiBvbmx5IG5vbi1uZXdsaW5lIHdoaXRlc3BhY2UgYXJlIGFyYml0cmFyaWx5IGxvbmdcbiAgLy8gSWYgYW55IHdoaXRlc3BhY2UgZXhjZXB0IG5ld2xpbmUsIG1vcmUgd2hpdGVzcGFjZSFcblxuICB2YXIgV3MgPSB0cihTdGFydCwgU1BBQ0UsIFdTLCAoX3RyNCA9IHt9LCBfdHI0W3doaXRlc3BhY2VdID0gdHJ1ZSwgX3RyNCkpO1xuICB0dChTdGFydCwgTkwsIE5MJDEsIChfdHQgPSB7fSwgX3R0W3doaXRlc3BhY2VdID0gdHJ1ZSwgX3R0KSk7XG4gIHR0KFdzLCBOTCk7IC8vIG5vbi1hY2NlcHRpbmcgc3RhdGUgdG8gYXZvaWQgbWl4aW5nIHdoaXRlc3BhY2VzXG5cbiAgdHIoV3MsIFNQQUNFLCBXcyk7IC8vIEVtb2ppIHRva2Vucy4gVGhleSBhcmUgbm90IGdyb3VwZWQgYnkgdGhlIHNjYW5uZXIgZXhjZXB0IGluIGNhc2VzIHdoZXJlIGFcbiAgLy8gemVyby13aWR0aCBqb2luZXIgaXMgcHJlc2VudFxuXG4gIHZhciBFbW9qaSA9IHRyKFN0YXJ0LCBFTU9KSSwgRU1PSkkkMSwgKF90cjUgPSB7fSwgX3RyNVtlbW9qaV0gPSB0cnVlLCBfdHI1KSk7XG4gIHRyKEVtb2ppLCBFTU9KSSwgRW1vamkpO1xuICB0dChFbW9qaSwgRU1PSklfVkFSSUFUSU9OLCBFbW9qaSk7IC8vIHR0KFN0YXJ0LCBFTU9KSV9WQVJJQVRJT04sIEVtb2ppKTsgLy8gVGhpcyBvbmUgaXMgc2tldGNoeVxuXG4gIHZhciBFbW9qaUpvaW5lciA9IHR0KEVtb2ppLCBFTU9KSV9KT0lORVIpO1xuICB0cihFbW9qaUpvaW5lciwgRU1PSkksIEVtb2ppKTsgLy8gdHQoRW1vamlKb2luZXIsIEVNT0pJX1ZBUklBVElPTiwgRW1vamkpOyAvLyBhbHNvIHNrZXRjaHlcbiAgLy8gR2VuZXJhdGVzIHN0YXRlcyBmb3IgdG9wLWxldmVsIGRvbWFpbnNcbiAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgbW9zdCBhY2N1cmF0ZSB3aGVuIHRsZHMgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuXG4gIHZhciB3b3JkanIgPSBbW0FTQ0lJX0xFVFRFUiwgV29yZF1dO1xuICB2YXIgdXdvcmRqciA9IFtbQVNDSUlfTEVUVEVSLCBudWxsXSwgW0xFVFRFUiwgVVdvcmRdXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRsZHMubGVuZ3RoOyBpKyspIHtcbiAgICBmYXN0dHMoU3RhcnQsIHRsZHNbaV0sIFRMRCwgV09SRCwgd29yZGpyKTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCB1dGxkcy5sZW5ndGg7IF9pKyspIHtcbiAgICBmYXN0dHMoU3RhcnQsIHV0bGRzW19pXSwgVVRMRCwgVVdPUkQsIHV3b3JkanIpO1xuICB9XG5cbiAgYWRkVG9Hcm91cHMoVExELCB7XG4gICAgdGxkOiB0cnVlLFxuICAgIGFzY2lpOiB0cnVlXG4gIH0sIGdyb3Vwcyk7XG4gIGFkZFRvR3JvdXBzKFVUTEQsIHtcbiAgICB1dGxkOiB0cnVlLFxuICAgIGFscGhhOiB0cnVlXG4gIH0sIGdyb3Vwcyk7IC8vIENvbGxlY3QgdGhlIHN0YXRlcyBnZW5lcmF0ZWQgYnkgZGlmZmVyZW50IHByb3RvY29scy4gTk9URTogSWYgYW55IG5ldyBUTERzXG4gIC8vIGdldCBhZGRlZCB0aGF0IGFyZSBhbHNvIHByb3RvY29scywgc2V0IHRoZSB0b2tlbiB0byBiZSB0aGUgc2FtZSBhcyB0aGVcbiAgLy8gcHJvdG9jb2wgdG8gZW5zdXJlIHBhcnNpbmcgd29ya3MgYXMgZXhwZWN0ZWQuXG5cbiAgZmFzdHRzKFN0YXJ0LCAnZmlsZScsIFNDSEVNRSwgV09SRCwgd29yZGpyKTtcbiAgZmFzdHRzKFN0YXJ0LCAnbWFpbHRvJywgU0NIRU1FLCBXT1JELCB3b3JkanIpO1xuICBmYXN0dHMoU3RhcnQsICdodHRwJywgU0xBU0hfU0NIRU1FLCBXT1JELCB3b3JkanIpO1xuICBmYXN0dHMoU3RhcnQsICdodHRwcycsIFNMQVNIX1NDSEVNRSwgV09SRCwgd29yZGpyKTtcbiAgZmFzdHRzKFN0YXJ0LCAnZnRwJywgU0xBU0hfU0NIRU1FLCBXT1JELCB3b3JkanIpO1xuICBmYXN0dHMoU3RhcnQsICdmdHBzJywgU0xBU0hfU0NIRU1FLCBXT1JELCB3b3JkanIpO1xuICBhZGRUb0dyb3VwcyhTQ0hFTUUsIHtcbiAgICBzY2hlbWU6IHRydWUsXG4gICAgYXNjaWk6IHRydWVcbiAgfSwgZ3JvdXBzKTtcbiAgYWRkVG9Hcm91cHMoU0xBU0hfU0NIRU1FLCB7XG4gICAgc2xhc2hzY2hlbWU6IHRydWUsXG4gICAgYXNjaWk6IHRydWVcbiAgfSwgZ3JvdXBzKTsgLy8gUmVnaXN0ZXIgY3VzdG9tIHNjaGVtZXMuIEFzc3VtZXMgZWFjaCBzY2hlbWUgaXMgYXNjaWludW1lcmljIHdpdGggaHlwaGVuc1xuXG4gIGN1c3RvbVNjaGVtZXMgPSBjdXN0b21TY2hlbWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA+IGJbMF0gPyAxIDogLTE7XG4gIH0pO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGN1c3RvbVNjaGVtZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfcmVmLCBfcmVmMjtcblxuICAgIHZhciBzY2ggPSBjdXN0b21TY2hlbWVzW19pMl1bMF07XG4gICAgdmFyIG9wdGlvbmFsU2xhc2hTbGFzaCA9IGN1c3RvbVNjaGVtZXNbX2kyXVsxXTtcbiAgICB2YXIgZmxhZ3MgPSBvcHRpb25hbFNsYXNoU2xhc2ggPyAoX3JlZiA9IHt9LCBfcmVmW3NjaGVtZV0gPSB0cnVlLCBfcmVmKSA6IChfcmVmMiA9IHt9LCBfcmVmMltzbGFzaHNjaGVtZV0gPSB0cnVlLCBfcmVmMik7XG5cbiAgICBpZiAoc2NoLmluZGV4T2YoJy0nKSA+PSAwKSB7XG4gICAgICBmbGFnc1tkb21haW5dID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFBU0NJSV9MRVRURVIudGVzdChzY2gpKSB7XG4gICAgICBmbGFnc1tudW1lcmljXSA9IHRydWU7IC8vIG51bWJlcnMgb25seVxuICAgIH0gZWxzZSBpZiAoRElHSVQudGVzdChzY2gpKSB7XG4gICAgICBmbGFnc1thc2NpaW51bWVyaWNdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxhZ3NbYXNjaWldID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cyhTdGFydCwgc2NoLCBzY2gsIGZsYWdzKTtcbiAgfSAvLyBMb2NhbGhvc3QgdG9rZW5cblxuXG4gIHRzKFN0YXJ0LCAnbG9jYWxob3N0JywgTE9DQUxIT1NULCB7XG4gICAgYXNjaWk6IHRydWVcbiAgfSk7IC8vIFNldCBkZWZhdWx0IHRyYW5zaXRpb24gZm9yIHN0YXJ0IHN0YXRlIChzb21lIHN5bWJvbClcblxuICBTdGFydC5qZCA9IG5ldyBTdGF0ZShTWU0pO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBTdGFydCxcbiAgICB0b2tlbnM6IGFzc2lnbih7XG4gICAgICBncm91cHM6IGdyb3Vwc1xuICAgIH0sIHRrKVxuICB9O1xufVxuLyoqXG5cdEdpdmVuIGEgc3RyaW5nLCByZXR1cm5zIGFuIGFycmF5IG9mIFRPS0VOIGluc3RhbmNlcyByZXByZXNlbnRpbmcgdGhlXG5cdGNvbXBvc2l0aW9uIG9mIHRoYXQgc3RyaW5nLlxuXG5cdEBtZXRob2QgcnVuXG5cdEBwYXJhbSB7U3RhdGU8c3RyaW5nPn0gc3RhcnQgc2Nhbm5lciBzdGFydGluZyBzdGF0ZVxuXHRAcGFyYW0ge3N0cmluZ30gc3RyIGlucHV0IHN0cmluZyB0byBzY2FuXG5cdEByZXR1cm4ge1Rva2VuW119IGxpc3Qgb2YgdG9rZW5zLCBlYWNoIHdpdGggYSB0eXBlIGFuZCB2YWx1ZVxuKi9cblxuZnVuY3Rpb24gcnVuJDEoc3RhcnQsIHN0cikge1xuICAvLyBTdGF0ZSBtYWNoaW5lIGlzIG5vdCBjYXNlIHNlbnNpdGl2ZSwgc28gaW5wdXQgaXMgdG9rZW5pemVkIGluIGxvd2VyY2FzZWRcbiAgLy8gZm9ybSAoc3RpbGwgcmV0dXJucyByZWd1bGFyIGNhc2UpLiBVc2VzIHNlbGVjdGl2ZSBgdG9Mb3dlckNhc2VgIGJlY2F1c2VcbiAgLy8gbG93ZXJjYXNpbmcgdGhlIGVudGlyZSBzdHJpbmcgY2F1c2VzIHRoZSBsZW5ndGggYW5kIGNoYXJhY3RlciBwb3NpdGlvbiB0b1xuICAvLyB2YXJ5IGluIHNvbWUgbm9uLUVuZ2xpc2ggc3RyaW5ncyB3aXRoIFY4LWJhc2VkIHJ1bnRpbWVzLlxuICB2YXIgaXRlcmFibGUgPSBzdHJpbmdUb0FycmF5KHN0ci5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiBjLnRvTG93ZXJDYXNlKCk7XG4gIH0pKTtcbiAgdmFyIGNoYXJDb3VudCA9IGl0ZXJhYmxlLmxlbmd0aDsgLy8gPD0gbGVuIGlmIHRoZXJlIGFyZSBlbW9qaXMsIGV0Y1xuXG4gIHZhciB0b2tlbnMgPSBbXTsgLy8gcmV0dXJuIHZhbHVlXG4gIC8vIGN1cnNvciB0aHJvdWdoIHRoZSBzdHJpbmcgaXRzZWxmLCBhY2NvdW50aW5nIGZvciBjaGFyYWN0ZXJzIHRoYXQgaGF2ZVxuICAvLyB3aWR0aCB3aXRoIGxlbmd0aCAyIHN1Y2ggYXMgZW1vamlzXG5cbiAgdmFyIGN1cnNvciA9IDA7IC8vIEN1cnNvciB0aHJvdWdoIHRoZSBhcnJheS1yZXByZXNlbnRhdGlvbiBvZiB0aGUgc3RyaW5nXG5cbiAgdmFyIGNoYXJDdXJzb3IgPSAwOyAvLyBUb2tlbml6ZSB0aGUgc3RyaW5nXG5cbiAgd2hpbGUgKGNoYXJDdXJzb3IgPCBjaGFyQ291bnQpIHtcbiAgICB2YXIgc3RhdGUgPSBzdGFydDtcbiAgICB2YXIgbmV4dFN0YXRlID0gbnVsbDtcbiAgICB2YXIgdG9rZW5MZW5ndGggPSAwO1xuICAgIHZhciBsYXRlc3RBY2NlcHRpbmcgPSBudWxsO1xuICAgIHZhciBzaW5jZUFjY2VwdHMgPSAtMTtcbiAgICB2YXIgY2hhcnNTaW5jZUFjY2VwdHMgPSAtMTtcblxuICAgIHdoaWxlIChjaGFyQ3Vyc29yIDwgY2hhckNvdW50ICYmIChuZXh0U3RhdGUgPSBzdGF0ZS5nbyhpdGVyYWJsZVtjaGFyQ3Vyc29yXSkpKSB7XG4gICAgICBzdGF0ZSA9IG5leHRTdGF0ZTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGF0ZXN0IGFjY2VwdGluZyBzdGF0ZVxuXG4gICAgICBpZiAoc3RhdGUuYWNjZXB0cygpKSB7XG4gICAgICAgIHNpbmNlQWNjZXB0cyA9IDA7XG4gICAgICAgIGNoYXJzU2luY2VBY2NlcHRzID0gMDtcbiAgICAgICAgbGF0ZXN0QWNjZXB0aW5nID0gc3RhdGU7XG4gICAgICB9IGVsc2UgaWYgKHNpbmNlQWNjZXB0cyA+PSAwKSB7XG4gICAgICAgIHNpbmNlQWNjZXB0cyArPSBpdGVyYWJsZVtjaGFyQ3Vyc29yXS5sZW5ndGg7XG4gICAgICAgIGNoYXJzU2luY2VBY2NlcHRzKys7XG4gICAgICB9XG5cbiAgICAgIHRva2VuTGVuZ3RoICs9IGl0ZXJhYmxlW2NoYXJDdXJzb3JdLmxlbmd0aDtcbiAgICAgIGN1cnNvciArPSBpdGVyYWJsZVtjaGFyQ3Vyc29yXS5sZW5ndGg7XG4gICAgICBjaGFyQ3Vyc29yKys7XG4gICAgfSAvLyBSb2xsIGJhY2sgdG8gdGhlIGxhdGVzdCBhY2NlcHRpbmcgc3RhdGVcblxuXG4gICAgY3Vyc29yIC09IHNpbmNlQWNjZXB0cztcbiAgICBjaGFyQ3Vyc29yIC09IGNoYXJzU2luY2VBY2NlcHRzO1xuICAgIHRva2VuTGVuZ3RoIC09IHNpbmNlQWNjZXB0czsgLy8gTm8gbW9yZSBqdW1wcywganVzdCBtYWtlIGEgbmV3IHRva2VuIGZyb20gdGhlIGxhc3QgYWNjZXB0aW5nIG9uZVxuXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgdDogbGF0ZXN0QWNjZXB0aW5nLnQsXG4gICAgICAvLyB0b2tlbiB0eXBlL25hbWVcbiAgICAgIHY6IHN0ci5zbGljZShjdXJzb3IgLSB0b2tlbkxlbmd0aCwgY3Vyc29yKSxcbiAgICAgIC8vIHN0cmluZyB2YWx1ZVxuICAgICAgczogY3Vyc29yIC0gdG9rZW5MZW5ndGgsXG4gICAgICAvLyBzdGFydCBpbmRleFxuICAgICAgZTogY3Vyc29yIC8vIGVuZCBpbmRleCAoZXhjbHVkaW5nKVxuXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgU3RyaW5nIHRvIGFuIEFycmF5IG9mIGNoYXJhY3RlcnMsIHRha2luZyBpbnRvIGFjY291bnQgdGhhdCBzb21lXG4gKiBjaGFyYWN0ZXJzIGxpa2UgZW1vamlzIHRha2UgdXAgdHdvIHN0cmluZyBpbmRleGVzLlxuICpcbiAqIEFkYXB0ZWQgZnJvbSBjb3JlLWpzIChNSVQgbGljZW5zZSlcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvMmQ2OWNmNWY5OWFiM2VhMzQ2M2MzOTVkZjgxZTVhMTViNjhmNDlkOS9wYWNrYWdlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlLmpzXG4gKlxuICogQGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIHdoaWxlIChpbmRleCA8IGxlbikge1xuICAgIHZhciBmaXJzdCA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICB2YXIgc2Vjb25kID0gdm9pZCAwO1xuICAgIHZhciBjaGFyID0gZmlyc3QgPCAweGQ4MDAgfHwgZmlyc3QgPiAweGRiZmYgfHwgaW5kZXggKyAxID09PSBsZW4gfHwgKHNlY29uZCA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSkpIDwgMHhkYzAwIHx8IHNlY29uZCA+IDB4ZGZmZiA/IHN0cltpbmRleF0gLy8gc2luZ2xlIGNoYXJhY3RlclxuICAgIDogc3RyLnNsaWNlKGluZGV4LCBpbmRleCArIDIpOyAvLyB0d28taW5kZXggY2hhcmFjdGVyc1xuXG4gICAgcmVzdWx0LnB1c2goY2hhcik7XG4gICAgaW5kZXggKz0gY2hhci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBGYXN0IHZlcnNpb24gb2YgdHMgZnVuY3Rpb24gZm9yIHdoZW4gdHJhbnNpdGlvbiBkZWZhdWx0cyBhcmUgd2VsbCBrbm93blxuICogQHBhcmFtIHtTdGF0ZTxzdHJpbmc+fSBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcGFyYW0ge3N0cmluZ30gdFxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHR0XG4gKiBAcGFyYW0ge1tSZWdFeHAsIFN0YXRlPHN0cmluZz5dW119IGpyXG4gKiBAcmV0dXJucyB7U3RhdGU8c3RyaW5nPn1cbiAqL1xuXG5mdW5jdGlvbiBmYXN0dHMoc3RhdGUsIGlucHV0LCB0LCBkZWZhdWx0dCwganIpIHtcbiAgdmFyIG5leHQ7XG4gIHZhciBsZW4gPSBpbnB1dC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICB2YXIgY2hhciA9IGlucHV0W2ldO1xuXG4gICAgaWYgKHN0YXRlLmpbY2hhcl0pIHtcbiAgICAgIG5leHQgPSBzdGF0ZS5qW2NoYXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0ID0gbmV3IFN0YXRlKGRlZmF1bHR0KTtcbiAgICAgIG5leHQuanIgPSBqci5zbGljZSgpO1xuICAgICAgc3RhdGUualtjaGFyXSA9IG5leHQ7XG4gICAgfVxuXG4gICAgc3RhdGUgPSBuZXh0O1xuICB9XG5cbiAgbmV4dCA9IG5ldyBTdGF0ZSh0KTtcbiAgbmV4dC5qciA9IGpyLnNsaWNlKCk7XG4gIHN0YXRlLmpbaW5wdXRbbGVuIC0gMV1dID0gbmV4dDtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcblxuICBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuLyoqXG4gKiBBbiBvYmplY3Qgd2hlcmUgZWFjaCBrZXkgaXMgYSB2YWxpZCBET00gRXZlbnQgTmFtZSBzdWNoIGFzIGBjbGlja2Agb3IgYGZvY3VzYFxuICogYW5kIGVhY2ggdmFsdWUgaXMgYW4gZXZlbnQgaGFuZGxlciBmdW5jdGlvbi5cbiAqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudCNldmVudHNcbiAqIEB0eXBlZGVmIHs/eyBbZXZlbnQ6IHN0cmluZ106IEZ1bmN0aW9uIH19IEV2ZW50TGlzdGVuZXJzXG4gKi9cblxuLyoqXG4gKiBBbGwgZm9ybWF0dGVkIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gcmVuZGVyIGEgbGluaywgaW5jbHVkaW5nIGB0YWdOYW1lYCxcbiAqIGBhdHRyaWJ1dGVzYCwgYGNvbnRlbnRgIGFuZCBgZXZlbnRMaXN0ZW5lcnNgLlxuICogQHR5cGVkZWYge3sgdGFnTmFtZTogYW55LCBhdHRyaWJ1dGVzOiB7W2F0dHI6IHN0cmluZ106IGFueX0sIGNvbnRlbnQ6IHN0cmluZyxcbiAqIGV2ZW50TGlzdGVuZXJzOiBFdmVudExpc3RlbmVycyB9fSBJbnRlcm1lZGlhdGVSZXByZXNlbnRhdGlvblxuICovXG5cbi8qKlxuICogU3BlY2lmeSBlaXRoZXIgYW4gb2JqZWN0IGRlc2NyaWJlZCBieSB0aGUgdGVtcGxhdGUgdHlwZSBgT2Agb3IgYSBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gdGFrZXMgYSBzdHJpbmcgdmFsdWUgKHVzdWFsbHkgdGhlIGxpbmsncyBocmVmIGF0dHJpYnV0ZSksIHRoZVxuICogbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikgYW5kIGFuIGludGVybmFsIHRva2VuIHJlcHJlc2VudGF0aW9uXG4gKiBvZiB0aGUgbGluay4gSXQgc2hvdWxkIHJldHVybiBhbiBvYmplY3Qgb2YgdGhlIHRlbXBsYXRlIHR5cGUgYE9gXG4gKiBAdGVtcGxhdGUgT1xuICogQHR5cGVkZWYge08gfCAoKHZhbHVlOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgdG9rZW46IE11bHRpVG9rZW4pID0+IE8pfSBPcHRPYmpcbiAqL1xuXG4vKipcbiAqIFNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gZGVzY3JpYmVkIGJ5IHRlbXBsYXRlIHR5cGUgYEZgIG9yIGFuIG9iamVjdC5cbiAqXG4gKiBFYWNoIGtleSBpbiB0aGUgb2JqZWN0IHNob3VsZCBiZSBhIGxpbmsgdHlwZSAoYCd1cmwnYCwgYCdoYXNodGFnYCcsIGV0Yy4pLiBFYWNoXG4gKiB2YWx1ZSBzaG91bGQgYmUgYSBmdW5jdGlvbiB3aXRoIHRlbXBsYXRlIHR5cGUgYEZgIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlXG4gKiBjb3JyZXNwb25kaW5nIGxpbmsgdHlwZSBpcyBlbmNvdW50ZXJlZC5cbiAqIEB0ZW1wbGF0ZSBGXG4gKiBAdHlwZWRlZiB7RiB8IHsgW3R5cGU6IHN0cmluZ106IEZ9fSBPcHRGblxuICovXG5cbi8qKlxuICogU3BlY2lmeSBlaXRoZXIgYSB2YWx1ZSB3aXRoIHRlbXBsYXRlIHR5cGUgYFZgLCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgVmAgb3JcbiAqIGFuIG9iamVjdCB3aGVyZSBlYWNoIHZhbHVlIHJlc29sdmVzIHRvIGBWYC5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gdGFrZXMgYSBzdHJpbmcgdmFsdWUgKHVzdWFsbHkgdGhlIGxpbmsncyBocmVmIGF0dHJpYnV0ZSksIHRoZVxuICogbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikgYW5kIGFuIGludGVybmFsIHRva2VuIHJlcHJlc2VudGF0aW9uXG4gKiBvZiB0aGUgbGluay4gSXQgc2hvdWxkIHJldHVybiBhbiBvYmplY3Qgb2YgdGhlIHRlbXBsYXRlIHR5cGUgYFZgXG4gKlxuICogRm9yIHRoZSBvYmplY3QsIGVhY2gga2V5IHNob3VsZCBiZSBhIGxpbmsgdHlwZSAoYCd1cmwnYCwgYCdoYXNodGFnYCcsIGV0Yy4pLlxuICogRWFjaCB2YWx1ZSBzaG91bGQgZWl0aGVyIGhhdmUgdHlwZSBgVmAgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgVi4gVGhpc1xuICogZnVuY3Rpb24gc2ltaWxhcmx5IHRha2VzIGEgc3RyaW5nIHZhbHVlIGFuZCBhIHRva2VuLlxuICpcbiAqIEV4YW1wbGUgdmFsaWQgdHlwZXMgZm9yIGBPcHQ8c3RyaW5nPmA6XG4gKlxuICogYGBganNcbiAqICdoZWxsbydcbiAqICh2YWx1ZSwgdHlwZSwgdG9rZW4pID0+ICd3b3JsZCdcbiAqIHsgdXJsOiAnaGVsbG8nLCBlbWFpbDogKHZhbHVlLCB0b2tlbikgPT4gJ3dvcmxkJ31cbiAqIGBgYFxuICogQHRlbXBsYXRlIFZcbiAqIEB0eXBlZGVmIHtWIHwgKCh2YWx1ZTogc3RyaW5nLCB0eXBlOiBzdHJpbmcsIHRva2VuOiBNdWx0aVRva2VuKSA9PiBWKSB8IHsgW3R5cGU6IHN0cmluZ106IFYgfCAoKHZhbHVlOiBzdHJpbmcsIHRva2VuOiBNdWx0aVRva2VuKSA9PiBWKSB9fSBPcHRcbiAqL1xuXG4vKipcbiAqIFNlZSBhdmFpbGFibGUgb3B0aW9uczogaHR0cHM6Ly9saW5raWZ5LmpzLm9yZy9kb2NzL29wdGlvbnMuaHRtbFxuICogQHR5cGVkZWYge3tcbiAqIFx0ZGVmYXVsdFByb3RvY29sPzogc3RyaW5nLFxuICogIGV2ZW50cz86IE9wdE9iajxFdmVudExpc3RlbmVycz4sXG4gKiBcdGZvcm1hdD86IE9wdDxzdHJpbmc+LFxuICogXHRmb3JtYXRIcmVmPzogT3B0PHN0cmluZz4sXG4gKiBcdG5sMmJyPzogYm9vbGVhbixcbiAqIFx0dGFnTmFtZT86IE9wdDxhbnk+LFxuICogXHR0YXJnZXQ/OiBPcHQ8c3RyaW5nPixcbiAqIFx0cmVsPzogT3B0PHN0cmluZz4sXG4gKiBcdHZhbGlkYXRlPzogT3B0PGJvb2xlYW4+LFxuICogXHR0cnVuY2F0ZT86IE9wdDxudW1iZXI+LFxuICogXHRjbGFzc05hbWU/OiBPcHQ8c3RyaW5nPixcbiAqIFx0YXR0cmlidXRlcz86IE9wdE9iajwoeyBbYXR0cjogc3RyaW5nXTogYW55IH0pPixcbiAqICBpZ25vcmVUYWdzPzogc3RyaW5nW10sXG4gKiBcdHJlbmRlcj86IE9wdEZuPCgoaXI6IEludGVybWVkaWF0ZVJlcHJlc2VudGF0aW9uKSA9PiBhbnkpPlxuICogfX0gT3B0c1xuICovXG5cbi8qKlxuICogQHR5cGUgUmVxdWlyZWQ8T3B0cz5cbiAqL1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGRlZmF1bHRQcm90b2NvbDogJ2h0dHAnLFxuICBldmVudHM6IG51bGwsXG4gIGZvcm1hdDogbm9vcCxcbiAgZm9ybWF0SHJlZjogbm9vcCxcbiAgbmwyYnI6IGZhbHNlLFxuICB0YWdOYW1lOiAnYScsXG4gIHRhcmdldDogbnVsbCxcbiAgcmVsOiBudWxsLFxuICB2YWxpZGF0ZTogdHJ1ZSxcbiAgdHJ1bmNhdGU6IEluZmluaXR5LFxuICBjbGFzc05hbWU6IG51bGwsXG4gIGF0dHJpYnV0ZXM6IG51bGwsXG4gIGlnbm9yZVRhZ3M6IFtdLFxuICByZW5kZXI6IG51bGxcbn07XG4vKipcbiAqIFV0aWxpdHkgY2xhc3MgZm9yIGxpbmtpZnkgaW50ZXJmYWNlcyB0byBhcHBseSBzcGVjaWZpZWRcbiAqIHtAbGluayBPcHRzIGZvcm1hdHRpbmcgYW5kIHJlbmRlcmluZyBvcHRpb25zfS5cbiAqXG4gKiBAcGFyYW0ge09wdHMgfCBPcHRpb25zfSBbb3B0c10gT3B0aW9uIHZhbHVlIG92ZXJyaWRlcy5cbiAqIEBwYXJhbSB7KGlyOiBJbnRlcm1lZGlhdGVSZXByZXNlbnRhdGlvbikgPT4gYW55fSBbZGVmYXVsdFJlbmRlcl0gKEZvclxuICogICBpbnRlcm5hbCB1c2UpIGRlZmF1bHQgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyBob3cgdG8gZ2VuZXJhdGUgYW5cbiAqICAgSFRNTCBlbGVtZW50IGJhc2VkIG9uIGEgbGluayB0b2tlbidzIGRlcml2ZWQgdGFnTmFtZSwgYXR0cmlidXRlcyBhbmQgSFRNTC5cbiAqICAgU2ltaWxhciB0byByZW5kZXIgb3B0aW9uXG4gKi9cblxuZnVuY3Rpb24gT3B0aW9ucyhvcHRzLCBkZWZhdWx0UmVuZGVyKSB7XG4gIGlmIChkZWZhdWx0UmVuZGVyID09PSB2b2lkIDApIHtcbiAgICBkZWZhdWx0UmVuZGVyID0gbnVsbDtcbiAgfVxuXG4gIHZhciBvID0gYXNzaWduKHt9LCBkZWZhdWx0cyk7XG5cbiAgaWYgKG9wdHMpIHtcbiAgICBvID0gYXNzaWduKG8sIG9wdHMgaW5zdGFuY2VvZiBPcHRpb25zID8gb3B0cy5vIDogb3B0cyk7XG4gIH0gLy8gRW5zdXJlIGFsbCBpZ25vcmVkIHRhZ3MgYXJlIHVwcGVyY2FzZVxuXG5cbiAgdmFyIGlnbm9yZWRUYWdzID0gby5pZ25vcmVUYWdzO1xuICB2YXIgdXBwZXJjYXNlSWdub3JlZFRhZ3MgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGlnbm9yZWRUYWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdXBwZXJjYXNlSWdub3JlZFRhZ3MucHVzaChpZ25vcmVkVGFnc1tpXS50b1VwcGVyQ2FzZSgpKTtcbiAgfVxuICAvKiogQHByb3RlY3RlZCAqL1xuXG5cbiAgdGhpcy5vID0gbztcblxuICBpZiAoZGVmYXVsdFJlbmRlcikge1xuICAgIHRoaXMuZGVmYXVsdFJlbmRlciA9IGRlZmF1bHRSZW5kZXI7XG4gIH1cblxuICB0aGlzLmlnbm9yZVRhZ3MgPSB1cHBlcmNhc2VJZ25vcmVkVGFncztcbn1cbk9wdGlvbnMucHJvdG90eXBlID0ge1xuICBvOiBkZWZhdWx0cyxcblxuICAvKipcbiAgICogQHR5cGUgc3RyaW5nW11cbiAgICovXG4gIGlnbm9yZVRhZ3M6IFtdLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0ludGVybWVkaWF0ZVJlcHJlc2VudGF0aW9ufSBpclxuICAgKiBAcmV0dXJucyB7YW55fVxuICAgKi9cbiAgZGVmYXVsdFJlbmRlcjogZnVuY3Rpb24gZGVmYXVsdFJlbmRlcihpcikge1xuICAgIHJldHVybiBpcjtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGJhc2VkIG9uIHdoZXRoZXIgYSB0b2tlbiBzaG91bGQgYmUgZGlzcGxheWVkIGFzIGFcbiAgICogbGluayBiYXNlZCBvbiB0aGUgdXNlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge011bHRpVG9rZW59IHRva2VuXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY2hlY2s6IGZ1bmN0aW9uIGNoZWNrKHRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCd2YWxpZGF0ZScsIHRva2VuLnRvU3RyaW5nKCksIHRva2VuKTtcbiAgfSxcbiAgLy8gUHJpdmF0ZSBtZXRob2RzXG5cbiAgLyoqXG4gICAqIFJlc29sdmUgYW4gb3B0aW9uJ3MgdmFsdWUgYmFzZWQgb24gdGhlIHZhbHVlIG9mIHRoZSBvcHRpb24gYW5kIHRoZSBnaXZlblxuICAgKiBwYXJhbXMuIElmIG9wZXJhdG9yIGFuZCB0b2tlbiBhcmUgc3BlY2lmaWVkIGFuZCB0aGUgdGFyZ2V0IG9wdGlvbiBpc1xuICAgKiBjYWxsYWJsZSwgYXV0b21hdGljYWxseSBjYWxscyB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnQuXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgT3B0c30gS1xuICAgKiBAcGFyYW0ge0t9IGtleSBOYW1lIG9mIG9wdGlvbiB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcGVyYXRvcl0gd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHRhcmdldCBvcHRpb24gaWYgaXQncyBhXG4gICAqIGZ1bmN0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCBSQVcgZnVuY3Rpb24gdmFsdWUgZ2V0cyByZXR1cm5lZFxuICAgKiBAcGFyYW0ge011bHRpVG9rZW59IFt0b2tlbl0gVGhlIHRva2VuIGZyb20gbGlua2lmeS50b2tlbml6ZVxuICAgKiBAcmV0dXJucyB7T3B0c1tLXSB8IGFueX1cbiAgICovXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSwgb3BlcmF0b3IsIHRva2VuKSB7XG4gICAgdmFyIGlzQ2FsbGFibGUgPSBvcGVyYXRvciAhPSBudWxsO1xuICAgIHZhciBvcHRpb24gPSB0aGlzLm9ba2V5XTtcblxuICAgIGlmICghb3B0aW9uKSB7XG4gICAgICByZXR1cm4gb3B0aW9uO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9uID0gdG9rZW4udCBpbiBvcHRpb24gPyBvcHRpb25bdG9rZW4udF0gOiBkZWZhdWx0c1trZXldO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0NhbGxhYmxlKSB7XG4gICAgICAgIG9wdGlvbiA9IG9wdGlvbihvcGVyYXRvciwgdG9rZW4pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0NhbGxhYmxlKSB7XG4gICAgICBvcHRpb24gPSBvcHRpb24ob3BlcmF0b3IsIHRva2VuLnQsIHRva2VuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUge2tleW9mIE9wdHN9IExcbiAgICogQHBhcmFtIHtMfSBrZXkgTmFtZSBvZiBvcHRpb25zIG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcGVyYXRvcl1cbiAgICogQHBhcmFtIHtNdWx0aVRva2VufSBbdG9rZW5dXG4gICAqIEByZXR1cm5zIHtPcHRzW0xdIHwgYW55fVxuICAgKi9cbiAgZ2V0T2JqOiBmdW5jdGlvbiBnZXRPYmooa2V5LCBvcGVyYXRvciwgdG9rZW4pIHtcbiAgICB2YXIgb2JqID0gdGhpcy5vW2tleV07XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyAmJiBvcGVyYXRvciAhPSBudWxsKSB7XG4gICAgICBvYmogPSBvYmoob3BlcmF0b3IsIHRva2VuLnQsIHRva2VuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBnaXZlbiB0b2tlbiB0byBhIHJlbmRlcmVkIGVsZW1lbnQgdGhhdCBtYXkgYmUgYWRkZWQgdG8gdGhlXG4gICAqIGNhbGxpbmctaW50ZXJmYWNlJ3MgRE9NXG4gICAqIEBwYXJhbSB7TXVsdGlUb2tlbn0gdG9rZW4gVG9rZW4gdG8gcmVuZGVyIHRvIGFuIEhUTUwgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7YW55fSBSZW5kZXIgcmVzdWx0OyBlLmcuLCBIVE1MIHN0cmluZywgRE9NIGVsZW1lbnQsIFJlYWN0XG4gICAqICAgQ29tcG9uZW50LCBldGMuXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcih0b2tlbikge1xuICAgIHZhciBpciA9IHRva2VuLnJlbmRlcih0aGlzKTsgLy8gaW50ZXJtZWRpYXRlIHJlcHJlc2VudGF0aW9uXG5cbiAgICB2YXIgcmVuZGVyRm4gPSB0aGlzLmdldCgncmVuZGVyJywgbnVsbCwgdG9rZW4pIHx8IHRoaXMuZGVmYXVsdFJlbmRlcjtcbiAgICByZXR1cm4gcmVuZGVyRm4oaXIsIHRva2VuLnQsIHRva2VuKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gbm9vcCh2YWwpIHtcbiAgcmV0dXJuIHZhbDtcbn1cblxudmFyIG9wdGlvbnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0ZGVmYXVsdHM6IGRlZmF1bHRzLFxuXHRPcHRpb25zOiBPcHRpb25zLFxuXHRhc3NpZ246IGFzc2lnblxufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0TXVsdGktVG9rZW5zXG5cdFRva2VucyBjb21wb3NlZCBvZiBhcnJheXMgb2YgVGV4dFRva2Vuc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtUb2tlbltdfSB0b2tlbnNcbiAqL1xuXG5mdW5jdGlvbiBNdWx0aVRva2VuKHZhbHVlLCB0b2tlbnMpIHtcbiAgdGhpcy50ID0gJ3Rva2VuJztcbiAgdGhpcy52ID0gdmFsdWU7XG4gIHRoaXMudGsgPSB0b2tlbnM7XG59XG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHVzZWQgZm9yIG1hbnVmYWN0dXJpbmcgdG9rZW5zIG9mIHRleHQgdG9rZW5zLiBUaGF0IGlzIHJhdGhlclxuICogdGhhbiB0aGUgdmFsdWUgZm9yIGEgdG9rZW4gYmVpbmcgYSBzbWFsbCBzdHJpbmcgb2YgdGV4dCwgaXQncyB2YWx1ZSBhbiBhcnJheVxuICogb2YgdGV4dCB0b2tlbnMuXG4gKlxuICogVXNlZCBmb3IgZ3JvdXBpbmcgdG9nZXRoZXIgVVJMcywgZW1haWxzLCBoYXNodGFncywgYW5kIG90aGVyIHBvdGVudGlhbFxuICogY3JlYXRpb25zLlxuICogQGNsYXNzIE11bHRpVG9rZW5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdlxuICogQHByb3BlcnR5IHtUb2tlbltdfSB0a1xuICogQGFic3RyYWN0XG4gKi9cblxuTXVsdGlUb2tlbi5wcm90b3R5cGUgPSB7XG4gIGlzTGluazogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc3RyaW5nIHRoaXMgdG9rZW4gcmVwcmVzZW50cy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnY7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoYXQgc2hvdWxkIHRoZSB2YWx1ZSBmb3IgdGhpcyB0b2tlbiBiZSBpbiB0aGUgYGhyZWZgIEhUTUwgYXR0cmlidXRlP1xuICAgKiBSZXR1cm5zIHRoZSBgLnRvU3RyaW5nYCB2YWx1ZSBieSBkZWZhdWx0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjaGVtZV1cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAqL1xuICB0b0hyZWY6IGZ1bmN0aW9uIHRvSHJlZihzY2hlbWUpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgRm9ybWF0dGluZyBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdHRlZFN0cmluZzogZnVuY3Rpb24gdG9Gb3JtYXR0ZWRTdHJpbmcob3B0aW9ucykge1xuICAgIHZhciB2YWwgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgdmFyIHRydW5jYXRlID0gb3B0aW9ucy5nZXQoJ3RydW5jYXRlJywgdmFsLCB0aGlzKTtcbiAgICB2YXIgZm9ybWF0dGVkID0gb3B0aW9ucy5nZXQoJ2Zvcm1hdCcsIHZhbCwgdGhpcyk7XG4gICAgcmV0dXJuIHRydW5jYXRlICYmIGZvcm1hdHRlZC5sZW5ndGggPiB0cnVuY2F0ZSA/IGZvcm1hdHRlZC5zdWJzdHJpbmcoMCwgdHJ1bmNhdGUpICsgJ+KApicgOiBmb3JtYXR0ZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXR0ZWRIcmVmOiBmdW5jdGlvbiB0b0Zvcm1hdHRlZEhyZWYob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmdldCgnZm9ybWF0SHJlZicsIHRoaXMudG9IcmVmKG9wdGlvbnMuZ2V0KCdkZWZhdWx0UHJvdG9jb2wnKSksIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgc3RhcnQgaW5kZXggb2YgdGhpcyB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgaW5wdXQgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBzdGFydEluZGV4OiBmdW5jdGlvbiBzdGFydEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnRrWzBdLnM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBlbmQgaW5kZXggb2YgdGhpcyB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgaW5wdXQgc3RyaW5nICh1cCB0byB0aGlzXG4gICAqIGluZGV4IGJ1dCBub3QgaW5jbHVkaW5nIGl0KVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZW5kSW5kZXg6IGZ1bmN0aW9uIGVuZEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnRrW3RoaXMudGsubGVuZ3RoIC0gMV0uZTtcbiAgfSxcblxuICAvKipcbiAgXHRSZXR1cm5zIGFuIG9iamVjdCAgb2YgcmVsZXZhbnQgdmFsdWVzIGZvciB0aGlzIHRva2VuLCB3aGljaCBpbmNsdWRlcyBrZXlzXG4gIFx0KiB0eXBlIC0gS2luZCBvZiB0b2tlbiAoJ3VybCcsICdlbWFpbCcsIGV0Yy4pXG4gIFx0KiB2YWx1ZSAtIE9yaWdpbmFsIHRleHRcbiAgXHQqIGhyZWYgLSBUaGUgdmFsdWUgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGFuY2hvciB0YWcncyBocmVmXG4gIFx0XHRhdHRyaWJ1dGVcbiAgXHRcdEBtZXRob2QgdG9PYmplY3RcbiAgXHRAcGFyYW0ge3N0cmluZ30gW3Byb3RvY29sXSBgJ2h0dHAnYCBieSBkZWZhdWx0XG4gICovXG4gIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChwcm90b2NvbCkge1xuICAgIGlmIChwcm90b2NvbCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm90b2NvbCA9IGRlZmF1bHRzLmRlZmF1bHRQcm90b2NvbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy50LFxuICAgICAgdmFsdWU6IHRoaXMudG9TdHJpbmcoKSxcbiAgICAgIGlzTGluazogdGhpcy5pc0xpbmssXG4gICAgICBocmVmOiB0aGlzLnRvSHJlZihwcm90b2NvbCksXG4gICAgICBzdGFydDogdGhpcy5zdGFydEluZGV4KCksXG4gICAgICBlbmQ6IHRoaXMuZW5kSW5kZXgoKVxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBGb3JtYXR0aW5nIG9wdGlvblxuICAgKi9cbiAgdG9Gb3JtYXR0ZWRPYmplY3Q6IGZ1bmN0aW9uIHRvRm9ybWF0dGVkT2JqZWN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy50LFxuICAgICAgdmFsdWU6IHRoaXMudG9Gb3JtYXR0ZWRTdHJpbmcob3B0aW9ucyksXG4gICAgICBpc0xpbms6IHRoaXMuaXNMaW5rLFxuICAgICAgaHJlZjogdGhpcy50b0Zvcm1hdHRlZEhyZWYob3B0aW9ucyksXG4gICAgICBzdGFydDogdGhpcy5zdGFydEluZGV4KCksXG4gICAgICBlbmQ6IHRoaXMuZW5kSW5kZXgoKVxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyB0b2tlbiBzaG91bGQgYmUgcmVuZGVyZWQgYXMgYSBsaW5rIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmdldCgndmFsaWRhdGUnLCB0aGlzLnRvU3RyaW5nKCksIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBob3cgdGhpcyBsaW5rIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIEZvcm1hdHRpbm5nIG9wdGlvbnNcbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKG9wdGlvbnMpIHtcbiAgICB2YXIgdG9rZW4gPSB0aGlzO1xuICAgIHZhciBocmVmID0gdGhpcy50b0Zvcm1hdHRlZEhyZWYob3B0aW9ucyk7XG4gICAgdmFyIHRhZ05hbWUgPSBvcHRpb25zLmdldCgndGFnTmFtZScsIGhyZWYsIHRva2VuKTtcbiAgICB2YXIgY29udGVudCA9IHRoaXMudG9Gb3JtYXR0ZWRTdHJpbmcob3B0aW9ucyk7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICB2YXIgY2xhc3NOYW1lID0gb3B0aW9ucy5nZXQoJ2NsYXNzTmFtZScsIGhyZWYsIHRva2VuKTtcbiAgICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy5nZXQoJ3RhcmdldCcsIGhyZWYsIHRva2VuKTtcbiAgICB2YXIgcmVsID0gb3B0aW9ucy5nZXQoJ3JlbCcsIGhyZWYsIHRva2VuKTtcbiAgICB2YXIgYXR0cnMgPSBvcHRpb25zLmdldE9iaignYXR0cmlidXRlcycsIGhyZWYsIHRva2VuKTtcbiAgICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLmdldE9iaignZXZlbnRzJywgaHJlZiwgdG9rZW4pO1xuICAgIGF0dHJpYnV0ZXMuaHJlZiA9IGhyZWY7XG5cbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICBhdHRyaWJ1dGVzLmNsYXNzID0gY2xhc3NOYW1lO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGF0dHJpYnV0ZXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmIChyZWwpIHtcbiAgICAgIGF0dHJpYnV0ZXMucmVsID0gcmVsO1xuICAgIH1cblxuICAgIGlmIChhdHRycykge1xuICAgICAgYXNzaWduKGF0dHJpYnV0ZXMsIGF0dHJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgZXZlbnRMaXN0ZW5lcnM6IGV2ZW50TGlzdGVuZXJzXG4gICAgfTtcbiAgfVxufTsgLy8gQmFzZSB0b2tlblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgdG9rZW4gdGhhdCBjYW4gYmUgZW1pdHRlZCBieSB0aGUgcGFyc2VyIHN0YXRlIG1hY2hpbmVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHJlYWRhYmxlIHR5cGUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgcHJvcGVydGllcyB0byBhc3NpZ24gb3Igb3ZlcnJpZGUsIGluY2x1ZGluZyBpc0xpbmsgPSB0cnVlIG9yIGZhbHNlXG4gKiBAcmV0dXJucyB7bmV3ICh2YWx1ZTogc3RyaW5nLCB0b2tlbnM6IFRva2VuW10pID0+IE11bHRpVG9rZW59IG5ldyB0b2tlbiBjbGFzc1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuQ2xhc3ModHlwZSwgcHJvcHMpIHtcbiAgdmFyIFRva2VuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTXVsdGlUb2tlbikge1xuICAgIF9pbmhlcml0c0xvb3NlKFRva2VuLCBfTXVsdGlUb2tlbik7XG5cbiAgICBmdW5jdGlvbiBUb2tlbih2YWx1ZSwgdG9rZW5zKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF90aGlzID0gX011bHRpVG9rZW4uY2FsbCh0aGlzLCB2YWx1ZSwgdG9rZW5zKSB8fCB0aGlzO1xuICAgICAgX3RoaXMudCA9IHR5cGU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFRva2VuO1xuICB9KE11bHRpVG9rZW4pO1xuXG4gIGZvciAodmFyIHAgaW4gcHJvcHMpIHtcbiAgICBUb2tlbi5wcm90b3R5cGVbcF0gPSBwcm9wc1twXTtcbiAgfVxuXG4gIFRva2VuLnQgPSB0eXBlO1xuICByZXR1cm4gVG9rZW47XG59XG4vKipcblx0UmVwcmVzZW50cyBhIGxpc3Qgb2YgdG9rZW5zIG1ha2luZyB1cCBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcbiovXG5cbnZhciBFbWFpbCA9IGNyZWF0ZVRva2VuQ2xhc3MoJ2VtYWlsJywge1xuICBpc0xpbms6IHRydWUsXG4gIHRvSHJlZjogZnVuY3Rpb24gdG9IcmVmKCkge1xuICAgIHJldHVybiAnbWFpbHRvOicgKyB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cbn0pO1xuLyoqXG5cdFJlcHJlc2VudHMgc29tZSBwbGFpbiB0ZXh0XG4qL1xuXG52YXIgVGV4dCA9IGNyZWF0ZVRva2VuQ2xhc3MoJ3RleHQnKTtcbi8qKlxuXHRNdWx0aS1saW5lYnJlYWsgdG9rZW4gLSByZXByZXNlbnRzIGEgbGluZSBicmVha1xuXHRAY2xhc3MgTmxcbiovXG5cbnZhciBObCA9IGNyZWF0ZVRva2VuQ2xhc3MoJ25sJyk7XG4vKipcblx0UmVwcmVzZW50cyBhIGxpc3Qgb2YgdGV4dCB0b2tlbnMgbWFraW5nIHVwIGEgdmFsaWQgVVJMXG5cdEBjbGFzcyBVcmxcbiovXG5cbnZhciBVcmwgPSBjcmVhdGVUb2tlbkNsYXNzKCd1cmwnLCB7XG4gIGlzTGluazogdHJ1ZSxcblxuICAvKipcbiAgXHRMb3dlcmNhc2VzIHJlbGV2YW50IHBhcnRzIG9mIHRoZSBkb21haW4gYW5kIGFkZHMgdGhlIHByb3RvY29sIGlmXG4gIFx0cmVxdWlyZWQuIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IGVzY2FwZSB1bnNhZmUgSFRNTCBjaGFyYWN0ZXJzIGluIHRoZVxuICBcdFVSTC5cbiAgXHRcdEBwYXJhbSB7c3RyaW5nfSBbc2NoZW1lXSBkZWZhdWx0IHNjaGVtZSAoZS5nLiwgJ2h0dHBzJylcbiAgXHRAcmV0dXJuIHtzdHJpbmd9IHRoZSBmdWxsIGhyZWZcbiAgKi9cbiAgdG9IcmVmOiBmdW5jdGlvbiB0b0hyZWYoc2NoZW1lKSB7XG4gICAgaWYgKHNjaGVtZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzY2hlbWUgPSBkZWZhdWx0cy5kZWZhdWx0UHJvdG9jb2w7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBoYXMgYSBwcmVmaXggc2NoZW1lXG4gICAgcmV0dXJuIHRoaXMuaGFzUHJvdG9jb2woKSA/IHRoaXMudiA6IHNjaGVtZSArIFwiOi8vXCIgKyB0aGlzLnY7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhpcyBVUkwgdG9rZW4gaGFzIGEgcHJvdG9jb2xcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1Byb3RvY29sOiBmdW5jdGlvbiBoYXNQcm90b2NvbCgpIHtcbiAgICB2YXIgdG9rZW5zID0gdGhpcy50aztcbiAgICByZXR1cm4gdG9rZW5zLmxlbmd0aCA+PSAyICYmIHRva2Vuc1swXS50ICE9PSBMT0NBTEhPU1QgJiYgdG9rZW5zWzFdLnQgPT09IENPTE9OO1xuICB9XG59KTtcblxudmFyIG11bHRpID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdE11bHRpVG9rZW46IE11bHRpVG9rZW4sXG5cdEJhc2U6IE11bHRpVG9rZW4sXG5cdGNyZWF0ZVRva2VuQ2xhc3M6IGNyZWF0ZVRva2VuQ2xhc3MsXG5cdEVtYWlsOiBFbWFpbCxcblx0VGV4dDogVGV4dCxcblx0Tmw6IE5sLFxuXHRVcmw6IFVybFxufSk7XG5cbi8qKlxuXHROb3QgZXhhY3RseSBwYXJzZXIsIG1vcmUgbGlrZSB0aGUgc2Vjb25kLXN0YWdlIHNjYW5uZXIgKGFsdGhvdWdoIHdlIGNhblxuXHR0aGVvcmV0aWNhbGx5IGhvdHN3YXAgdGhlIGNvZGUgaGVyZSB3aXRoIGEgcmVhbCBwYXJzZXIgaW4gdGhlIGZ1dHVyZS4uLiBidXRcblx0Zm9yIGEgbGl0dGxlIFVSTC1maW5kaW5nIHV0aWxpdHkgYWJzdHJhY3Qgc3ludGF4IHRyZWVzIG1heSBiZSBhIGxpdHRsZVxuXHRvdmVya2lsbCkuXG5cblx0VVJMIGZvcm1hdDogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VUklfc2NoZW1lXG5cdEVtYWlsIGZvcm1hdDogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbWFpbEFkZHJlc3MgKGxpbmtzIHRvIFJGQyBpblxuXHRyZWZlcmVuY2UpXG5cblx0QG1vZHVsZSBsaW5raWZ5XG5cdEBzdWJtb2R1bGUgcGFyc2VyXG5cdEBtYWluIHJ1blxuKi9cblxudmFyIG1ha2VTdGF0ZSA9IGZ1bmN0aW9uIG1ha2VTdGF0ZShhcmcpIHtcbiAgcmV0dXJuIG5ldyBTdGF0ZShhcmcpO1xufTtcbi8qKlxuICogR2VuZXJhdGUgdGhlIHBhcnNlciBtdWx0aSB0b2tlbi1iYXNlZCBzdGF0ZSBtYWNoaW5lXG4gKiBAcGFyYW0ge3sgZ3JvdXBzOiBDb2xsZWN0aW9uczxzdHJpbmc+IH19IHRva2Vuc1xuICovXG5cblxuZnVuY3Rpb24gaW5pdCQxKF9yZWYpIHtcbiAgdmFyIGdyb3VwcyA9IF9yZWYuZ3JvdXBzO1xuICAvLyBUeXBlcyBvZiBjaGFyYWN0ZXJzIHRoZSBVUkwgY2FuIGRlZmluaXRlbHkgZW5kIGluXG4gIHZhciBxc0FjY2VwdGluZyA9IGdyb3Vwcy5kb21haW4uY29uY2F0KFtBTVBFUlNBTkQsIEFTVEVSSVNLLCBBVCwgQkFDS1NMQVNILCBCQUNLVElDSywgQ0FSRVQsIERPTExBUiwgRVFVQUxTLCBIWVBIRU4sIE5VTSwgUEVSQ0VOVCwgUElQRSwgUExVUywgUE9VTkQsIFNMQVNILCBTWU0sIFRJTERFLCBVTkRFUlNDT1JFXSk7IC8vIFR5cGVzIG9mIHRva2VucyB0aGF0IGNhbiBmb2xsb3cgYSBVUkwgYW5kIGJlIHBhcnQgb2YgdGhlIHF1ZXJ5IHN0cmluZ1xuICAvLyBidXQgY2Fubm90IGJlIHRoZSB2ZXJ5IGxhc3QgY2hhcmFjdGVyc1xuICAvLyBDaGFyYWN0ZXJzIHRoYXQgY2Fubm90IGFwcGVhciBpbiB0aGUgVVJMIGF0IGFsbCBzaG91bGQgYmUgZXhjbHVkZWRcblxuICB2YXIgcXNOb25BY2NlcHRpbmcgPSBbQVBPU1RST1BIRSwgQ0xPU0VBTkdMRUJSQUNLRVQsIENMT1NFQlJBQ0UsIENMT1NFQlJBQ0tFVCwgQ0xPU0VQQVJFTiwgQ09MT04sIENPTU1BLCBET1QsIEVYQ0xBTUFUSU9OLCBPUEVOQU5HTEVCUkFDS0VULCBPUEVOQlJBQ0UsIE9QRU5CUkFDS0VULCBPUEVOUEFSRU4sIFFVRVJZLCBRVU9URSwgU0VNSV07IC8vIEZvciBhZGRyZXNzZXMgd2l0aG91dCB0aGUgbWFpbHRvIHByZWZpeFxuICAvLyBUb2tlbnMgYWxsb3dlZCBpbiB0aGUgbG9jYWxwYXJ0IG9mIHRoZSBlbWFpbFxuXG4gIHZhciBsb2NhbHBhcnRBY2NlcHRpbmcgPSBbQU1QRVJTQU5ELCBBUE9TVFJPUEhFLCBBU1RFUklTSywgQkFDS1NMQVNILCBCQUNLVElDSywgQ0FSRVQsIENMT1NFQlJBQ0UsIERPTExBUiwgRVFVQUxTLCBIWVBIRU4sIE5VTSwgT1BFTkJSQUNFLCBQRVJDRU5ULCBQSVBFLCBQTFVTLCBQT1VORCwgUVVFUlksIFNMQVNILCBTWU0sIFRJTERFLCBVTkRFUlNDT1JFXTsgLy8gVGhlIHVuaXZlcnNhbCBzdGFydGluZyBzdGF0ZS5cblxuICAvKipcbiAgICogQHR5cGUgU3RhdGU8VG9rZW4+XG4gICAqL1xuXG4gIHZhciBTdGFydCA9IG1ha2VTdGF0ZSgpO1xuICB2YXIgTG9jYWxwYXJ0ID0gdHQoU3RhcnQsIFRJTERFKTsgLy8gTG9jYWwgcGFydCBvZiB0aGUgZW1haWwgYWRkcmVzc1xuXG4gIHRhKExvY2FscGFydCwgbG9jYWxwYXJ0QWNjZXB0aW5nLCBMb2NhbHBhcnQpO1xuICB0YShMb2NhbHBhcnQsIGdyb3Vwcy5kb21haW4sIExvY2FscGFydCk7XG4gIHZhciBEb21haW4gPSBtYWtlU3RhdGUoKSxcbiAgICAgIFNjaGVtZSA9IG1ha2VTdGF0ZSgpLFxuICAgICAgU2xhc2hTY2hlbWUgPSBtYWtlU3RhdGUoKTtcbiAgdGEoU3RhcnQsIGdyb3Vwcy5kb21haW4sIERvbWFpbik7IC8vIHBhcnNlZCBzdHJpbmcgZW5kcyB3aXRoIGEgcG90ZW50aWFsIGRvbWFpbiBuYW1lIChBKVxuXG4gIHRhKFN0YXJ0LCBncm91cHMuc2NoZW1lLCBTY2hlbWUpOyAvLyBlLmcuLCAnbWFpbHRvJ1xuXG4gIHRhKFN0YXJ0LCBncm91cHMuc2xhc2hzY2hlbWUsIFNsYXNoU2NoZW1lKTsgLy8gZS5nLiwgJ2h0dHAnXG5cbiAgdGEoRG9tYWluLCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKERvbWFpbiwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdmFyIExvY2FscGFydEF0ID0gdHQoRG9tYWluLCBBVCk7IC8vIExvY2FsIHBhcnQgb2YgdGhlIGVtYWlsIGFkZHJlc3MgcGx1cyBAXG5cbiAgdHQoTG9jYWxwYXJ0LCBBVCwgTG9jYWxwYXJ0QXQpOyAvLyBjbG9zZSB0byBhbiBlbWFpbCBhZGRyZXNzIG5vd1xuXG4gIHZhciBMb2NhbHBhcnREb3QgPSB0dChMb2NhbHBhcnQsIERPVCk7IC8vIExvY2FsIHBhcnQgb2YgdGhlIGVtYWlsIGFkZHJlc3MgcGx1cyAnLicgKGxvY2FscGFydCBjYW5ub3QgZW5kIGluIC4pXG5cbiAgdGEoTG9jYWxwYXJ0RG90LCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKExvY2FscGFydERvdCwgZ3JvdXBzLmRvbWFpbiwgTG9jYWxwYXJ0KTtcbiAgdmFyIEVtYWlsRG9tYWluID0gbWFrZVN0YXRlKCk7XG4gIHRhKExvY2FscGFydEF0LCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7IC8vIHBhcnNlZCBzdHJpbmcgc3RhcnRzIHdpdGggbG9jYWwgZW1haWwgaW5mbyArIEAgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZVxuXG4gIHRhKEVtYWlsRG9tYWluLCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIHZhciBFbWFpbERvbWFpbkRvdCA9IHR0KEVtYWlsRG9tYWluLCBET1QpOyAvLyBkb21haW4gZm9sbG93ZWQgYnkgRE9UXG5cbiAgdGEoRW1haWxEb21haW5Eb3QsIGdyb3Vwcy5kb21haW4sIEVtYWlsRG9tYWluKTtcbiAgdmFyIEVtYWlsJDEgPSBtYWtlU3RhdGUoRW1haWwpOyAvLyBQb3NzaWJsZSBlbWFpbCBhZGRyZXNzIChjb3VsZCBoYXZlIG1vcmUgdGxkcylcblxuICB0YShFbWFpbERvbWFpbkRvdCwgZ3JvdXBzLnRsZCwgRW1haWwkMSk7XG4gIHRhKEVtYWlsRG9tYWluRG90LCBncm91cHMudXRsZCwgRW1haWwkMSk7XG4gIHR0KExvY2FscGFydEF0LCBMT0NBTEhPU1QsIEVtYWlsJDEpOyAvLyBIeXBoZW4gY2FuIGp1bXAgYmFjayB0byBhIGRvbWFpbiBuYW1lXG5cbiAgdmFyIEVtYWlsRG9tYWluSHlwaGVuID0gdHQoRW1haWxEb21haW4sIEhZUEhFTik7IC8vIHBhcnNlZCBzdHJpbmcgc3RhcnRzIHdpdGggbG9jYWwgZW1haWwgaW5mbyArIEAgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZVxuXG4gIHRhKEVtYWlsRG9tYWluSHlwaGVuLCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIHRhKEVtYWlsJDEsIGdyb3Vwcy5kb21haW4sIEVtYWlsRG9tYWluKTtcbiAgdHQoRW1haWwkMSwgRE9ULCBFbWFpbERvbWFpbkRvdCk7XG4gIHR0KEVtYWlsJDEsIEhZUEhFTiwgRW1haWxEb21haW5IeXBoZW4pOyAvLyBGaW5hbCBwb3NzaWJsZSBlbWFpbCBzdGF0ZXNcblxuICB2YXIgRW1haWxDb2xvbiA9IHR0KEVtYWlsJDEsIENPTE9OKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IGNvbG9uIChwb3RlbnRpYWwgcG9ydCBudW1iZXIgaGVyZSlcblxuICAvKmNvbnN0IEVtYWlsQ29sb25Qb3J0ID0gKi9cblxuICB0YShFbWFpbENvbG9uLCBncm91cHMubnVtZXJpYywgRW1haWwpOyAvLyBVUkwgZm9sbG93ZWQgYnkgY29sb24gYW5kIHBvcnQgbnVtbmVyXG4gIC8vIEFjY291bnQgZm9yIGRvdHMgYW5kIGh5cGhlbnMuIEh5cGhlbnMgYXJlIHVzdWFsbHkgcGFydHMgb2YgZG9tYWluIG5hbWVzXG4gIC8vIChidXQgbm90IFRMRHMpXG5cbiAgdmFyIERvbWFpbkh5cGhlbiA9IHR0KERvbWFpbiwgSFlQSEVOKTsgLy8gZG9tYWluIGZvbGxvd2VkIGJ5IGh5cGhlblxuXG4gIHZhciBEb21haW5Eb3QgPSB0dChEb21haW4sIERPVCk7IC8vIGRvbWFpbiBmb2xsb3dlZCBieSBET1RcblxuICB0YShEb21haW5IeXBoZW4sIGdyb3Vwcy5kb21haW4sIERvbWFpbik7XG4gIHRhKERvbWFpbkRvdCwgbG9jYWxwYXJ0QWNjZXB0aW5nLCBMb2NhbHBhcnQpO1xuICB0YShEb21haW5Eb3QsIGdyb3Vwcy5kb21haW4sIERvbWFpbik7XG4gIHZhciBEb21haW5Eb3RUbGQgPSBtYWtlU3RhdGUoVXJsKTsgLy8gU2ltcGxlc3QgcG9zc2libGUgVVJMIHdpdGggbm8gcXVlcnkgc3RyaW5nXG5cbiAgdGEoRG9tYWluRG90LCBncm91cHMudGxkLCBEb21haW5Eb3RUbGQpO1xuICB0YShEb21haW5Eb3QsIGdyb3Vwcy51dGxkLCBEb21haW5Eb3RUbGQpO1xuICB0YShEb21haW5Eb3RUbGQsIGdyb3Vwcy5kb21haW4sIERvbWFpbik7XG4gIHRhKERvbWFpbkRvdFRsZCwgbG9jYWxwYXJ0QWNjZXB0aW5nLCBMb2NhbHBhcnQpO1xuICB0dChEb21haW5Eb3RUbGQsIERPVCwgRG9tYWluRG90KTtcbiAgdHQoRG9tYWluRG90VGxkLCBIWVBIRU4sIERvbWFpbkh5cGhlbik7XG4gIHR0KERvbWFpbkRvdFRsZCwgQVQsIExvY2FscGFydEF0KTtcbiAgdmFyIERvbWFpbkRvdFRsZENvbG9uID0gdHQoRG9tYWluRG90VGxkLCBDT0xPTik7IC8vIFVSTCBmb2xsb3dlZCBieSBjb2xvbiAocG90ZW50aWFsIHBvcnQgbnVtYmVyIGhlcmUpXG5cbiAgdmFyIERvbWFpbkRvdFRsZENvbG9uUG9ydCA9IG1ha2VTdGF0ZShVcmwpOyAvLyBUTEQgZm9sbG93ZWQgYnkgYSBwb3J0IG51bWJlclxuXG4gIHRhKERvbWFpbkRvdFRsZENvbG9uLCBncm91cHMubnVtZXJpYywgRG9tYWluRG90VGxkQ29sb25Qb3J0KTsgLy8gTG9uZyBVUkwgd2l0aCBvcHRpb25hbCBwb3J0IGFuZCBtYXliZSBxdWVyeSBzdHJpbmdcblxuICB2YXIgVXJsJDEgPSBtYWtlU3RhdGUoVXJsKTsgLy8gVVJMIHdpdGggZXh0cmEgc3ltYm9scyBhdCB0aGUgZW5kLCBmb2xsb3dlZCBieSBhbiBvcGVuaW5nIGJyYWNrZXRcblxuICB2YXIgVXJsTm9uYWNjZXB0ID0gbWFrZVN0YXRlKCk7IC8vIFVSTCBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHMgKHdpbGwgbm90IGJlIHBhcnQgb2YgdGhlIGZpbmFsIFVSTClcbiAgLy8gUXVlcnkgc3RyaW5nc1xuXG4gIHRhKFVybCQxLCBxc0FjY2VwdGluZywgVXJsJDEpO1xuICB0YShVcmwkMSwgcXNOb25BY2NlcHRpbmcsIFVybE5vbmFjY2VwdCk7XG4gIHRhKFVybE5vbmFjY2VwdCwgcXNBY2NlcHRpbmcsIFVybCQxKTtcbiAgdGEoVXJsTm9uYWNjZXB0LCBxc05vbkFjY2VwdGluZywgVXJsTm9uYWNjZXB0KTsgLy8gQmVjb21lIHJlYWwgVVJMcyBhZnRlciBgU0xBU0hgIG9yIGBDT0xPTiBOVU0gU0xBU0hgXG4gIC8vIEhlcmUgd29ya3Mgd2l0aCBvciB3aXRob3V0IHNjaGVtZTovLyBwcmVmaXhcblxuICB0dChEb21haW5Eb3RUbGQsIFNMQVNILCBVcmwkMSk7XG4gIHR0KERvbWFpbkRvdFRsZENvbG9uUG9ydCwgU0xBU0gsIFVybCQxKTsgLy8gTm90ZSB0aGF0IGRvbWFpbnMgdGhhdCBiZWdpbiB3aXRoIHNjaGVtZXMgYXJlIHRyZWF0ZWQgc2xpZ2hseSBkaWZmZXJlbnRseVxuXG4gIHZhciBVcmlQcmVmaXggPSB0dChTY2hlbWUsIENPTE9OKTsgLy8gZS5nLiwgJ21haWx0bzonIG9yICdodHRwOi8vJ1xuXG4gIHZhciBTbGFzaFNjaGVtZUNvbG9uID0gdHQoU2xhc2hTY2hlbWUsIENPTE9OKTsgLy8gZS5nLiwgJ2h0dHA6J1xuXG4gIHZhciBTbGFzaFNjaGVtZUNvbG9uU2xhc2ggPSB0dChTbGFzaFNjaGVtZUNvbG9uLCBTTEFTSCk7IC8vIGUuZy4sICdodHRwOi8nXG5cbiAgdHQoU2xhc2hTY2hlbWVDb2xvblNsYXNoLCBTTEFTSCwgVXJpUHJlZml4KTsgLy8gU2NoZW1lIHN0YXRlcyBjYW4gdHJhbnNpdGlvbiB0byBkb21haW4gc3RhdGVzXG5cbiAgdGEoU2NoZW1lLCBncm91cHMuZG9tYWluLCBEb21haW4pO1xuICB0dChTY2hlbWUsIERPVCwgRG9tYWluRG90KTtcbiAgdHQoU2NoZW1lLCBIWVBIRU4sIERvbWFpbkh5cGhlbik7XG4gIHRhKFNsYXNoU2NoZW1lLCBncm91cHMuZG9tYWluLCBEb21haW4pO1xuICB0dChTbGFzaFNjaGVtZSwgRE9ULCBEb21haW5Eb3QpO1xuICB0dChTbGFzaFNjaGVtZSwgSFlQSEVOLCBEb21haW5IeXBoZW4pOyAvLyBGb3JjZSBVUkwgd2l0aCBzY2hlbWUgcHJlZml4IGZvbGxvd2VkIGJ5IGFueXRoaW5nIHNhbmVcblxuICB0YShVcmlQcmVmaXgsIGdyb3Vwcy5kb21haW4sIFVybCQxKTtcbiAgdHQoVXJpUHJlZml4LCBTTEFTSCwgVXJsJDEpOyAvLyBVUkwsIGZvbGxvd2VkIGJ5IGFuIG9wZW5pbmcgYnJhY2tldFxuXG4gIHZhciBVcmxPcGVuYnJhY2UgPSB0dChVcmwkMSwgT1BFTkJSQUNFKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IHtcblxuICB2YXIgVXJsT3BlbmJyYWNrZXQgPSB0dChVcmwkMSwgT1BFTkJSQUNLRVQpOyAvLyBVUkwgZm9sbG93ZWQgYnkgW1xuXG4gIHZhciBVcmxPcGVuYW5nbGVicmFja2V0ID0gdHQoVXJsJDEsIE9QRU5BTkdMRUJSQUNLRVQpOyAvLyBVUkwgZm9sbG93ZWQgYnkgPFxuXG4gIHZhciBVcmxPcGVucGFyZW4gPSB0dChVcmwkMSwgT1BFTlBBUkVOKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IChcblxuICB0dChVcmxOb25hY2NlcHQsIE9QRU5CUkFDRSwgVXJsT3BlbmJyYWNlKTtcbiAgdHQoVXJsTm9uYWNjZXB0LCBPUEVOQlJBQ0tFVCwgVXJsT3BlbmJyYWNrZXQpO1xuICB0dChVcmxOb25hY2NlcHQsIE9QRU5BTkdMRUJSQUNLRVQsIFVybE9wZW5hbmdsZWJyYWNrZXQpO1xuICB0dChVcmxOb25hY2NlcHQsIE9QRU5QQVJFTiwgVXJsT3BlbnBhcmVuKTsgLy8gQ2xvc2luZyBicmFja2V0IGNvbXBvbmVudC4gVGhpcyBjaGFyYWN0ZXIgV0lMTCBiZSBpbmNsdWRlZCBpbiB0aGUgVVJMXG5cbiAgdHQoVXJsT3BlbmJyYWNlLCBDTE9TRUJSQUNFLCBVcmwkMSk7XG4gIHR0KFVybE9wZW5icmFja2V0LCBDTE9TRUJSQUNLRVQsIFVybCQxKTtcbiAgdHQoVXJsT3BlbmFuZ2xlYnJhY2tldCwgQ0xPU0VBTkdMRUJSQUNLRVQsIFVybCQxKTtcbiAgdHQoVXJsT3BlbnBhcmVuLCBDTE9TRVBBUkVOLCBVcmwkMSk7XG4gIHR0KFVybE9wZW5icmFjZSwgQ0xPU0VCUkFDRSwgVXJsJDEpOyAvLyBVUkwgdGhhdCBiZWluZ3Mgd2l0aCBhbiBvcGVuaW5nIGJyYWNrZXQsIGZvbGxvd2VkIGJ5IGEgc3ltYm9scy5cbiAgLy8gTm90ZSB0aGF0IHRoZSBmaW5hbCBzdGF0ZSBjYW4gc3RpbGwgYmUgYFVybE9wZW5icmFjZWAgKGlmIHRoZSBVUkwgb25seVxuICAvLyBoYXMgYSBzaW5nbGUgb3BlbmluZyBicmFja2V0IGZvciBzb21lIHJlYXNvbikuXG5cbiAgdmFyIFVybE9wZW5icmFjZVEgPSBtYWtlU3RhdGUoVXJsKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IHsgYW5kIHNvbWUgc3ltYm9scyB0aGF0IHRoZSBVUkwgY2FuIGVuZCBpdFxuXG4gIHZhciBVcmxPcGVuYnJhY2tldFEgPSBtYWtlU3RhdGUoVXJsKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IFsgYW5kIHNvbWUgc3ltYm9scyB0aGF0IHRoZSBVUkwgY2FuIGVuZCBpdFxuXG4gIHZhciBVcmxPcGVuYW5nbGVicmFja2V0USA9IG1ha2VTdGF0ZShVcmwpOyAvLyBVUkwgZm9sbG93ZWQgYnkgPCBhbmQgc29tZSBzeW1ib2xzIHRoYXQgdGhlIFVSTCBjYW4gZW5kIGl0XG5cbiAgdmFyIFVybE9wZW5wYXJlblEgPSBtYWtlU3RhdGUoVXJsKTsgLy8gVVJMIGZvbGxvd2VkIGJ5ICggYW5kIHNvbWUgc3ltYm9scyB0aGF0IHRoZSBVUkwgY2FuIGVuZCBpdFxuXG4gIHRhKFVybE9wZW5icmFjZSwgcXNBY2NlcHRpbmcsIFVybE9wZW5icmFjZVEpO1xuICB0YShVcmxPcGVuYnJhY2tldCwgcXNBY2NlcHRpbmcsIFVybE9wZW5icmFja2V0USk7XG4gIHRhKFVybE9wZW5hbmdsZWJyYWNrZXQsIHFzQWNjZXB0aW5nLCBVcmxPcGVuYW5nbGVicmFja2V0USk7XG4gIHRhKFVybE9wZW5wYXJlbiwgcXNBY2NlcHRpbmcsIFVybE9wZW5wYXJlblEpO1xuICB2YXIgVXJsT3BlbmJyYWNlU3ltcyA9IG1ha2VTdGF0ZSgpOyAvLyBVcmxPcGVuYnJhY2UgZm9sbG93ZWQgYnkgc29tZSBzeW1ib2xzIGl0IGNhbm5vdCBlbmQgaXRcblxuICB2YXIgVXJsT3BlbmJyYWNrZXRTeW1zID0gbWFrZVN0YXRlKCk7IC8vIFVybE9wZW5icmFja2V0USBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHMgaXQgY2Fubm90IGVuZCBpdFxuXG4gIHZhciBVcmxPcGVuYW5nbGVicmFja2V0U3ltcyA9IG1ha2VTdGF0ZSgpOyAvLyBVcmxPcGVuYW5nbGVicmFja2V0USBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHMgaXQgY2Fubm90IGVuZCBpdFxuXG4gIHZhciBVcmxPcGVucGFyZW5TeW1zID0gbWFrZVN0YXRlKCk7IC8vIFVybE9wZW5wYXJlblEgZm9sbG93ZWQgYnkgc29tZSBzeW1ib2xzIGl0IGNhbm5vdCBlbmQgaXRcblxuICB0YShVcmxPcGVuYnJhY2UsIHFzTm9uQWNjZXB0aW5nKTtcbiAgdGEoVXJsT3BlbmJyYWNrZXQsIHFzTm9uQWNjZXB0aW5nKTtcbiAgdGEoVXJsT3BlbmFuZ2xlYnJhY2tldCwgcXNOb25BY2NlcHRpbmcpO1xuICB0YShVcmxPcGVucGFyZW4sIHFzTm9uQWNjZXB0aW5nKTsgLy8gVVJMIHRoYXQgYmVnaW5zIHdpdGggYW4gb3BlbmluZyBicmFja2V0LCBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHNcblxuICB0YShVcmxPcGVuYnJhY2VRLCBxc0FjY2VwdGluZywgVXJsT3BlbmJyYWNlUSk7XG4gIHRhKFVybE9wZW5icmFja2V0USwgcXNBY2NlcHRpbmcsIFVybE9wZW5icmFja2V0USk7XG4gIHRhKFVybE9wZW5hbmdsZWJyYWNrZXRRLCBxc0FjY2VwdGluZywgVXJsT3BlbmFuZ2xlYnJhY2tldFEpO1xuICB0YShVcmxPcGVucGFyZW5RLCBxc0FjY2VwdGluZywgVXJsT3BlbnBhcmVuUSk7XG4gIHRhKFVybE9wZW5icmFjZVEsIHFzTm9uQWNjZXB0aW5nLCBVcmxPcGVuYnJhY2VRKTtcbiAgdGEoVXJsT3BlbmJyYWNrZXRRLCBxc05vbkFjY2VwdGluZywgVXJsT3BlbmJyYWNrZXRRKTtcbiAgdGEoVXJsT3BlbmFuZ2xlYnJhY2tldFEsIHFzTm9uQWNjZXB0aW5nLCBVcmxPcGVuYW5nbGVicmFja2V0USk7XG4gIHRhKFVybE9wZW5wYXJlblEsIHFzTm9uQWNjZXB0aW5nLCBVcmxPcGVucGFyZW5RKTtcbiAgdGEoVXJsT3BlbmJyYWNlU3ltcywgcXNBY2NlcHRpbmcsIFVybE9wZW5icmFjZVN5bXMpO1xuICB0YShVcmxPcGVuYnJhY2tldFN5bXMsIHFzQWNjZXB0aW5nLCBVcmxPcGVuYnJhY2tldFEpO1xuICB0YShVcmxPcGVuYW5nbGVicmFja2V0U3ltcywgcXNBY2NlcHRpbmcsIFVybE9wZW5hbmdsZWJyYWNrZXRRKTtcbiAgdGEoVXJsT3BlbnBhcmVuU3ltcywgcXNBY2NlcHRpbmcsIFVybE9wZW5wYXJlblEpO1xuICB0YShVcmxPcGVuYnJhY2VTeW1zLCBxc05vbkFjY2VwdGluZywgVXJsT3BlbmJyYWNlU3ltcyk7XG4gIHRhKFVybE9wZW5icmFja2V0U3ltcywgcXNOb25BY2NlcHRpbmcsIFVybE9wZW5icmFja2V0U3ltcyk7XG4gIHRhKFVybE9wZW5hbmdsZWJyYWNrZXRTeW1zLCBxc05vbkFjY2VwdGluZywgVXJsT3BlbmFuZ2xlYnJhY2tldFN5bXMpO1xuICB0YShVcmxPcGVucGFyZW5TeW1zLCBxc05vbkFjY2VwdGluZywgVXJsT3BlbnBhcmVuU3ltcyk7IC8vIENsb3NlIGJyYWNlL2JyYWNrZXQgdG8gYmVjb21lIHJlZ3VsYXIgVVJMXG5cbiAgdHQoVXJsT3BlbmJyYWNrZXRRLCBDTE9TRUJSQUNLRVQsIFVybCQxKTtcbiAgdHQoVXJsT3BlbmFuZ2xlYnJhY2tldFEsIENMT1NFQU5HTEVCUkFDS0VULCBVcmwkMSk7XG4gIHR0KFVybE9wZW5wYXJlblEsIENMT1NFUEFSRU4sIFVybCQxKTtcbiAgdHQoVXJsT3BlbmJyYWNlUSwgQ0xPU0VCUkFDRSwgVXJsJDEpO1xuICB0dChVcmxPcGVuYnJhY2tldFN5bXMsIENMT1NFQlJBQ0tFVCwgVXJsJDEpO1xuICB0dChVcmxPcGVuYW5nbGVicmFja2V0U3ltcywgQ0xPU0VBTkdMRUJSQUNLRVQsIFVybCQxKTtcbiAgdHQoVXJsT3BlbnBhcmVuU3ltcywgQ0xPU0VQQVJFTiwgVXJsJDEpO1xuICB0dChVcmxPcGVuYnJhY2VTeW1zLCBDTE9TRVBBUkVOLCBVcmwkMSk7XG4gIHR0KFN0YXJ0LCBMT0NBTEhPU1QsIERvbWFpbkRvdFRsZCk7IC8vIGxvY2FsaG9zdCBpcyBhIHZhbGlkIFVSTCBzdGF0ZVxuXG4gIHR0KFN0YXJ0LCBOTCQxLCBObCk7IC8vIHNpbmdsZSBuZXcgbGluZVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IFN0YXJ0LFxuICAgIHRva2VuczogdGtcbiAgfTtcbn1cbi8qKlxuICogUnVuIHRoZSBwYXJzZXIgc3RhdGUgbWFjaGluZSBvbiBhIGxpc3Qgb2Ygc2Nhbm5lZCBzdHJpbmctYmFzZWQgdG9rZW5zIHRvXG4gKiBjcmVhdGUgYSBsaXN0IG9mIG11bHRpIHRva2VucywgZWFjaCBvZiB3aGljaCByZXByZXNlbnRzIGEgVVJMLCBlbWFpbCBhZGRyZXNzLFxuICogcGxhaW4gdGV4dCwgZXRjLlxuICpcbiAqIEBwYXJhbSB7U3RhdGU8TXVsdGlUb2tlbj59IHN0YXJ0IHBhcnNlciBzdGFydCBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IHRoZSBvcmlnaW5hbCBpbnB1dCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBnaXZlbiB0b2tlbnNcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdG9rZW5zIGxpc3Qgb2Ygc2Nhbm5lZCB0b2tlbnNcbiAqIEByZXR1cm5zIHtNdWx0aVRva2VuW119XG4gKi9cblxuZnVuY3Rpb24gcnVuKHN0YXJ0LCBpbnB1dCwgdG9rZW5zKSB7XG4gIHZhciBsZW4gPSB0b2tlbnMubGVuZ3RoO1xuICB2YXIgY3Vyc29yID0gMDtcbiAgdmFyIG11bHRpcyA9IFtdO1xuICB2YXIgdGV4dFRva2VucyA9IFtdO1xuXG4gIHdoaWxlIChjdXJzb3IgPCBsZW4pIHtcbiAgICB2YXIgc3RhdGUgPSBzdGFydDtcbiAgICB2YXIgc2Vjb25kU3RhdGUgPSBudWxsO1xuICAgIHZhciBuZXh0U3RhdGUgPSBudWxsO1xuICAgIHZhciBtdWx0aUxlbmd0aCA9IDA7XG4gICAgdmFyIGxhdGVzdEFjY2VwdGluZyA9IG51bGw7XG4gICAgdmFyIHNpbmNlQWNjZXB0cyA9IC0xO1xuXG4gICAgd2hpbGUgKGN1cnNvciA8IGxlbiAmJiAhKHNlY29uZFN0YXRlID0gc3RhdGUuZ28odG9rZW5zW2N1cnNvcl0udCkpKSB7XG4gICAgICAvLyBTdGFydGluZyB0b2tlbnMgd2l0aCBub3doZXJlIHRvIGp1bXAgdG8uXG4gICAgICAvLyBDb25zaWRlciB0aGVzZSB0byBiZSBqdXN0IHBsYWluIHRleHRcbiAgICAgIHRleHRUb2tlbnMucHVzaCh0b2tlbnNbY3Vyc29yKytdKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoY3Vyc29yIDwgbGVuICYmIChuZXh0U3RhdGUgPSBzZWNvbmRTdGF0ZSB8fCBzdGF0ZS5nbyh0b2tlbnNbY3Vyc29yXS50KSkpIHtcbiAgICAgIC8vIEdldCB0aGUgbmV4dCBzdGF0ZVxuICAgICAgc2Vjb25kU3RhdGUgPSBudWxsO1xuICAgICAgc3RhdGUgPSBuZXh0U3RhdGU7IC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhdGVzdCBhY2NlcHRpbmcgc3RhdGVcblxuICAgICAgaWYgKHN0YXRlLmFjY2VwdHMoKSkge1xuICAgICAgICBzaW5jZUFjY2VwdHMgPSAwO1xuICAgICAgICBsYXRlc3RBY2NlcHRpbmcgPSBzdGF0ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2luY2VBY2NlcHRzID49IDApIHtcbiAgICAgICAgc2luY2VBY2NlcHRzKys7XG4gICAgICB9XG5cbiAgICAgIGN1cnNvcisrO1xuICAgICAgbXVsdGlMZW5ndGgrKztcbiAgICB9XG5cbiAgICBpZiAoc2luY2VBY2NlcHRzIDwgMCkge1xuICAgICAgLy8gTm8gYWNjZXB0aW5nIHN0YXRlIHdhcyBmb3VuZCwgcGFydCBvZiBhIHJlZ3VsYXIgdGV4dCB0b2tlbiBhZGRcbiAgICAgIC8vIHRoZSBmaXJzdCB0ZXh0IHRva2VuIHRvIHRoZSB0ZXh0IHRva2VucyBhcnJheSBhbmQgdHJ5IGFnYWluIGZyb21cbiAgICAgIC8vIHRoZSBuZXh0XG4gICAgICBjdXJzb3IgLT0gbXVsdGlMZW5ndGg7XG5cbiAgICAgIGlmIChjdXJzb3IgPCBsZW4pIHtcbiAgICAgICAgdGV4dFRva2Vucy5wdXNoKHRva2Vuc1tjdXJzb3JdKTtcbiAgICAgICAgY3Vyc29yKys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFjY2VwdGluZyBzdGF0ZSFcbiAgICAgIC8vIEZpcnN0IGNsb3NlIG9mZiB0aGUgdGV4dFRva2VucyAoaWYgYXZhaWxhYmxlKVxuICAgICAgaWYgKHRleHRUb2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBtdWx0aXMucHVzaChpbml0TXVsdGlUb2tlbihUZXh0LCBpbnB1dCwgdGV4dFRva2VucykpO1xuICAgICAgICB0ZXh0VG9rZW5zID0gW107XG4gICAgICB9IC8vIFJvbGwgYmFjayB0byB0aGUgbGF0ZXN0IGFjY2VwdGluZyBzdGF0ZVxuXG5cbiAgICAgIGN1cnNvciAtPSBzaW5jZUFjY2VwdHM7XG4gICAgICBtdWx0aUxlbmd0aCAtPSBzaW5jZUFjY2VwdHM7IC8vIENyZWF0ZSBhIG5ldyBtdWx0aXRva2VuXG5cbiAgICAgIHZhciBNdWx0aSA9IGxhdGVzdEFjY2VwdGluZy50O1xuICAgICAgdmFyIHN1YnRva2VucyA9IHRva2Vucy5zbGljZShjdXJzb3IgLSBtdWx0aUxlbmd0aCwgY3Vyc29yKTtcbiAgICAgIG11bHRpcy5wdXNoKGluaXRNdWx0aVRva2VuKE11bHRpLCBpbnB1dCwgc3VidG9rZW5zKSk7XG4gICAgfVxuICB9IC8vIEZpbmFsbHkgY2xvc2Ugb2ZmIHRoZSB0ZXh0VG9rZW5zIChpZiBhdmFpbGFibGUpXG5cblxuICBpZiAodGV4dFRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgbXVsdGlzLnB1c2goaW5pdE11bHRpVG9rZW4oVGV4dCwgaW5wdXQsIHRleHRUb2tlbnMpKTtcbiAgfVxuXG4gIHJldHVybiBtdWx0aXM7XG59XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGluc3RhbnRpYXRpbmcgYSBuZXcgbXVsdGl0b2tlbiB3aXRoIGFsbCB0aGUgcmVsZXZhbnRcbiAqIGZpZWxkcyBkdXJpbmcgcGFyc2luZy5cbiAqIEBwYXJhbSB7bmV3ICh2YWx1ZTogc3RyaW5nLCB0b2tlbnM6IFRva2VuW10pID0+IE11bHRpVG9rZW59IE11bHRpIGNsYXNzIHRvIGluc3RhbnRpYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgb3JpZ2luYWwgaW5wdXQgc3RyaW5nXG4gKiBAcGFyYW0ge1Rva2VuW119IHRva2VucyBjb25zZWN1dGl2ZSB0b2tlbnMgc2Nhbm5lZCBmcm9tIGlucHV0IHN0cmluZ1xuICogQHJldHVybnMge011bHRpVG9rZW59XG4gKi9cblxuZnVuY3Rpb24gaW5pdE11bHRpVG9rZW4oTXVsdGksIGlucHV0LCB0b2tlbnMpIHtcbiAgdmFyIHN0YXJ0SWR4ID0gdG9rZW5zWzBdLnM7XG4gIHZhciBlbmRJZHggPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLmU7XG4gIHZhciB2YWx1ZSA9IGlucHV0LnNsaWNlKHN0YXJ0SWR4LCBlbmRJZHgpO1xuICByZXR1cm4gbmV3IE11bHRpKHZhbHVlLCB0b2tlbnMpO1xufVxuXG52YXIgd2FybiA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlICYmIGNvbnNvbGUud2FybiB8fCBmdW5jdGlvbiAoKSB7fTtcblxudmFyIHdhcm5BZHZpY2UgPSAnVG8gYXZvaWQgdGhpcyB3YXJuaW5nLCBwbGVhc2UgcmVnaXN0ZXIgYWxsIGN1c3RvbSBzY2hlbWVzIGJlZm9yZSBpbnZva2luZyBsaW5raWZ5IHRoZSBmaXJzdCB0aW1lLic7IC8vIFNpZGUtZWZmZWN0IGluaXRpYWxpemF0aW9uIHN0YXRlXG5cbnZhciBJTklUID0ge1xuICBzY2FubmVyOiBudWxsLFxuICBwYXJzZXI6IG51bGwsXG4gIHRva2VuUXVldWU6IFtdLFxuICBwbHVnaW5RdWV1ZTogW10sXG4gIGN1c3RvbVNjaGVtZXM6IFtdLFxuICBpbml0aWFsaXplZDogZmFsc2Vcbn07XG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBcdHN0YXJ0OiBTdGF0ZTxzdHJpbmc+LFxuICogXHR0b2tlbnM6IHsgZ3JvdXBzOiBDb2xsZWN0aW9uczxzdHJpbmc+IH0gJiB0eXBlb2YgdGtcbiAqIH19IFNjYW5uZXJJbml0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogXHRzdGFydDogU3RhdGU8TXVsdGlUb2tlbj4sXG4gKiBcdHRva2VuczogdHlwZW9mIG11bHRpXG4gKiB9fSBQYXJzZXJJbml0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KGFyZzogeyBzY2FubmVyOiBTY2FubmVySW5pdCB9KSA9PiB2b2lkfSBUb2tlblBsdWdpblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhhcmc6IHsgc2Nhbm5lcjogU2Nhbm5lckluaXQsIHBhcnNlcjogUGFyc2VySW5pdCB9KSA9PiB2b2lkfSBQbHVnaW5cbiAqL1xuXG4vKipcbiAqIERlLXJlZ2lzdGVyIGFsbCBwbHVnaW5zIGFuZCByZXNldCB0aGUgaW50ZXJuYWwgc3RhdGUtbWFjaGluZS4gVXNlZCBmb3JcbiAqIHRlc3Rpbmc7IG5vdCByZXF1aXJlZCBpbiBwcmFjdGljZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIFN0YXRlLmdyb3VwcyA9IHt9O1xuICBJTklULnNjYW5uZXIgPSBudWxsO1xuICBJTklULnBhcnNlciA9IG51bGw7XG4gIElOSVQudG9rZW5RdWV1ZSA9IFtdO1xuICBJTklULnBsdWdpblF1ZXVlID0gW107XG4gIElOSVQuY3VzdG9tU2NoZW1lcyA9IFtdO1xuICBJTklULmluaXRpYWxpemVkID0gZmFsc2U7XG59XG4vKipcbiAqIFJlZ2lzdGVyIGEgdG9rZW4gcGx1Z2luIHRvIGFsbG93IHRoZSBzY2FubmVyIHRvIHJlY29nbml6ZSBhZGRpdGlvbmFsIHRva2VuXG4gKiB0eXBlcyBiZWZvcmUgdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lIGlzIGNvbnN0cnVjdGVkIGZyb20gdGhlIHJlc3VsdHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBvZiBwbHVnaW4gdG8gcmVnaXN0ZXJcbiAqIEBwYXJhbSB7VG9rZW5QbHVnaW59IHBsdWdpbiBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHNjYW5uZXIgc3RhdGUgbWFjaGluZVxuICogYW5kIGF2YWlsYWJsZSBzY2FubmVyIHRva2VucyBhbmQgY29sbGVjdGlvbnMgYW5kIGV4dGVuZHMgdGhlIHN0YXRlIG1hY2hpbmUgdG9cbiAqIHJlY29nbml6ZSBhZGRpdGlvbmFsIHRva2VucyBvciBncm91cHMuXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJUb2tlblBsdWdpbihuYW1lLCBwbHVnaW4pIHtcbiAgaWYgKHR5cGVvZiBwbHVnaW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsaW5raWZ5anM6IEludmFsaWQgdG9rZW4gcGx1Z2luIFwiICsgcGx1Z2luICsgXCIgKGV4cGVjdHMgZnVuY3Rpb24pXCIpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBJTklULnRva2VuUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobmFtZSA9PT0gSU5JVC50b2tlblF1ZXVlW2ldWzBdKSB7XG4gICAgICB3YXJuKFwibGlua2lmeWpzOiB0b2tlbiBwbHVnaW4gXFxcIlwiICsgbmFtZSArIFwiXFxcIiBhbHJlYWR5IHJlZ2lzdGVyZWQgLSB3aWxsIGJlIG92ZXJ3cml0dGVuXCIpO1xuICAgICAgSU5JVC50b2tlblF1ZXVlW2ldID0gW25hbWUsIHBsdWdpbl07XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgSU5JVC50b2tlblF1ZXVlLnB1c2goW25hbWUsIHBsdWdpbl0pO1xuXG4gIGlmIChJTklULmluaXRpYWxpemVkKSB7XG4gICAgd2FybihcImxpbmtpZnlqczogYWxyZWFkeSBpbml0aWFsaXplZCAtIHdpbGwgbm90IHJlZ2lzdGVyIHRva2VuIHBsdWdpbiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIHVudGlsIHlvdSBtYW51YWxseSBjYWxsIGxpbmtpZnkuaW5pdCgpLiBcIiArIHdhcm5BZHZpY2UpO1xuICB9XG59XG4vKipcbiAqIFJlZ2lzdGVyIGEgbGlua2lmeSBwbHVnaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG9mIHBsdWdpbiB0byByZWdpc3RlclxuICogQHBhcmFtIHtQbHVnaW59IHBsdWdpbiBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lIGFuZFxuICogZXh0ZW5kcyB0aGUgcGFyc2VyIHRvIHJlY29nbml6ZSBhZGRpdGlvbmFsIGxpbmsgdHlwZXNcbiAqL1xuXG5mdW5jdGlvbiByZWdpc3RlclBsdWdpbihuYW1lLCBwbHVnaW4pIHtcbiAgaWYgKHR5cGVvZiBwbHVnaW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsaW5raWZ5anM6IEludmFsaWQgcGx1Z2luIFwiICsgcGx1Z2luICsgXCIgKGV4cGVjdHMgZnVuY3Rpb24pXCIpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBJTklULnBsdWdpblF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5hbWUgPT09IElOSVQucGx1Z2luUXVldWVbaV1bMF0pIHtcbiAgICAgIHdhcm4oXCJsaW5raWZ5anM6IHBsdWdpbiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGFscmVhZHkgcmVnaXN0ZXJlZCAtIHdpbGwgYmUgb3ZlcndyaXR0ZW5cIik7XG4gICAgICBJTklULnBsdWdpblF1ZXVlW2ldID0gW25hbWUsIHBsdWdpbl07XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgSU5JVC5wbHVnaW5RdWV1ZS5wdXNoKFtuYW1lLCBwbHVnaW5dKTtcblxuICBpZiAoSU5JVC5pbml0aWFsaXplZCkge1xuICAgIHdhcm4oXCJsaW5raWZ5anM6IGFscmVhZHkgaW5pdGlhbGl6ZWQgLSB3aWxsIG5vdCByZWdpc3RlciBwbHVnaW4gXFxcIlwiICsgbmFtZSArIFwiXFxcIiB1bnRpbCB5b3UgbWFudWFsbHkgY2FsbCBsaW5raWZ5LmluaXQoKS4gXCIgKyB3YXJuQWR2aWNlKTtcbiAgfVxufVxuLyoqXG4gKiBEZXRlY3QgVVJMcyB3aXRoIHRoZSBmb2xsb3dpbmcgYWRkaXRpb25hbCBwcm90b2NvbC4gQW55dGhpbmcgd2l0aCBmb3JtYXRcbiAqIFwicHJvdG9jb2w6Ly8uLi5cIiB3aWxsIGJlIGNvbnNpZGVyZWQgYSBsaW5rLiBJZiBgb3B0aW9uYWxTbGFzaFNsYXNoYCBpcyBzZXQgdG9cbiAqIGB0cnVlYCwgYW55dGhpbmcgd2l0aCBmb3JtYXQgXCJwcm90b2NvbDouLi5cIiB3aWxsIGJlIGNvbnNpZGVyZWQgYSBsaW5rLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25hbFNsYXNoU2xhc2hdXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJDdXN0b21Qcm90b2NvbChzY2hlbWUsIG9wdGlvbmFsU2xhc2hTbGFzaCkge1xuICBpZiAob3B0aW9uYWxTbGFzaFNsYXNoID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25hbFNsYXNoU2xhc2ggPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChJTklULmluaXRpYWxpemVkKSB7XG4gICAgd2FybihcImxpbmtpZnlqczogYWxyZWFkeSBpbml0aWFsaXplZCAtIHdpbGwgbm90IHJlZ2lzdGVyIGN1c3RvbSBzY2hlbWUgXFxcIlwiICsgc2NoZW1lICsgXCJcXFwiIHVudGlsIHlvdSBtYW51YWxseSBjYWxsIGxpbmtpZnkuaW5pdCgpLiBcIiArIHdhcm5BZHZpY2UpO1xuICB9XG5cbiAgaWYgKCEvXlswLTlhLXpdKygtWzAtOWEtel0rKSokLy50ZXN0KHNjaGVtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbmtpZnlqczogaW5jb3JyZWN0IHNjaGVtZSBmb3JtYXQuXFxuIDEuIE11c3Qgb25seSBjb250YWluIGRpZ2l0cywgbG93ZXJjYXNlIEFTQ0lJIGxldHRlcnMgb3IgXCItXCJcXG4gMi4gQ2Fubm90IHN0YXJ0IG9yIGVuZCB3aXRoIFwiLVwiXFxuIDMuIFwiLVwiIGNhbm5vdCByZXBlYXQnKTtcbiAgfVxuXG4gIElOSVQuY3VzdG9tU2NoZW1lcy5wdXNoKFtzY2hlbWUsIG9wdGlvbmFsU2xhc2hTbGFzaF0pO1xufVxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBsaW5raWZ5IHN0YXRlIG1hY2hpbmUuIENhbGxlZCBhdXRvbWF0aWNhbGx5IHRoZSBmaXJzdCB0aW1lXG4gKiBsaW5raWZ5IGlzIGNhbGxlZCBvbiBhIHN0cmluZywgYnV0IG1heSBiZSBjYWxsZWQgbWFudWFsbHkgYXMgd2VsbC5cbiAqL1xuXG5mdW5jdGlvbiBpbml0KCkge1xuICAvLyBJbml0aWFsaXplIHNjYW5uZXIgc3RhdGUgbWFjaGluZSBhbmQgcGx1Z2luc1xuICBJTklULnNjYW5uZXIgPSBpbml0JDIoSU5JVC5jdXN0b21TY2hlbWVzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IElOSVQudG9rZW5RdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIElOSVQudG9rZW5RdWV1ZVtpXVsxXSh7XG4gICAgICBzY2FubmVyOiBJTklULnNjYW5uZXJcbiAgICB9KTtcbiAgfSAvLyBJbml0aWFsaXplIHBhcnNlciBzdGF0ZSBtYWNoaW5lIGFuZCBwbHVnaW5zXG5cblxuICBJTklULnBhcnNlciA9IGluaXQkMShJTklULnNjYW5uZXIudG9rZW5zKTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgSU5JVC5wbHVnaW5RdWV1ZS5sZW5ndGg7IF9pKyspIHtcbiAgICBJTklULnBsdWdpblF1ZXVlW19pXVsxXSh7XG4gICAgICBzY2FubmVyOiBJTklULnNjYW5uZXIsXG4gICAgICBwYXJzZXI6IElOSVQucGFyc2VyXG4gICAgfSk7XG4gIH1cblxuICBJTklULmluaXRpYWxpemVkID0gdHJ1ZTtcbn1cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgaW50byB0b2tlbnMgdGhhdCByZXByZXNlbnQgbGlua2FibGUgYW5kIG5vbi1saW5rYWJsZSBzdWItY29tcG9uZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7TXVsdGlUb2tlbltdfSB0b2tlbnNcbiAqL1xuXG5mdW5jdGlvbiB0b2tlbml6ZShzdHIpIHtcbiAgaWYgKCFJTklULmluaXRpYWxpemVkKSB7XG4gICAgaW5pdCgpO1xuICB9XG5cbiAgcmV0dXJuIHJ1bihJTklULnBhcnNlci5zdGFydCwgc3RyLCBydW4kMShJTklULnNjYW5uZXIuc3RhcnQsIHN0cikpO1xufVxuLyoqXG4gKiBGaW5kIGEgbGlzdCBvZiBsaW5rYWJsZSBpdGVtcyBpbiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBzdHJpbmcgdG8gZmluZCBsaW5rcyBpblxuICogQHBhcmFtIHtzdHJpbmcgfCBPcHRzfSBbdHlwZV0gZWl0aGVyIGZvcm1hdHRpbmcgb3B0aW9ucyBvciBzcGVjaWZpYyB0eXBlIG9mXG4gKiBsaW5rcyB0byBmaW5kLCBlLmcuLCAndXJsJyBvciAnZW1haWwnXG4gKiBAcGFyYW0ge09wdHN9IFtvcHRzXSBmb3JtYXR0aW5nIG9wdGlvbnMgZm9yIGZpbmFsIG91dHB1dC4gQ2Fubm90IGJlIHNwZWNpZmllZFxuICogaWYgb3B0cyBhbHJlYWR5IHByb3ZpZGVkIGluIGB0eXBlYCBhcmd1bWVudFxuKi9cblxuZnVuY3Rpb24gZmluZChzdHIsIHR5cGUsIG9wdHMpIHtcbiAgaWYgKHR5cGUgPT09IHZvaWQgMCkge1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG5cbiAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgIG9wdHMgPSBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGUgJiYgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIHRocm93IEVycm9yKFwibGlua2lmeWpzOiBJbnZhbGlkIGxpbmsgdHlwZSBcIiArIHR5cGUgKyBcIjsgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICB9XG5cbiAgICBvcHRzID0gdHlwZTtcbiAgICB0eXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gbmV3IE9wdGlvbnMob3B0cyk7XG4gIHZhciB0b2tlbnMgPSB0b2tlbml6ZShzdHIpO1xuICB2YXIgZmlsdGVyZWQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbi5pc0xpbmsgJiYgKCF0eXBlIHx8IHRva2VuLnQgPT09IHR5cGUpKSB7XG4gICAgICBmaWx0ZXJlZC5wdXNoKHRva2VuLnRvRm9ybWF0dGVkT2JqZWN0KG9wdGlvbnMpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmlsdGVyZWQ7XG59XG4vKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgdmFsaWQgbGlua2FibGUgdGV4dCBvZiBzb21lIHNvcnQuIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90XG4gKiB0cmltIHRoZSB0ZXh0IGZvciB5b3UuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGEgc2Vjb25kIGB0eXBlYCBwYXJhbSwgd2hpY2ggaXMgdGhlIHR5cGUgb2YgbGluayB0byB0ZXN0XG4gKiBmb3IuXG4gKlxuICogRm9yIGV4YW1wbGUsXG4gKlxuICogICAgIGxpbmtpZnkudGVzdChzdHIsICdlbWFpbCcpO1xuICpcbiAqIFJldHVybnMgYHRydWVgIGlmIHN0ciBpcyBhIHZhbGlkIGVtYWlsLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBzdHJpbmcgdG8gdGVzdCBmb3IgbGlua3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gb3B0aW9uYWwgc3BlY2lmaWMgbGluayB0eXBlIHRvIGxvb2sgZm9yXG4gKiBAcmV0dXJucyBib29sZWFuIHRydWUvZmFsc2VcbiAqL1xuXG5mdW5jdGlvbiB0ZXN0KHN0ciwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgdHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgdG9rZW5zID0gdG9rZW5pemUoc3RyKTtcbiAgcmV0dXJuIHRva2Vucy5sZW5ndGggPT09IDEgJiYgdG9rZW5zWzBdLmlzTGluayAmJiAoIXR5cGUgfHwgdG9rZW5zWzBdLnQgPT09IHR5cGUpO1xufVxuXG5leHBvcnQgeyBNdWx0aVRva2VuLCBPcHRpb25zLCBTdGF0ZSwgY3JlYXRlVG9rZW5DbGFzcywgZmluZCwgaW5pdCwgbXVsdGksIG9wdGlvbnMsIHJlZ2V4cCwgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbCwgcmVnaXN0ZXJQbHVnaW4sIHJlZ2lzdGVyVG9rZW5QbHVnaW4sIHJlc2V0LCBzdHJpbmdUb0FycmF5LCB0ZXN0LCB0b2tlbml6ZSB9O1xuIl0sIm5hbWVzIjpbInRsZHMiLCJzcGxpdCIsInV0bGRzIiwiYXNzaWduIiwidGFyZ2V0IiwicHJvcGVydGllcyIsImtleSIsIm51bWVyaWMiLCJhc2NpaSIsImFscGhhIiwiYXNjaWludW1lcmljIiwiYWxwaGFudW1lcmljIiwiZG9tYWluIiwiZW1vamkiLCJzY2hlbWUiLCJzbGFzaHNjaGVtZSIsIndoaXRlc3BhY2UiLCJyZWdpc3Rlckdyb3VwIiwibmFtZSIsImdyb3VwcyIsImFkZFRvR3JvdXBzIiwidCIsImZsYWdzIiwiayIsImdyb3VwIiwiaW5kZXhPZiIsInB1c2giLCJmbGFnc0ZvclRva2VuIiwicmVzdWx0IiwiYyIsIlN0YXRlIiwidG9rZW4iLCJqIiwianIiLCJqZCIsInByb3RvdHlwZSIsImFjY2VwdHMiLCJnbyIsImlucHV0Iiwic3RhdGUiLCJuZXh0U3RhdGUiLCJpIiwibGVuZ3RoIiwicmVnZXgiLCJfbmV4dFN0YXRlIiwidGVzdCIsImhhcyIsImV4YWN0T25seSIsInRhIiwiaW5wdXRzIiwibmV4dCIsInR0IiwidHIiLCJyZWdleHAiLCJ0cyIsImxlbiIsInRlbXBsYXRlU3RhdGUiLCJhcHBseSIsImFsbEZsYWdzIiwiV09SRCIsIlVXT1JEIiwiTE9DQUxIT1NUIiwiVExEIiwiVVRMRCIsIlNDSEVNRSIsIlNMQVNIX1NDSEVNRSIsIk5VTSIsIldTIiwiTkwkMSIsIk9QRU5CUkFDRSIsIk9QRU5CUkFDS0VUIiwiT1BFTkFOR0xFQlJBQ0tFVCIsIk9QRU5QQVJFTiIsIkNMT1NFQlJBQ0UiLCJDTE9TRUJSQUNLRVQiLCJDTE9TRUFOR0xFQlJBQ0tFVCIsIkNMT1NFUEFSRU4iLCJBTVBFUlNBTkQiLCJBUE9TVFJPUEhFIiwiQVNURVJJU0siLCJBVCIsIkJBQ0tTTEFTSCIsIkJBQ0tUSUNLIiwiQ0FSRVQiLCJDT0xPTiIsIkNPTU1BIiwiRE9MTEFSIiwiRE9UIiwiRVFVQUxTIiwiRVhDTEFNQVRJT04iLCJIWVBIRU4iLCJQRVJDRU5UIiwiUElQRSIsIlBMVVMiLCJQT1VORCIsIlFVRVJZIiwiUVVPVEUiLCJTRU1JIiwiU0xBU0giLCJUSUxERSIsIlVOREVSU0NPUkUiLCJFTU9KSSQxIiwiU1lNIiwidGsiLCJPYmplY3QiLCJmcmVlemUiLCJfX3Byb3RvX18iLCJOTCIsIkVNT0pJIiwiQVNDSUlfTEVUVEVSIiwiTEVUVEVSIiwiRU1PSklfVkFSSUFUSU9OJDEiLCJESUdJVCIsIlNQQUNFIiwiRU1PSklfVkFSSUFUSU9OIiwiRU1PSklfSk9JTkVSIiwiaW5pdCQyIiwiY3VzdG9tU2NoZW1lcyIsIl90ciIsIl90cjIiLCJfdHIzIiwiX3RyNCIsIl90dCIsIl90cjUiLCJTdGFydCIsIk51bSIsIldvcmQiLCJVV29yZCIsIldzIiwiRW1vamkiLCJFbW9qaUpvaW5lciIsIndvcmRqciIsInV3b3JkanIiLCJmYXN0dHMiLCJfaSIsInRsZCIsInV0bGQiLCJzb3J0IiwiYSIsImIiLCJfaTIiLCJfcmVmIiwiX3JlZjIiLCJzY2giLCJvcHRpb25hbFNsYXNoU2xhc2giLCJzdGFydCIsInRva2VucyIsInJ1biQxIiwic3RyIiwiaXRlcmFibGUiLCJzdHJpbmdUb0FycmF5IiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwiY2hhckNvdW50IiwiY3Vyc29yIiwiY2hhckN1cnNvciIsInRva2VuTGVuZ3RoIiwibGF0ZXN0QWNjZXB0aW5nIiwic2luY2VBY2NlcHRzIiwiY2hhcnNTaW5jZUFjY2VwdHMiLCJ2Iiwic2xpY2UiLCJzIiwiZSIsImluZGV4IiwiZmlyc3QiLCJjaGFyQ29kZUF0Iiwic2Vjb25kIiwiY2hhciIsImRlZmF1bHR0IiwiX2luaGVyaXRzTG9vc2UiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsIl9zZXRQcm90b3R5cGVPZiIsIm8iLCJwIiwic2V0UHJvdG90eXBlT2YiLCJkZWZhdWx0cyIsImRlZmF1bHRQcm90b2NvbCIsImV2ZW50cyIsImZvcm1hdCIsIm5vb3AiLCJmb3JtYXRIcmVmIiwibmwyYnIiLCJ0YWdOYW1lIiwicmVsIiwidmFsaWRhdGUiLCJ0cnVuY2F0ZSIsIkluZmluaXR5IiwiY2xhc3NOYW1lIiwiYXR0cmlidXRlcyIsImlnbm9yZVRhZ3MiLCJyZW5kZXIiLCJPcHRpb25zIiwib3B0cyIsImRlZmF1bHRSZW5kZXIiLCJpZ25vcmVkVGFncyIsInVwcGVyY2FzZUlnbm9yZWRUYWdzIiwidG9VcHBlckNhc2UiLCJpciIsImNoZWNrIiwiZ2V0IiwidG9TdHJpbmciLCJvcGVyYXRvciIsImlzQ2FsbGFibGUiLCJvcHRpb24iLCJnZXRPYmoiLCJvYmoiLCJyZW5kZXJGbiIsInZhbCIsIm9wdGlvbnMiLCJNdWx0aVRva2VuIiwidmFsdWUiLCJpc0xpbmsiLCJ0b0hyZWYiLCJ0b0Zvcm1hdHRlZFN0cmluZyIsImZvcm1hdHRlZCIsInN1YnN0cmluZyIsInRvRm9ybWF0dGVkSHJlZiIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsInRvT2JqZWN0IiwicHJvdG9jb2wiLCJ0eXBlIiwiaHJlZiIsImVuZCIsInRvRm9ybWF0dGVkT2JqZWN0IiwiY29udGVudCIsImF0dHJzIiwiZXZlbnRMaXN0ZW5lcnMiLCJjbGFzcyIsImNyZWF0ZVRva2VuQ2xhc3MiLCJwcm9wcyIsIlRva2VuIiwiX011bHRpVG9rZW4iLCJfdGhpcyIsImNhbGwiLCJFbWFpbCIsIlRleHQiLCJObCIsIlVybCIsImhhc1Byb3RvY29sIiwibXVsdGkiLCJCYXNlIiwibWFrZVN0YXRlIiwiYXJnIiwiaW5pdCQxIiwicXNBY2NlcHRpbmciLCJjb25jYXQiLCJxc05vbkFjY2VwdGluZyIsImxvY2FscGFydEFjY2VwdGluZyIsIkxvY2FscGFydCIsIkRvbWFpbiIsIlNjaGVtZSIsIlNsYXNoU2NoZW1lIiwiTG9jYWxwYXJ0QXQiLCJMb2NhbHBhcnREb3QiLCJFbWFpbERvbWFpbiIsIkVtYWlsRG9tYWluRG90IiwiRW1haWwkMSIsIkVtYWlsRG9tYWluSHlwaGVuIiwiRW1haWxDb2xvbiIsIkRvbWFpbkh5cGhlbiIsIkRvbWFpbkRvdCIsIkRvbWFpbkRvdFRsZCIsIkRvbWFpbkRvdFRsZENvbG9uIiwiRG9tYWluRG90VGxkQ29sb25Qb3J0IiwiVXJsJDEiLCJVcmxOb25hY2NlcHQiLCJVcmlQcmVmaXgiLCJTbGFzaFNjaGVtZUNvbG9uIiwiU2xhc2hTY2hlbWVDb2xvblNsYXNoIiwiVXJsT3BlbmJyYWNlIiwiVXJsT3BlbmJyYWNrZXQiLCJVcmxPcGVuYW5nbGVicmFja2V0IiwiVXJsT3BlbnBhcmVuIiwiVXJsT3BlbmJyYWNlUSIsIlVybE9wZW5icmFja2V0USIsIlVybE9wZW5hbmdsZWJyYWNrZXRRIiwiVXJsT3BlbnBhcmVuUSIsIlVybE9wZW5icmFjZVN5bXMiLCJVcmxPcGVuYnJhY2tldFN5bXMiLCJVcmxPcGVuYW5nbGVicmFja2V0U3ltcyIsIlVybE9wZW5wYXJlblN5bXMiLCJydW4iLCJtdWx0aXMiLCJ0ZXh0VG9rZW5zIiwic2Vjb25kU3RhdGUiLCJtdWx0aUxlbmd0aCIsImluaXRNdWx0aVRva2VuIiwiTXVsdGkiLCJzdWJ0b2tlbnMiLCJzdGFydElkeCIsImVuZElkeCIsIndhcm4iLCJjb25zb2xlIiwid2FybkFkdmljZSIsIklOSVQiLCJzY2FubmVyIiwicGFyc2VyIiwidG9rZW5RdWV1ZSIsInBsdWdpblF1ZXVlIiwiaW5pdGlhbGl6ZWQiLCJyZXNldCIsInJlZ2lzdGVyVG9rZW5QbHVnaW4iLCJwbHVnaW4iLCJFcnJvciIsInJlZ2lzdGVyUGx1Z2luIiwicmVnaXN0ZXJDdXN0b21Qcm90b2NvbCIsImluaXQiLCJ0b2tlbml6ZSIsImZpbmQiLCJmaWx0ZXJlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/linkifyjs/dist/linkify.es.js\n");

/***/ })

};
;